[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Elmfire.jl",
    "section": "",
    "text": "Overview\nElmfire.jl is a pure Julia implementation of the ELMFIRE (Eulerian Level Set Model of FIRE spread) wildfire simulation model. It provides high-performance fire spread modeling with support for:",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Elmfire.jl</span>"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Elmfire.jl",
    "section": "",
    "text": "Rothermel Surface Fire Spread Model - Industry-standard fire behavior calculations\nLevel Set Method - Efficient fire front propagation using the Eulerian approach\nCrown Fire Modeling - Passive and active crown fire transitions\nEmber Transport (Spotting) - Stochastic ember generation and transport\nWeather Interpolation - Spatially and temporally varying weather conditions\nMonte Carlo Ensembles - Probabilistic fire forecasting with parallel execution\nWUI (Wildland-Urban Interface) Models - Building ignition and urban fire spread\nSuppression Models - Fire containment line construction and resource management\nGeospatial I/O - GeoTIFF reading/writing for integration with GIS workflows",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Elmfire.jl</span>"
    ]
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "Elmfire.jl",
    "section": "Features",
    "text": "Features\n\nMulti-Precision Support\nElmfire.jl supports both Float64 (default) and Float32 precision throughout the entire codebase, allowing you to trade off numerical precision for memory efficiency and potentially faster computation on certain hardware.\n\n\nHigh Performance\n\nNarrow Band Method - Only computes fire spread near the active fire front\nMulti-threaded Ensemble Runs - Parallel execution of Monte Carlo simulations\nEfficient Memory Layout - Column-major arrays optimized for Julia\n\n\n\nComprehensive Fire Behavior\n\n53 standard FBFM (Fire Behavior Fuel Models) included\nCustom fuel model support\nDynamic fuel moisture effects\nSlope and aspect terrain effects\nWind-driven elliptical spread patterns",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Elmfire.jl</span>"
    ]
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Elmfire.jl",
    "section": "Quick Start",
    "text": "Quick Start\nusing Elmfire\n\n# Create a fire simulation state (100x100 grid, 30ft cells)\nstate = FireState{Float64}(100, 100, 30.0)\n\n# Create standard fuel model table\nfuel_table = create_standard_fuel_table(Float64)\n\n# Set weather conditions\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 15.0,\n    wind_direction = 270.0,  # From west\n    M1 = 0.06,   # 6% 1-hr fuel moisture\n    M10 = 0.08,\n    M100 = 0.10,\n    MLH = 0.60,\n    MLW = 0.90\n)\n\n# Ignite at center\nignite!(state, 50, 50, 0.0)\n\n# Run for 60 minutes\nsimulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 60.0)\n\n# Get results\nprintln(\"Burned area: \", get_burned_area_acres(state), \" acres\")",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Elmfire.jl</span>"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Elmfire.jl",
    "section": "Installation",
    "text": "Installation\nusing Pkg\nPkg.add(\"Elmfire\")\nOr for the development version:\nusing Pkg\nPkg.develop(path=\"path/to/Elmfire.jl\")",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Elmfire.jl</span>"
    ]
  },
  {
    "objectID": "index.html#documentation-structure",
    "href": "index.html#documentation-structure",
    "title": "Elmfire.jl",
    "section": "Documentation Structure",
    "text": "Documentation Structure\n\nGetting Started - Installation and first simulation\nTutorials - Step-by-step guides with examples\nAPI Reference - Complete function and type documentation",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Elmfire.jl</span>"
    ]
  },
  {
    "objectID": "index.html#funding",
    "href": "index.html#funding",
    "title": "Elmfire.jl",
    "section": "Funding",
    "text": "Funding\nThis work was funded by the NSF CO-WY ASCEND Applied R&D Program.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Elmfire.jl</span>"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Elmfire.jl",
    "section": "License",
    "text": "License\nElmfire.jl is released under the MIT License.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Elmfire.jl</span>"
    ]
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "Setup\nThis tutorial will guide you through running your first wildfire simulation with Elmfire.jl. We’ll cover the basic components and build up to more complex scenarios with visualizations.\nFirst, let’s load the required packages:\nusing Elmfire\nusing Plots\nusing Random\n\n# Set a seed for reproducibility\nRandom.seed!(42)\n\nTaskLocalRNG()",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#understanding-the-components",
    "href": "getting-started.html#understanding-the-components",
    "title": "Getting Started",
    "section": "Understanding the Components",
    "text": "Understanding the Components\nA fire simulation in Elmfire.jl requires several components:\n\nFireState - The simulation grid that tracks fire spread\nFuelModelTable - Lookup table of fuel properties\nWeather - Wind speed, direction, and fuel moisture\nTerrain - Slope and aspect (optional for flat terrain)\n\nLet’s explore each component.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#basic-simulation-flat-terrain-no-wind",
    "href": "getting-started.html#basic-simulation-flat-terrain-no-wind",
    "title": "Getting Started",
    "section": "Basic Simulation: Flat Terrain, No Wind",
    "text": "Basic Simulation: Flat Terrain, No Wind\nLet’s start with the simplest case - a fire spreading on flat terrain with no wind:\n\n# Create a 100x100 grid with 30-foot cells\nncols, nrows = 100, 100\ncellsize = 30.0  # feet\n\nstate = FireState{Float64}(ncols, nrows, cellsize)\n\n# Create fuel model table with standard fuel models\nfuel_table = create_standard_fuel_table(Float64)\n\n# Weather with NO wind\nweather_no_wind = ConstantWeather{Float64}(\n    wind_speed_mph = 0.0,\n    wind_direction = 0.0,\n    M1 = 0.06,   # 6% moisture for 1-hr fuels\n    M10 = 0.08,\n    M100 = 0.10,\n    MLH = 0.60,\n    MLW = 0.90\n)\n\n# Ignite at the center\nignite!(state, 50, 50, 0.0)\n\n# Run simulation for 30 minutes\nsimulate_uniform!(\n    state,\n    1,              # FBFM01 (Short grass)\n    fuel_table,\n    weather_no_wind,\n    0.0,            # Flat terrain (0 degrees slope)\n    0.0,            # Aspect doesn't matter when flat\n    0.0,            # Start time\n    30.0            # End time (30 minutes)\n)\n\n# Visualize the burned area\nheatmap(\n    state.burned',\n    title = \"Fire Spread - No Wind (30 min)\",\n    xlabel = \"X (cells)\",\n    ylabel = \"Y (cells)\",\n    color = :YlOrRd,\n    aspect_ratio = 1,\n    size = (500, 500)\n)\n\n\n\n\nWith no wind, the fire spreads roughly circularly from the ignition point. This is because the spread rate is uniform in all directions.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#adding-wind-elliptical-fire-spread",
    "href": "getting-started.html#adding-wind-elliptical-fire-spread",
    "title": "Getting Started",
    "section": "Adding Wind: Elliptical Fire Spread",
    "text": "Adding Wind: Elliptical Fire Spread\nNow let’s add wind and see how it changes the fire shape:\n\n# Reset the state\nstate = FireState{Float64}(ncols, nrows, cellsize)\n\n# Weather WITH wind from the west (blowing east)\nweather_wind = ConstantWeather{Float64}(\n    wind_speed_mph = 15.0,\n    wind_direction = 270.0,  # Wind FROM west\n    M1 = 0.06,\n    M10 = 0.08,\n    M100 = 0.10,\n    MLH = 0.60,\n    MLW = 0.90\n)\n\n# Ignite at center\nignite!(state, 50, 50, 0.0)\n\n# Run simulation\nsimulate_uniform!(state, 1, fuel_table, weather_wind, 0.0, 0.0, 0.0, 30.0)\n\n# Visualize\nheatmap(\n    state.burned',\n    title = \"Fire Spread - 15 mph Wind from West (30 min)\",\n    xlabel = \"X (cells)\",\n    ylabel = \"Y (cells)\",\n    color = :YlOrRd,\n    aspect_ratio = 1,\n    size = (500, 500)\n)\n\n\n\n\nThe fire now spreads in an elliptical pattern, moving much faster downwind (to the east) than upwind.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#comparing-wind-speeds",
    "href": "getting-started.html#comparing-wind-speeds",
    "title": "Getting Started",
    "section": "Comparing Wind Speeds",
    "text": "Comparing Wind Speeds\nLet’s compare how different wind speeds affect fire spread:\n\nwind_speeds = [0, 5, 10, 20]\nplots_wind = []\n\nfor ws in wind_speeds\n    state = FireState{Float64}(ncols, nrows, cellsize)\n\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = Float64(ws),\n        wind_direction = 270.0,\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n\n    ignite!(state, 50, 50, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 30.0)\n\n    p = heatmap(\n        state.burned',\n        title = \"Wind: $ws mph\",\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false,\n        axis = false\n    )\n    push!(plots_wind, p)\nend\n\nplot(plots_wind..., layout = (2, 2), size = (800, 800))\n\n\n\n\nAs wind speed increases:\n\nFire spread becomes more elliptical\nThe head fire (downwind) moves much faster\nThe backing fire (upwind) moves very slowly\nTotal burned area increases significantly",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#effect-of-wind-direction",
    "href": "getting-started.html#effect-of-wind-direction",
    "title": "Getting Started",
    "section": "Effect of Wind Direction",
    "text": "Effect of Wind Direction\nLet’s see how wind direction affects the fire spread pattern:\n\nwind_directions = [0, 90, 180, 270]  # N, E, S, W\ndirection_labels = [\"From North\", \"From East\", \"From South\", \"From West\"]\nplots_dir = []\n\nfor (wd, label) in zip(wind_directions, direction_labels)\n    state = FireState{Float64}(ncols, nrows, cellsize)\n\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 15.0,\n        wind_direction = Float64(wd),\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n\n    ignite!(state, 50, 50, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 30.0)\n\n    p = heatmap(\n        state.burned',\n        title = label,\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false\n    )\n    push!(plots_dir, p)\nend\n\nplot(plots_dir..., layout = (2, 2), size = (800, 800))",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#fuel-moisture-effects",
    "href": "getting-started.html#fuel-moisture-effects",
    "title": "Getting Started",
    "section": "Fuel Moisture Effects",
    "text": "Fuel Moisture Effects\nFuel moisture is critical to fire behavior. Drier fuels burn more intensely:\n\nmoisture_levels = [(0.03, \"Very Dry (3%)\"), (0.06, \"Dry (6%)\"),\n                   (0.10, \"Moderate (10%)\"), (0.15, \"Moist (15%)\")]\nplots_moisture = []\n\nfor (m1, label) in moisture_levels\n    state = FireState{Float64}(ncols, nrows, cellsize)\n\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 10.0,\n        wind_direction = 270.0,\n        M1 = m1,\n        M10 = m1 + 0.02,\n        M100 = m1 + 0.04,\n        MLH = 0.60,\n        MLW = 0.90\n    )\n\n    ignite!(state, 50, 50, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 30.0)\n\n    acres = get_burned_area_acres(state)\n    p = heatmap(\n        state.burned',\n        title = \"$label\\n$(round(acres, digits=1)) acres\",\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false\n    )\n    push!(plots_moisture, p)\nend\n\nplot(plots_moisture..., layout = (2, 2), size = (800, 800))\n\n\n\n\nLower fuel moisture = faster spread and more area burned!",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#different-fuel-types",
    "href": "getting-started.html#different-fuel-types",
    "title": "Getting Started",
    "section": "Different Fuel Types",
    "text": "Different Fuel Types\nThe fuel model dramatically affects fire behavior. Let’s compare a few standard fuel models:\n\nfuel_models = [\n    (1, \"FBFM01: Short Grass\"),\n    (4, \"FBFM04: Chaparral\"),\n    (8, \"FBFM08: Timber Litter\"),\n    (13, \"FBFM13: Heavy Slash\")\n]\nplots_fuel = []\n\nfor (fuel_id, label) in fuel_models\n    state = FireState{Float64}(ncols, nrows, cellsize)\n\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 10.0,\n        wind_direction = 270.0,\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n\n    ignite!(state, 50, 50, 0.0)\n    simulate_uniform!(state, fuel_id, fuel_table, weather, 0.0, 0.0, 0.0, 30.0)\n\n    acres = get_burned_area_acres(state)\n    p = heatmap(\n        state.burned',\n        title = \"$label\\n$(round(acres, digits=1)) acres\",\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false\n    )\n    push!(plots_fuel, p)\nend\n\nplot(plots_fuel..., layout = (2, 2), size = (800, 800))\n\n\n\n\nEach fuel model has different:\n\nFuel loading (amount of fuel)\nSurface area to volume ratio (how quickly it burns)\nFuel bed depth (affects wind adjustment)\nMoisture of extinction (how wet it can be and still burn)",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#terrain-effects-slope",
    "href": "getting-started.html#terrain-effects-slope",
    "title": "Getting Started",
    "section": "Terrain Effects: Slope",
    "text": "Terrain Effects: Slope\nFire spreads faster uphill. Let’s compare different slopes:\n\nslopes = [0, 10, 20, 30]  # degrees\nplots_slope = []\n\nfor slp in slopes\n    state = FireState{Float64}(ncols, nrows, cellsize)\n\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 5.0,\n        wind_direction = 180.0,  # From south\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n\n    ignite!(state, 50, 50, 0.0)\n\n    # Uphill to the north (aspect = 180 means slope faces south)\n    simulate_uniform!(state, 1, fuel_table, weather, Float64(slp), 180.0, 0.0, 30.0)\n\n    acres = get_burned_area_acres(state)\n    p = heatmap(\n        state.burned',\n        title = \"Slope: $(slp)°\\n$(round(acres, digits=1)) acres\",\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false\n    )\n    push!(plots_slope, p)\nend\n\nplot(plots_slope..., layout = (2, 2), size = (800, 800))\n\n\n\n\nSteeper slopes cause faster uphill spread due to:\n\nPreheating of uphill fuels by convection\nFlames directly contacting uphill fuels\nIncreased effective wind (draft effect)",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#time-of-arrival-map",
    "href": "getting-started.html#time-of-arrival-map",
    "title": "Getting Started",
    "section": "Time of Arrival Map",
    "text": "Time of Arrival Map\nThe time_of_arrival field shows when each cell burned:\n\nstate = FireState{Float64}(ncols, nrows, cellsize)\n\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 12.0,\n    wind_direction = 270.0,\n    M1 = 0.06, M10 = 0.08, M100 = 0.10,\n    MLH = 0.60, MLW = 0.90\n)\n\nignite!(state, 50, 50, 0.0)\nsimulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 45.0)\n\n# Replace -1 (unburned) with NaN for plotting\ntoa = copy(state.time_of_arrival)\ntoa[toa .&lt; 0] .= NaN\n\nheatmap(\n    toa',\n    title = \"Time of Arrival (minutes)\",\n    xlabel = \"X (cells)\",\n    ylabel = \"Y (cells)\",\n    color = :viridis,\n    aspect_ratio = 1,\n    size = (600, 500)\n)\n\n\n\n\nThe time of arrival map is useful for:\n\nEvacuation planning\nResource deployment timing\nUnderstanding fire progression",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#fireline-intensity",
    "href": "getting-started.html#fireline-intensity",
    "title": "Getting Started",
    "section": "Fireline Intensity",
    "text": "Fireline Intensity\nFireline intensity (kW/m) indicates fire severity:\n\nstate = FireState{Float64}(ncols, nrows, cellsize)\n\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 15.0,\n    wind_direction = 270.0,\n    M1 = 0.04, M10 = 0.06, M100 = 0.08,\n    MLH = 0.50, MLW = 0.80\n)\n\nignite!(state, 50, 50, 0.0)\nsimulate_uniform!(state, 4, fuel_table, weather, 5.0, 180.0, 0.0, 30.0)  # Chaparral on slope\n\n# Plot fireline intensity\nflin = copy(state.fireline_intensity)\nflin[flin .== 0] .= NaN\n\nheatmap(\n    flin',\n    title = \"Fireline Intensity (kW/m)\",\n    xlabel = \"X (cells)\",\n    ylabel = \"Y (cells)\",\n    color = :inferno,\n    aspect_ratio = 1,\n    size = (600, 500)\n)\n\n\n\n\nFireline intensity classifications:\n\n&lt; 350 kW/m: Low intensity, hand crews can work directly\n350-1700 kW/m: Moderate, mechanical equipment needed\n1700-3500 kW/m: High, aerial support required\n&gt; 3500 kW/m: Very high, control very difficult",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#fire-progression-over-time",
    "href": "getting-started.html#fire-progression-over-time",
    "title": "Getting Started",
    "section": "Fire Progression Over Time",
    "text": "Fire Progression Over Time\nLet’s visualize how a fire grows over time:\n\ntimes = [5, 15, 30, 60]\nplots_time = []\n\nfor t_end in times\n    state = FireState{Float64}(150, 150, cellsize)\n\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 12.0,\n        wind_direction = 270.0,\n        M1 = 0.05, M10 = 0.07, M100 = 0.09,\n        MLH = 0.55, MLW = 0.85\n    )\n\n    ignite!(state, 75, 75, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, Float64(t_end))\n\n    acres = get_burned_area_acres(state)\n    p = heatmap(\n        state.burned',\n        title = \"t = $t_end min\\n$(round(acres, digits=1)) acres\",\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false\n    )\n    push!(plots_time, p)\nend\n\nplot(plots_time..., layout = (2, 2), size = (800, 800),\n     plot_title = \"Fire Growth Over Time\")",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#multiple-ignition-points",
    "href": "getting-started.html#multiple-ignition-points",
    "title": "Getting Started",
    "section": "Multiple Ignition Points",
    "text": "Multiple Ignition Points\nYou can simulate fires with multiple ignition points:\n\nstate = FireState{Float64}(150, 150, cellsize)\n\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 8.0,\n    wind_direction = 270.0,\n    M1 = 0.06, M10 = 0.08, M100 = 0.10,\n    MLH = 0.60, MLW = 0.90\n)\n\n# Multiple ignition points\nignite!(state, 50, 75, 0.0)\nignite!(state, 100, 75, 5.0)  # 5 minutes later\nignite!(state, 75, 50, 10.0)  # 10 minutes later\n\nsimulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 45.0)\n\n# Show time of arrival to see fire merger\ntoa = copy(state.time_of_arrival)\ntoa[toa .&lt; 0] .= NaN\n\nheatmap(\n    toa',\n    title = \"Multiple Ignitions - Time of Arrival\",\n    color = :viridis,\n    aspect_ratio = 1,\n    size = (600, 500)\n)",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#whats-next",
    "href": "getting-started.html#whats-next",
    "title": "Getting Started",
    "section": "What’s Next?",
    "text": "What’s Next?\nNow that you understand the basics, explore more advanced topics:\n\nWeather Effects - Time-varying weather\nCrown Fire - Active and passive crown fire\nSpotting - Ember transport and spot fires\nEnsemble Simulations - Probabilistic forecasting\nWUI Modeling - Building ignition\nSuppression - Fire containment",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "comparison.html",
    "href": "comparison.html",
    "title": "Comparison with Original ELMFIRE",
    "section": "",
    "text": "At a Glance\nELMFIRE (Eulerian Level Set Model of FIRE spread) was originally developed by Chris Lautenberger as a Fortran-based operational wildfire simulation system. It is used by the Pyrecast project to forecast the spread of large fires across the Continental US. The mathematical formulation is described in the original journal article.\nElmfire.jl is a ground-up rewrite of ELMFIRE in Julia. It reimplements the core algorithms but differs substantially in software architecture. The fire physics (Rothermel spread model, level set solver, crown fire, spotting) are faithful to the original formulation. This page documents the key differences between the two implementations.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comparison with Original ELMFIRE</span>"
    ]
  },
  {
    "objectID": "comparison.html#at-a-glance",
    "href": "comparison.html#at-a-glance",
    "title": "Comparison with Original ELMFIRE",
    "section": "",
    "text": "Original ELMFIRE\nElmfire.jl\n\n\n\n\nLanguage\nFortran + Shell + Python\nJulia\n\n\nLines of code\n~28,000 (14K Fortran, 11K Shell, 3K Python)\n~7,000\n\n\nParallelism\nMPI (distributed)\nJulia threads + Distributed\n\n\nConfiguration\nFortran namelists\nJulia structs and keyword arguments\n\n\nGeospatial I/O\nDirect GDAL / C bindings\nArchGDAL.jl and Rasters.jl\n\n\nNumeric precision\nDouble precision\nGeneric (Float32 or Float64)\n\n\nTesting\nVerification/validation scripts\nUnit tests with CI\n\n\nMaturity\nOperational, peer-reviewed\nIn development\n\n\nLicense\nEclipse Public License 2.0\nMIT",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comparison with Original ELMFIRE</span>"
    ]
  },
  {
    "objectID": "comparison.html#language",
    "href": "comparison.html#language",
    "title": "Comparison with Original ELMFIRE",
    "section": "Language",
    "text": "Language\nThe original ELMFIRE uses Fortran for the core simulation (~14,000 lines), shell scripts for orchestration and job management (~11,000 lines), and Python for pre/post-processing (~3,000 lines).\nElmfire.jl uses Julia for all components (~7,000 lines). The line count difference partly reflects Julia’s expressiveness and partly reflects that the original includes operational tooling (cloud deployment, gRPC services, etc.) that Elmfire.jl does not yet cover.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comparison with Original ELMFIRE</span>"
    ]
  },
  {
    "objectID": "comparison.html#development-workflow",
    "href": "comparison.html#development-workflow",
    "title": "Comparison with Original ELMFIRE",
    "section": "Development Workflow",
    "text": "Development Workflow\nThe original ELMFIRE is a compiled executable. Parameters are set via namelist files, and code changes require recompilation.\nElmfire.jl runs in the Julia REPL or notebooks, allowing interactive parameter adjustment and visualization without recompilation:\nweather = ConstantWeather{Float64}(wind_speed_mph=20.0, wind_direction=270.0,\n    M1=0.06, M10=0.08, M100=0.10, MLH=0.60, MLW=0.90)\nreset!(state)\nignite!(state, 50, 50, 0.0)\nsimulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 30.0)\nThe trade-off is that Julia has longer startup and compilation times compared to a pre-built Fortran binary.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comparison with Original ELMFIRE</span>"
    ]
  },
  {
    "objectID": "comparison.html#numeric-precision",
    "href": "comparison.html#numeric-precision",
    "title": "Comparison with Original ELMFIRE",
    "section": "Numeric Precision",
    "text": "Numeric Precision\nThe original ELMFIRE uses double-precision floating point throughout. Elmfire.jl parameterizes core types on AbstractFloat, allowing either Float64 or Float32:\nstate64 = FireState{Float64}(100, 100, 30.0)\nstate32 = FireState{Float32}(100, 100, 30f0)\nThis is useful for exploring memory/performance trade-offs, though Float64 remains the default and is recommended for production use.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comparison with Original ELMFIRE</span>"
    ]
  },
  {
    "objectID": "comparison.html#parallelism",
    "href": "comparison.html#parallelism",
    "title": "Comparison with Original ELMFIRE",
    "section": "Parallelism",
    "text": "Parallelism\nThe original ELMFIRE uses MPI for distributed parallelism with domain decomposition. This scales well across HPC clusters and is battle-tested in operational forecasting.\nElmfire.jl uses Julia’s native threading for ensemble runs (run_ensemble_threaded!), running independent simulations in parallel without domain decomposition. Julia’s Distributed module is available for multi-node scaling. This approach is simpler but does not yet match the original’s MPI scalability for single large-domain simulations.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comparison with Original ELMFIRE</span>"
    ]
  },
  {
    "objectID": "comparison.html#configuration",
    "href": "comparison.html#configuration",
    "title": "Comparison with Original ELMFIRE",
    "section": "Configuration",
    "text": "Configuration\nThe original ELMFIRE reads parameters from Fortran namelist files. Elmfire.jl uses Julia structs with keyword arguments:\nconfig = SimulationConfig{Float64}(\n    enable_crown_fire = true,\n    foliar_moisture = 100.0\n)\nNamelist files are language-agnostic and well-suited for batch job submission. Julia structs are type-checked and composable but require Julia to work with.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comparison with Original ELMFIRE</span>"
    ]
  },
  {
    "objectID": "comparison.html#geospatial-io",
    "href": "comparison.html#geospatial-io",
    "title": "Comparison with Original ELMFIRE",
    "section": "Geospatial I/O",
    "text": "Geospatial I/O\nBoth implementations read and write GeoTIFF rasters via GDAL. The original ELMFIRE uses Fortran/C bindings directly. Elmfire.jl uses ArchGDAL.jl and Rasters.jl for higher-level raster handling.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comparison with Original ELMFIRE</span>"
    ]
  },
  {
    "objectID": "comparison.html#testing",
    "href": "comparison.html#testing",
    "title": "Comparison with Original ELMFIRE",
    "section": "Testing",
    "text": "Testing\nThe original ELMFIRE includes verification cases and validation scripts for known fire scenarios.\nElmfire.jl has a unit test suite covering each module (Rothermel, level set, crown fire, spotting, weather, ensemble, etc.) that runs in CI on every commit. However, Elmfire.jl has not yet undergone the same level of real-world validation as the original.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comparison with Original ELMFIRE</span>"
    ]
  },
  {
    "objectID": "comparison.html#maturity",
    "href": "comparison.html#maturity",
    "title": "Comparison with Original ELMFIRE",
    "section": "Maturity",
    "text": "Maturity\nThe original ELMFIRE is a mature, operationally deployed system. It has been peer-reviewed, validated against real fires, and used in production forecasting through Pyrecast.\nElmfire.jl is a newer implementation still under active development. While the core algorithms are implemented and tested, it has not yet been validated to the same degree and should be considered experimental for operational use.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comparison with Original ELMFIRE</span>"
    ]
  },
  {
    "objectID": "comparison.html#what-stays-the-same",
    "href": "comparison.html#what-stays-the-same",
    "title": "Comparison with Original ELMFIRE",
    "section": "What Stays the Same",
    "text": "What Stays the Same\nThe fire science is the same. Both implementations use:\n\nRothermel (1972) surface fire spread model\nLevel set PDE with upwind differencing and narrow-band tracking\nSuperbee flux limiter for gradient calculation\n2nd-order Runge-Kutta time integration\nCFL-adaptive timestep for numerical stability\nVan Wagner (1977) crown fire initiation\nCruz et al. (2005) active crown fire spread rate\n53 standard FBFM fuel models\nElliptical fire shape (Anderson, 1983)\n\nFor equivalent inputs, the two implementations should produce consistent fire behavior outputs.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Comparison with Original ELMFIRE</span>"
    ]
  },
  {
    "objectID": "gpu.html",
    "href": "gpu.html",
    "title": "GPU Acceleration",
    "section": "",
    "text": "Status\nElmfire.jl is designed with GPU acceleration in mind. This page describes the current state, the planned approach, and the computational profile that motivates the work.\nPhase 0 (complete): Core types have been refactored to support GPU arrays.\nPhase 1+ (planned): GPU kernels, ensemble support, and optimization. See below.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>GPU Acceleration</span>"
    ]
  },
  {
    "objectID": "gpu.html#status",
    "href": "gpu.html#status",
    "title": "GPU Acceleration",
    "section": "",
    "text": "FireState{T, A} is parameterized on array type A, so it can hold either Matrix{T} (CPU) or GPU arrays.\nFuelModelArray{T} provides a dense struct-of-arrays fuel model lookup, replacing the Dict-based FuelModelTable which cannot run on GPU.\nactive_mask() converts the narrow band’s Set to a dense BitMatrix for GPU kernel masking.\nsurface_spread_rate_flat() computes Rothermel spread rates from FuelModelArray using array indexing instead of struct access.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>GPU Acceleration</span>"
    ]
  },
  {
    "objectID": "gpu.html#computational-profile",
    "href": "gpu.html#computational-profile",
    "title": "GPU Acceleration",
    "section": "Computational Profile",
    "text": "Computational Profile\nOn a 512x512 grid with ~1,000 active cells in the narrow band, each simulation timestep breaks down roughly as:\n\n\n\n\n\n\n\n\nComponent\nTime\nParallelizable?\n\n\n\n\nVelocity calculation (Rothermel + wind)\n~100 ms\nYes (per-cell, independent)\n\n\nCrown fire\n~70 ms\nYes (per-cell, independent)\n\n\nLevel set RK2\n~10 ms\nYes (stencil, structured)\n\n\nWeather interpolation\n~10 ms\nYes (per-cell lookup)\n\n\nNarrow band updates\n~10 ms\nNo (set operations)\n\n\n\nThe first four components (~190 ms) are candidates for GPU offloading. The narrow band management (~10 ms) stays on the CPU.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>GPU Acceleration</span>"
    ]
  },
  {
    "objectID": "gpu.html#approach",
    "href": "gpu.html#approach",
    "title": "GPU Acceleration",
    "section": "Approach",
    "text": "Approach\n\nKernelAbstractions.jl\nGPU kernels will be written with KernelAbstractions.jl (KA), which provides a vendor-agnostic @kernel macro. The same kernel code runs on:\n\nNVIDIA GPUs (via CUDA.jl)\nAMD GPUs (via AMDGPU.jl)\nApple Silicon (via Metal.jl)\nCPU (for testing without GPU hardware)\n\n\n\nPackage Extension\nGPU support will be shipped as a package extension so that users without GPUs pay no dependency cost:\n# Project.toml\n[weakdeps]\nKernelAbstractions = \"...\"\nAdapt = \"...\"\n\n[extensions]\nElmfireKAExt = [\"KernelAbstractions\", \"Adapt\"]\n\n\nCPU/GPU Boundary\nThe narrow band is managed on the CPU (it uses Set operations). Each timestep:\n\nCPU collects active cells and builds a mask\nMask is uploaded to GPU\nGPU runs velocity, CFL, and RK2 kernels\nNewly burned cell indices are downloaded to CPU\nCPU updates narrow band and burned status\n\nGrid arrays (phi, ux, uy) stay resident on the GPU between timesteps to minimize transfers.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>GPU Acceleration</span>"
    ]
  },
  {
    "objectID": "gpu.html#planned-phases",
    "href": "gpu.html#planned-phases",
    "title": "GPU Acceleration",
    "section": "Planned Phases",
    "text": "Planned Phases\n\nPhase 1: GPU Velocity Kernel\nThe velocity calculation (Rothermel + elliptical spread + normal computation) dominates runtime. A single @kernel computes spread rate and velocity components for all active cells in parallel:\n@kernel function velocity_kernel!(ux, uy, phi, active_mask, fuel_ids,\n                                   fuel_array, slope, aspect, weather_fields,\n                                   cellsize, padding, ncols, nrows)\n    px, py = @index(Global, NTuple)\n    active_mask[px, py] || return\n    # Rothermel spread rate from fuel_array\n    # Normal vector from phi stencil\n    # Elliptical spread + velocity components\n    ux[px, py] = ...\n    uy[px, py] = ...\nend\nThis phase also includes CFL reduction and RK2 stencil kernels.\n\n\nPhase 2: GPU Ensemble Support\nMultiple ensemble members run concurrently using GPU streams. Each stream executes an independent simulation, reusing the run_ensemble_threaded! pattern with GPU-accelerated inner loops.\n\n\nPhase 3: Optimization\n\nDual-mode launch: 1D kernel over an index list for small fires (&lt;5K active cells); 2D grid kernel with mask for large fires.\nPersistent GPU state: Eliminate per-timestep mask uploads by detecting newly burned cells on GPU.\nFloat32 fast path: Already supported by the type system; validate precision on GPU.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>GPU Acceleration</span>"
    ]
  },
  {
    "objectID": "gpu.html#projected-performance",
    "href": "gpu.html#projected-performance",
    "title": "GPU Acceleration",
    "section": "Projected Performance",
    "text": "Projected Performance\nEstimates assume a mid-to-high-end GPU (e.g. NVIDIA A100) on a 512x512 grid:\n\n\n\nComponent\nCPU\nGPU (est.)\nSpeedup\n\n\n\n\nVelocity calculation\n~170 ms\n~2-5 ms\n30-80x\n\n\nRK2 level set\n~10 ms\n~0.2 ms\n50x\n\n\nCFL reduction\n~1 ms\n~0.1 ms\n10x\n\n\nNarrow band (CPU)\n~10 ms\n~10 ms\n1x\n\n\nTotal per timestep\n~200 ms\n~15-20 ms\n10-15x\n\n\n\nThe narrow band management on CPU becomes the bottleneck on GPU. For larger grids or more active cells, the GPU advantage grows because the CPU-side cost is proportionally smaller.\nThese are projections, not benchmarks. Actual performance will depend on hardware, grid size, and fire characteristics.",
    "crumbs": [
      "Docs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>GPU Acceleration</span>"
    ]
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Basic Tutorials\nThese tutorials provide in-depth coverage of Elmfire.jl’s features with practical examples.",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tutorials</span>"
    ]
  },
  {
    "objectID": "tutorials/index.html#basic-tutorials",
    "href": "tutorials/index.html#basic-tutorials",
    "title": "Tutorials",
    "section": "",
    "text": "Basic Simulation - Core simulation concepts and API\nWeather Effects - Wind, moisture, and time-varying weather\nTerrain Effects - Slope, aspect, and topographic influence",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tutorials</span>"
    ]
  },
  {
    "objectID": "tutorials/index.html#advanced-fire-behavior",
    "href": "tutorials/index.html#advanced-fire-behavior",
    "title": "Tutorials",
    "section": "Advanced Fire Behavior",
    "text": "Advanced Fire Behavior\n\nCrown Fire - Passive and active crown fire modeling\nSpotting - Ember generation and transport",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tutorials</span>"
    ]
  },
  {
    "objectID": "tutorials/index.html#operational-features",
    "href": "tutorials/index.html#operational-features",
    "title": "Tutorials",
    "section": "Operational Features",
    "text": "Operational Features\n\nEnsemble Simulations - Monte Carlo probabilistic forecasting\nWUI Modeling - Wildland-urban interface and building ignition\nSuppression - Fire containment and resource management",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tutorials</span>"
    ]
  },
  {
    "objectID": "tutorials/index.html#prerequisites",
    "href": "tutorials/index.html#prerequisites",
    "title": "Tutorials",
    "section": "Prerequisites",
    "text": "Prerequisites\nAll tutorials assume you have Elmfire.jl installed:\nusing Pkg\nPkg.add(\"Elmfire\")\nAnd the following packages for visualization:\nPkg.add(\"Plots\")",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Tutorials</span>"
    ]
  },
  {
    "objectID": "tutorials/basic-simulation.html",
    "href": "tutorials/basic-simulation.html",
    "title": "Basic Simulation",
    "section": "",
    "text": "The FireState Structure\nThis tutorial covers the fundamental components of an Elmfire.jl simulation.\nThe FireState is the central data structure that holds all simulation state:\nusing Elmfire\nusing Plots\n\n# Create a fire state\nstate = FireState{Float64}(100, 100, 30.0)\n\nprintln(\"Grid dimensions: $(state.ncols) x $(state.nrows)\")\nprintln(\"Cell size: $(state.cellsize) ft\")\nprintln(\"Padding: $(state.padding) cells\")\nprintln(\"Phi array size: \", size(state.phi))\n\nGrid dimensions: 100 x 100\nCell size: 30.0 ft\nPadding: 2 cells\nPhi array size: (104, 104)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Simulation</span>"
    ]
  },
  {
    "objectID": "tutorials/basic-simulation.html#the-firestate-structure",
    "href": "tutorials/basic-simulation.html#the-firestate-structure",
    "title": "Basic Simulation",
    "section": "",
    "text": "Key Fields\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nphi\nMatrix{T}\nLevel set field (negative = burned)\n\n\nburned\nBitMatrix\nBoolean burned map\n\n\ntime_of_arrival\nMatrix{T}\nWhen each cell burned (-1 = unburned)\n\n\nspread_rate\nMatrix{T}\nSpread rate at burn time (ft/min)\n\n\nfireline_intensity\nMatrix{T}\nIntensity at burn time (kW/m)\n\n\nflame_length\nMatrix{T}\nFlame length at burn time (ft)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Simulation</span>"
    ]
  },
  {
    "objectID": "tutorials/basic-simulation.html#fuel-models",
    "href": "tutorials/basic-simulation.html#fuel-models",
    "title": "Basic Simulation",
    "section": "Fuel Models",
    "text": "Fuel Models\nFuel models describe the physical properties of vegetation that affect fire behavior:\n\n# Create the standard fuel table\nfuel_table = create_standard_fuel_table(Float64)\n\n# Get a specific fuel model\nfm = get_fuel_model(fuel_table, 1, 60)  # FBFM01 at live moisture class 60\n\nprintln(\"Fuel Model: \", fm.name)\nprintln(\"Fuel bed depth: \", fm.delta, \" ft\")\nprintln(\"1-hr load: \", fm.W0[1], \" lb/ft²\")\nprintln(\"Dead fuel extinction moisture: \", fm.mex_dead)\n\nFuel Model: FBFM01\nFuel bed depth: 1.0 ft\n1-hr load: 0.034 lb/ft²\nDead fuel extinction moisture: 0.12\n\n\n\nStandard Fuel Models\nThe 13 original FBFM models plus 40 additional Scott & Burgan models are included:\n\n# List available fuel models\nfuel_ids = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nnames = [get_fuel_model(fuel_table, id, 60).name for id in fuel_ids]\n\nfor (id, name) in zip(fuel_ids, names)\n    println(\"FBFM$id: $name\")\nend\n\nFBFM1: FBFM01\nFBFM2: FBFM02\nFBFM3: FBFM03\nFBFM4: FBFM04\nFBFM5: FBFM05\nFBFM6: FBFM06\nFBFM7: FBFM07\nFBFM8: FBFM08\nFBFM9: FBFM09\nFBFM10: FBFM10\nFBFM11: FBFM11\nFBFM12: FBFM12\nFBFM13: FBFM13",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Simulation</span>"
    ]
  },
  {
    "objectID": "tutorials/basic-simulation.html#weather-conditions",
    "href": "tutorials/basic-simulation.html#weather-conditions",
    "title": "Basic Simulation",
    "section": "Weather Conditions",
    "text": "Weather Conditions\nWeather is specified using ConstantWeather for uniform conditions:\n\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 15.0,      # 20-ft wind speed\n    wind_direction = 270.0,     # Meteorological (FROM direction)\n    M1 = 0.06,                  # 1-hr dead fuel moisture (fraction)\n    M10 = 0.08,                 # 10-hr dead fuel moisture\n    M100 = 0.10,                # 100-hr dead fuel moisture\n    MLH = 0.60,                 # Live herbaceous moisture\n    MLW = 0.90                  # Live woody moisture\n)\n\nConstantWeather{Float64}(15.0, 270.0, 0.06, 0.08, 0.1, 0.6, 0.9)\n\n\n\nWind Direction Convention\nWind direction uses the meteorological convention (direction wind is coming FROM):\n\n0° = Wind from the North (fire spreads South)\n90° = Wind from the East (fire spreads West)\n180° = Wind from the South (fire spreads North)\n270° = Wind from the West (fire spreads East)\n\n\ndirections = [0, 90, 180, 270]\nlabels = [\"N→S\", \"E→W\", \"S→N\", \"W→E\"]\nplots = []\n\nfor (wd, lbl) in zip(directions, labels)\n    state = FireState{Float64}(60, 60, 30.0)\n    w = ConstantWeather{Float64}(wind_speed_mph=12.0, wind_direction=Float64(wd),\n        M1=0.06, M10=0.08, M100=0.10, MLH=0.60, MLW=0.90)\n    ignite!(state, 30, 30, 0.0)\n    simulate_uniform!(state, 1, fuel_table, w, 0.0, 0.0, 0.0, 20.0)\n    push!(plots, heatmap(state.burned', title=lbl, color=:YlOrRd,\n        aspect_ratio=1, colorbar=false, axis=false))\nend\n\nplot(plots..., layout=(2,2), size=(600,600), plot_title=\"Wind Direction Effects\")",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Simulation</span>"
    ]
  },
  {
    "objectID": "tutorials/basic-simulation.html#running-a-simulation",
    "href": "tutorials/basic-simulation.html#running-a-simulation",
    "title": "Basic Simulation",
    "section": "Running a Simulation",
    "text": "Running a Simulation\n\nStep 1: Initialize State\n\nstate = FireState{Float64}(100, 100, 30.0)\n\nCPUFireState{Float64}([100.0 100.0 … 100.0 100.0; 100.0 100.0 … 100.0 100.0; … ; 100.0 100.0 … 100.0 100.0; 100.0 100.0 … 100.0 100.0], [100.0 100.0 … 100.0 100.0; 100.0 100.0 … 100.0 100.0; … ; 100.0 100.0 … 100.0 100.0; 100.0 100.0 … 100.0 100.0], [-1.0 -1.0 … -1.0 -1.0; -1.0 -1.0 … -1.0 -1.0; … ; -1.0 -1.0 … -1.0 -1.0; -1.0 -1.0 … -1.0 -1.0], Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], NarrowBand(Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0], CartesianIndex{2}[], 0, Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0], 5), 100, 100, 30.0, 0.0, 0.0, 2)\n\n\n\n\nStep 2: Set Up Terrain\nFor the simplified API, terrain is specified as uniform slope and aspect:\n\nslope_deg = 10.0    # 10-degree slope\naspect_deg = 180.0  # Slope faces south (uphill is north)\n\n180.0\n\n\nFor spatially varying terrain, use matrices:\n\n# Non-uniform terrain example\nncols, nrows = 100, 100\nslope_matrix = zeros(Float64, ncols, nrows)\naspect_matrix = fill(180.0, ncols, nrows)\n\n# Create a ridge running east-west\nfor ix in 1:ncols\n    for iy in 1:nrows\n        dist_from_center = abs(iy - 50)\n        slope_matrix[ix, iy] = min(20.0, dist_from_center * 0.5)\n        aspect_matrix[ix, iy] = iy &lt; 50 ? 180.0 : 0.0\n    end\nend\n\nheatmap(slope_matrix', title=\"Slope (degrees)\", color=:terrain, aspect_ratio=1)\n\n\n\n\n\n\nStep 3: Ignite\n\nstate = FireState{Float64}(100, 100, 30.0)\n\n# Single point ignition\nignite!(state, 50, 50, 0.0)  # (x, y, time)\n\n# Or use world coordinates\n# ignite_point!(state, 1500.0, 1500.0, 0.0)  # (x_ft, y_ft, time)\n\n# Or ignite a circle\n# ignite_circle!(state, 50, 50, 3.0, 0.0)  # (cx, cy, radius_cells, time)\n\n\n\nStep 4: Run Simulation\n\nweather = ConstantWeather{Float64}(wind_speed_mph=10.0, wind_direction=270.0,\n    M1=0.06, M10=0.08, M100=0.10, MLH=0.60, MLW=0.90)\n\nsimulate_uniform!(\n    state,\n    1,              # Fuel model ID\n    fuel_table,\n    weather,\n    10.0,           # Slope (degrees)\n    180.0,          # Aspect (degrees)\n    0.0,            # Start time\n    60.0;           # End time\n    dt_initial = 1.0,      # Initial timestep\n    target_cfl = 0.9,      # CFL target\n    dt_max = 10.0          # Maximum timestep\n)\n\nprintln(\"Burned area: \", round(get_burned_area_acres(state), digits=2), \" acres\")\n\nBurned area: 81.61 acres\n\n\n\n\nStep 5: Extract Results\n\n# Burned area\nacres = get_burned_area_acres(state)\nsq_ft = get_burned_area(state)\n\n# Fire perimeter (grid cells on the edge)\nperimeter = get_fire_perimeter(state)\nprintln(\"Perimeter cells: \", length(perimeter))\n\n# Visualize results\np1 = heatmap(state.burned', title=\"Burned Area\", color=:YlOrRd, aspect_ratio=1)\n\ntoa = copy(state.time_of_arrival)\ntoa[toa .&lt; 0] .= NaN\np2 = heatmap(toa', title=\"Time of Arrival (min)\", color=:viridis, aspect_ratio=1)\n\nflin = copy(state.fireline_intensity)\nflin[flin .== 0] .= NaN\np3 = heatmap(flin', title=\"Fireline Intensity (kW/m)\", color=:inferno, aspect_ratio=1)\n\nfl = copy(state.flame_length)\nfl[fl .== 0] .= NaN\np4 = heatmap(fl', title=\"Flame Length (ft)\", color=:hot, aspect_ratio=1)\n\nplot(p1, p2, p3, p4, layout=(2,2), size=(800, 800))\n\nPerimeter cells: 676",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Simulation</span>"
    ]
  },
  {
    "objectID": "tutorials/basic-simulation.html#simulation-with-callbacks",
    "href": "tutorials/basic-simulation.html#simulation-with-callbacks",
    "title": "Basic Simulation",
    "section": "Simulation with Callbacks",
    "text": "Simulation with Callbacks\nMonitor simulation progress with a callback function:\n\nstate = FireState{Float64}(100, 100, 30.0)\nignite!(state, 50, 50, 0.0)\n\n# Track burned area over time\ntimes = Float64[]\nareas = Float64[]\n\nfunction my_callback(state, t, dt, iteration)\n    push!(times, t)\n    push!(areas, get_burned_area_acres(state))\nend\n\nsimulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 60.0;\n    callback = my_callback)\n\nplot(times, areas, xlabel=\"Time (min)\", ylabel=\"Burned Area (acres)\",\n    title=\"Fire Growth\", legend=false, linewidth=2)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Simulation</span>"
    ]
  },
  {
    "objectID": "tutorials/basic-simulation.html#non-uniform-conditions",
    "href": "tutorials/basic-simulation.html#non-uniform-conditions",
    "title": "Basic Simulation",
    "section": "Non-Uniform Conditions",
    "text": "Non-Uniform Conditions\nFor spatially varying fuel and terrain, use simulate!:\n\nncols, nrows = 100, 100\nstate = FireState{Float64}(ncols, nrows, 30.0)\n\n# Create fuel mosaic (grass and chaparral)\nfuel_ids = fill(1, ncols, nrows)\nfuel_ids[40:60, :] .= 4  # Chaparral strip\n\n# Varying terrain\nslope = zeros(Float64, ncols, nrows)\nslope[:, 60:end] .= 15.0  # Steep uphill in upper portion\n\naspect = fill(180.0, ncols, nrows)\n\nignite!(state, 50, 30, 0.0)\n\nsimulate!(state, fuel_ids, fuel_table, weather, slope, aspect, 0.0, 45.0)\n\np1 = heatmap(fuel_ids', title=\"Fuel Types\", color=:Set1, aspect_ratio=1)\np2 = heatmap(slope', title=\"Slope (deg)\", color=:terrain, aspect_ratio=1)\np3 = heatmap(state.burned', title=\"Burned\", color=:YlOrRd, aspect_ratio=1)\n\ntoa = copy(state.time_of_arrival)\ntoa[toa .&lt; 0] .= NaN\np4 = heatmap(toa', title=\"Time of Arrival\", color=:viridis, aspect_ratio=1)\n\nplot(p1, p2, p3, p4, layout=(2,2), size=(800, 800))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Simulation</span>"
    ]
  },
  {
    "objectID": "tutorials/basic-simulation.html#float32-precision",
    "href": "tutorials/basic-simulation.html#float32-precision",
    "title": "Basic Simulation",
    "section": "Float32 Precision",
    "text": "Float32 Precision\nFor memory-constrained applications, use Float32:\n\n# Float32 simulation\nstate32 = FireState{Float32}(100, 100, 30.0f0)\nfuel_table32 = create_standard_fuel_table(Float32)\nweather32 = ConstantWeather{Float32}(\n    wind_speed_mph = 10.0f0,\n    wind_direction = 270.0f0,\n    M1 = 0.06f0, M10 = 0.08f0, M100 = 0.10f0,\n    MLH = 0.60f0, MLW = 0.90f0\n)\n\nignite!(state32, 50, 50, 0.0f0)\nsimulate_uniform!(state32, 1, fuel_table32, weather32, 0.0f0, 0.0f0, 0.0f0, 30.0f0)\n\nprintln(\"Float32 burned area: \", get_burned_area_acres(state32), \" acres\")\n\nFloat32 burned area: 28.57438 acres",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Basic Simulation</span>"
    ]
  },
  {
    "objectID": "tutorials/weather-effects.html",
    "href": "tutorials/weather-effects.html",
    "title": "Weather Effects",
    "section": "",
    "text": "Wind Speed Effects\nWeather is the primary driver of fire behavior. This tutorial explores how different weather parameters affect fire spread.\nWind is the most critical weather factor for fire spread:\nfuel_table = create_standard_fuel_table(Float64)\n\nwind_speeds = 0:5:30\nburned_areas = Float64[]\n\nfor ws in wind_speeds\n    state = FireState{Float64}(100, 100, 30.0)\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = Float64(ws),\n        wind_direction = 270.0,\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n    ignite!(state, 50, 50, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 30.0)\n    push!(burned_areas, get_burned_area_acres(state))\nend\n\nplot(wind_speeds, burned_areas,\n    xlabel = \"Wind Speed (mph)\",\n    ylabel = \"Burned Area (acres) in 30 min\",\n    title = \"Wind Speed vs Fire Size\",\n    linewidth = 2,\n    marker = :circle,\n    legend = false\n)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Weather Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/weather-effects.html#wind-speed-effects",
    "href": "tutorials/weather-effects.html#wind-speed-effects",
    "title": "Weather Effects",
    "section": "",
    "text": "Wind Creates Elliptical Spread\nThe fire spread pattern changes dramatically with wind:\n\nspeeds = [0, 10, 20, 30]\nplots = []\n\nfor ws in speeds\n    state = FireState{Float64}(100, 100, 30.0)\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = Float64(ws),\n        wind_direction = 270.0,\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n    ignite!(state, 50, 50, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 30.0)\n\n    push!(plots, heatmap(state.burned',\n        title = \"$(ws) mph\",\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false,\n        axis = false\n    ))\nend\n\nplot(plots..., layout = (2, 2), size = (700, 700),\n    plot_title = \"Wind Speed Effect on Fire Shape\")\n\n\n\n\n\n\nElliptical Spread Model\nElmfire uses the Anderson elliptical spread model:\n\n# Visualize how wind speed affects fire shape\n# Higher wind = more elongated ellipse stretching downwind\n\nwind_speeds = [0.0, 2.0, 5.0, 8.0]\np = plot(aspect_ratio = 1, legend = :topright,\n    xlabel = \"Distance (ft)\", ylabel = \"Distance (ft)\",\n    title = \"Fire Spread Shape vs Wind Speed\\n(after 1 minute, wind blowing East →)\")\n\nfor ws in wind_speeds\n    # Use a base spread rate that increases with wind (simplified)\n    base_ros = 10.0 + ws * 2  # Faster spread with more wind\n    es = elliptical_spread(base_ros, ws)\n\n    # Ellipse with ignition at upwind focus (origin)\n    a = (es.head + es.back) / 2      # Semi-major axis\n    c = (es.head - es.back) / 2      # Focus offset (ignition is at upwind focus)\n    b = es.flank                      # Semi-minor axis\n\n    # Parametric ellipse centered at (c, 0), with ignition at origin\n    t = range(0, 2π, length=200)\n    x = [c + a * cos(τ) for τ in t]\n    y = [b * sin(τ) for τ in t]\n\n    plot!(p, x, y, label = \"$(Int(ws)) mph wind\", linewidth = 2)\nend\n\n# Mark ignition point\nscatter!(p, [0], [0], marker = :star, markersize = 12, color = :red, label = \"Ignition\")\n\n# Wind arrow pointing east (direction wind blows)\nquiver!(p, [-8], [8], quiver=([10], [0]), color = :gray, linewidth = 2)\n\np",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Weather Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/weather-effects.html#wind-direction",
    "href": "tutorials/weather-effects.html#wind-direction",
    "title": "Weather Effects",
    "section": "Wind Direction",
    "text": "Wind Direction\nWind direction determines which way the fire spreads fastest:\n\ndirections = 0:45:315\ndir_labels = [\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\"]\nplots = []\n\nfor (wd, lbl) in zip(directions, dir_labels)\n    state = FireState{Float64}(80, 80, 30.0)\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 15.0,\n        wind_direction = Float64(wd),\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n    ignite!(state, 40, 40, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 25.0)\n\n    push!(plots, heatmap(state.burned',\n        title = \"From $lbl ($(wd)°)\",\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false,\n        axis = false\n    ))\nend\n\nplot(plots..., layout = (2, 4), size = (1000, 500))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Weather Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/weather-effects.html#fuel-moisture",
    "href": "tutorials/weather-effects.html#fuel-moisture",
    "title": "Weather Effects",
    "section": "Fuel Moisture",
    "text": "Fuel Moisture\nFuel moisture critically affects fire intensity and spread rate:\n\nmoistures = 0.02:0.02:0.16\nareas = Float64[]\nintensities = Float64[]\n\nfor m1 in moistures\n    state = FireState{Float64}(100, 100, 30.0)\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 10.0,\n        wind_direction = 270.0,\n        M1 = m1,\n        M10 = m1 + 0.02,\n        M100 = m1 + 0.04,\n        MLH = 0.60,\n        MLW = 0.90\n    )\n    ignite!(state, 50, 50, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 30.0)\n\n    push!(areas, get_burned_area_acres(state))\n    push!(intensities, maximum(state.fireline_intensity))\nend\n\np1 = plot(moistures .* 100, areas,\n    xlabel = \"1-hr Fuel Moisture (%)\",\n    ylabel = \"Burned Area (acres)\",\n    title = \"Moisture vs Fire Size\",\n    linewidth = 2,\n    legend = false\n)\n\np2 = plot(moistures .* 100, intensities,\n    xlabel = \"1-hr Fuel Moisture (%)\",\n    ylabel = \"Max Intensity (kW/m)\",\n    title = \"Moisture vs Intensity\",\n    linewidth = 2,\n    legend = false,\n    color = :red\n)\n\nplot(p1, p2, layout = (1, 2), size = (800, 350))\n\n\n\n\n\nMoisture Damping Coefficient\nThe moisture damping reduces fire intensity as moisture increases:\n\n# Get a fuel model\nfm = get_fuel_model(fuel_table, 1, 60)\n\n# Calculate moisture damping for range of moistures\n# moisture_damping takes the ratio: moisture / extinction moisture\nm_range = 0.02:0.01:fm.mex_dead\ndamping = [moisture_damping(Float64(m / fm.mex_dead)) for m in m_range]\n\nplot(m_range .* 100, damping,\n    xlabel = \"Dead Fuel Moisture (%)\",\n    ylabel = \"Moisture Damping Coefficient\",\n    title = \"Moisture Damping (FBFM01, Mex_dead=$(round(fm.mex_dead*100))%)\",\n    linewidth = 2,\n    legend = false,\n    xlims = (0, 30)\n)\nvline!([fm.mex_dead * 100], linestyle = :dash, label = \"Extinction\")",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Weather Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/weather-effects.html#live-fuel-moisture",
    "href": "tutorials/weather-effects.html#live-fuel-moisture",
    "title": "Weather Effects",
    "section": "Live Fuel Moisture",
    "text": "Live Fuel Moisture\nLive herbaceous and woody moisture affect flame length and intensity:\n\nmlh_values = [0.30, 0.60, 0.90, 1.20]  # Live herbaceous\nmlh_labels = [\"30%\", \"60%\", \"90%\", \"120%\"]\nplots = []\n\nfor (mlh, lbl) in zip(mlh_values, mlh_labels)\n    state = FireState{Float64}(80, 80, 30.0)\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 10.0,\n        wind_direction = 270.0,\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = mlh,\n        MLW = 0.90\n    )\n    ignite!(state, 40, 40, 0.0)\n    simulate_uniform!(state, 2, fuel_table, weather, 0.0, 0.0, 0.0, 25.0)  # FBFM02 has live fuels\n\n    flin = copy(state.fireline_intensity)\n    flin[flin .== 0] .= NaN\n\n    push!(plots, heatmap(flin',\n        title = \"MLH = $lbl\",\n        color = :inferno,\n        aspect_ratio = 1,\n        clims = (0, 500)\n    ))\nend\n\nplot(plots..., layout = (2, 2), size = (700, 700),\n    plot_title = \"Live Herbaceous Moisture Effect on Intensity\")",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Weather Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/weather-effects.html#combining-effects",
    "href": "tutorials/weather-effects.html#combining-effects",
    "title": "Weather Effects",
    "section": "Combining Effects",
    "text": "Combining Effects\nWind and moisture interact to produce complex fire behavior:\n\nwind_speeds = [5, 15]\nmoistures = [0.04, 0.10]\nplots = []\n\nfor ws in wind_speeds\n    for m1 in moistures\n        state = FireState{Float64}(100, 100, 30.0)\n        weather = ConstantWeather{Float64}(\n            wind_speed_mph = Float64(ws),\n            wind_direction = 270.0,\n            M1 = m1, M10 = m1 + 0.02, M100 = m1 + 0.04,\n            MLH = 0.60, MLW = 0.90\n        )\n        ignite!(state, 50, 50, 0.0)\n        simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 30.0)\n\n        acres = round(get_burned_area_acres(state), digits=1)\n        push!(plots, heatmap(state.burned',\n            title = \"$(ws)mph, $(Int(m1*100))% M\\n$acres ac\",\n            color = :YlOrRd,\n            aspect_ratio = 1,\n            colorbar = false\n        ))\n    end\nend\n\nplot(plots..., layout = (2, 2), size = (700, 700))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Weather Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/weather-effects.html#time-varying-weather",
    "href": "tutorials/weather-effects.html#time-varying-weather",
    "title": "Weather Effects",
    "section": "Time-Varying Weather",
    "text": "Time-Varying Weather\nFor extended simulations, weather changes over time. Use WeatherTimeSeries:\n\nncols, nrows = 100, 100\ncellsize = 30.0\n\n# Create weather grids for different times\nfunction make_weather_grid(ws, wd, m1)\n    ConstantWeather{Float64}(\n        wind_speed_mph = ws,\n        wind_direction = wd,\n        M1 = m1, M10 = m1 + 0.02, M100 = m1 + 0.04,\n        MLH = 0.60, MLW = 0.90\n    )\nend\n\n# Morning: light winds from east, higher moisture\ngrid1 = WeatherGrid{Float64}(make_weather_grid(5.0, 90.0, 0.08), 1, 1, 1e6)\n# Afternoon: strong winds from west, drier\ngrid2 = WeatherGrid{Float64}(make_weather_grid(15.0, 270.0, 0.05), 1, 1, 1e6)\n# Evening: moderate winds from south\ngrid3 = WeatherGrid{Float64}(make_weather_grid(10.0, 180.0, 0.06), 1, 1, 1e6)\n\n# Create time series\ntimes = [0.0, 60.0, 120.0]\nweather_series = WeatherTimeSeries{Float64}([grid1, grid2, grid3], times)\n\n# Create interpolator\nweather_interp = WeatherInterpolator(weather_series, ncols, nrows, cellsize)\n\n# Run simulation\nstate = FireState{Float64}(ncols, nrows, cellsize)\nfuel_ids = fill(1, ncols, nrows)\nslope = zeros(Float64, ncols, nrows)\naspect = zeros(Float64, ncols, nrows)\n\nignite!(state, 50, 50, 0.0)\n\nsimulate_full!(state, fuel_ids, fuel_table, weather_interp, slope, aspect,\n    0.0, 180.0)  # 3 hours\n\n# Visualize with time markers\ntoa = copy(state.time_of_arrival)\ntoa[toa .&lt; 0] .= NaN\n\nheatmap(toa',\n    title = \"Time of Arrival - Changing Weather\\n(Wind shifts at 60 & 120 min)\",\n    xlabel = \"X\", ylabel = \"Y\",\n    color = :viridis,\n    aspect_ratio = 1,\n    size = (600, 500)\n)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Weather Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/weather-effects.html#weather-at-a-specific-time",
    "href": "tutorials/weather-effects.html#weather-at-a-specific-time",
    "title": "Weather Effects",
    "section": "Weather at a Specific Time",
    "text": "Weather at a Specific Time\nQuery interpolated weather values:\n\n# Get weather at center cell at different times\nix, iy = 50, 50\n\nfor t in [0.0, 30.0, 60.0, 90.0, 120.0]\n    w = get_weather_at(weather_interp, ix, iy, t)\n    println(\"t=$(Int(t))min: WS=$(round(w.ws, digits=1))mph, WD=$(round(w.wd))°, M1=$(round(w.m1*100, digits=1))%\")\nend\n\nt=0min: WS=5.0mph, WD=90.0°, M1=8.0%\nt=30min: WS=10.0mph, WD=180.0°, M1=6.5%\nt=60min: WS=15.0mph, WD=270.0°, M1=5.0%\nt=90min: WS=12.5mph, WD=225.0°, M1=5.5%\nt=120min: WS=10.0mph, WD=180.0°, M1=6.0%",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Weather Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/weather-effects.html#wind-adjustment-factor",
    "href": "tutorials/weather-effects.html#wind-adjustment-factor",
    "title": "Weather Effects",
    "section": "Wind Adjustment Factor",
    "text": "Wind Adjustment Factor\nThe 20-ft wind is adjusted to mid-flame height based on fuel bed depth:\n\ndepths = 0.1:0.1:5.0\nwafs = [wind_adjustment_factor(d) for d in depths]\n\nplot(depths, wafs,\n    xlabel = \"Fuel Bed Depth (ft)\",\n    ylabel = \"Wind Adjustment Factor\",\n    title = \"20-ft to Mid-flame Wind Adjustment\",\n    linewidth = 2,\n    legend = false,\n    ylims = (0, 1)\n)\n\n\n\n\nTaller fuel beds have less wind reduction at mid-flame height.",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Weather Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/weather-effects.html#extreme-weather-scenarios",
    "href": "tutorials/weather-effects.html#extreme-weather-scenarios",
    "title": "Weather Effects",
    "section": "Extreme Weather Scenarios",
    "text": "Extreme Weather Scenarios\nModel extreme fire weather conditions:\n\nscenarios = [\n    (\"Moderate\", 10.0, 0.08),\n    (\"Red Flag\", 25.0, 0.04),\n    (\"Extreme\", 40.0, 0.02)\n]\n\nplots = []\n\nfor (name, ws, m1) in scenarios\n    state = FireState{Float64}(150, 150, 30.0)\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = ws,\n        wind_direction = 270.0,\n        M1 = m1, M10 = m1 + 0.02, M100 = m1 + 0.04,\n        MLH = 0.40, MLW = 0.70\n    )\n    ignite!(state, 75, 75, 0.0)\n    simulate_uniform!(state, 4, fuel_table, weather, 10.0, 180.0, 0.0, 30.0)\n\n    acres = round(get_burned_area_acres(state), digits=1)\n    push!(plots, heatmap(state.burned',\n        title = \"$name\\n$acres acres in 30 min\",\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false\n    ))\nend\n\nplot(plots..., layout = (1, 3), size = (900, 300))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Weather Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/terrain-effects.html",
    "href": "tutorials/terrain-effects.html",
    "title": "Terrain Effects",
    "section": "",
    "text": "Slope Effects\nTerrain dramatically influences fire behavior. This tutorial explores slope and aspect effects.\nFire spreads faster uphill due to: - Preheating of fuels above the fire - Convective heat transfer - Flame tilting toward uphill fuels\nfuel_table = create_standard_fuel_table(Float64)\n\nslopes = 0:5:35\nareas = Float64[]\n\nfor slp in slopes\n    state = FireState{Float64}(100, 100, 30.0)\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 5.0,\n        wind_direction = 180.0,  # From south\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n    ignite!(state, 50, 50, 0.0)\n    # Slope faces south (uphill to north)\n    simulate_uniform!(state, 1, fuel_table, weather, Float64(slp), 180.0, 0.0, 30.0)\n    push!(areas, get_burned_area_acres(state))\nend\n\nplot(slopes, areas,\n    xlabel = \"Slope (degrees)\",\n    ylabel = \"Burned Area (acres)\",\n    title = \"Slope Effect on Fire Spread (30 min)\",\n    linewidth = 2,\n    marker = :circle,\n    legend = false\n)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Terrain Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/terrain-effects.html#slope-effects",
    "href": "tutorials/terrain-effects.html#slope-effects",
    "title": "Terrain Effects",
    "section": "",
    "text": "Visualizing Slope Effect\n\nslopes = [0, 10, 20, 30]\nplots = []\n\nfor slp in slopes\n    state = FireState{Float64}(100, 100, 30.0)\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 5.0,\n        wind_direction = 180.0,\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n    ignite!(state, 50, 30, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, Float64(slp), 180.0, 0.0, 30.0)\n\n    push!(plots, heatmap(state.burned',\n        title = \"Slope: $(slp)°\",\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false\n    ))\nend\n\nplot(plots..., layout = (2, 2), size = (700, 700),\n    plot_title = \"Fire Spread on Different Slopes (Uphill to North)\")",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Terrain Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/terrain-effects.html#aspect-effects",
    "href": "tutorials/terrain-effects.html#aspect-effects",
    "title": "Terrain Effects",
    "section": "Aspect Effects",
    "text": "Aspect Effects\nAspect determines which direction the slope faces:\n\naspects = [0, 90, 180, 270]\naspect_labels = [\"North-facing\", \"East-facing\", \"South-facing\", \"West-facing\"]\nplots = []\n\nfor (asp, lbl) in zip(aspects, aspect_labels)\n    state = FireState{Float64}(100, 100, 30.0)\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 5.0,\n        wind_direction = 270.0,  # Wind from west\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n    ignite!(state, 50, 50, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 15.0, Float64(asp), 0.0, 25.0)\n\n    push!(plots, heatmap(state.burned',\n        title = lbl,\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false\n    ))\nend\n\nplot(plots..., layout = (2, 2), size = (700, 700),\n    plot_title = \"15° Slope with Different Aspects (Wind from West)\")",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Terrain Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/terrain-effects.html#slope-factor-calculation",
    "href": "tutorials/terrain-effects.html#slope-factor-calculation",
    "title": "Terrain Effects",
    "section": "Slope Factor Calculation",
    "text": "Slope Factor Calculation\nThe slope factor in the Rothermel model:\n\nslopes_deg = 0:1:45\nslope_factors = [calculate_tanslp2(Float64(s)) for s in slopes_deg]\n\nplot(slopes_deg, slope_factors,\n    xlabel = \"Slope (degrees)\",\n    ylabel = \"tan²(slope)\",\n    title = \"Slope Factor in Rothermel Model\",\n    linewidth = 2,\n    legend = false\n)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Terrain Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/terrain-effects.html#wind-vs-slope-interaction",
    "href": "tutorials/terrain-effects.html#wind-vs-slope-interaction",
    "title": "Terrain Effects",
    "section": "Wind vs Slope Interaction",
    "text": "Wind vs Slope Interaction\nWind and slope can reinforce or oppose each other:\n\n# Create scenarios\nscenarios = [\n    (\"Wind uphill\", 180.0, 180.0),      # Wind from S, slope faces S (uphill N)\n    (\"Wind downhill\", 0.0, 180.0),       # Wind from N, slope faces S (downhill N)\n    (\"Wind cross-slope\", 270.0, 180.0),  # Wind from W, slope faces S\n]\n\nplots = []\n\nfor (name, wind_dir, aspect) in scenarios\n    state = FireState{Float64}(100, 100, 30.0)\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 10.0,\n        wind_direction = wind_dir,\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n    ignite!(state, 50, 50, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 20.0, aspect, 0.0, 25.0)\n\n    acres = round(get_burned_area_acres(state), digits=1)\n    push!(plots, heatmap(state.burned',\n        title = \"$name\\n$acres acres\",\n        color = :YlOrRd,\n        aspect_ratio = 1,\n        colorbar = false\n    ))\nend\n\nplot(plots..., layout = (1, 3), size = (900, 300))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Terrain Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/terrain-effects.html#complex-terrain",
    "href": "tutorials/terrain-effects.html#complex-terrain",
    "title": "Terrain Effects",
    "section": "Complex Terrain",
    "text": "Complex Terrain\nSimulate fire on varying terrain:\n\nncols, nrows = 100, 100\ncellsize = 30.0\n\n# Create a simple terrain: valley running E-W\nslope = zeros(Float64, ncols, nrows)\naspect = zeros(Float64, ncols, nrows)\n\nfor ix in 1:ncols\n    for iy in 1:nrows\n        dist_from_center = abs(iy - 50)\n        slope[ix, iy] = min(25.0, dist_from_center * 0.6)\n        aspect[ix, iy] = iy &lt; 50 ? 180.0 : 0.0  # South-facing above, North-facing below\n    end\nend\n\nstate = FireState{Float64}(ncols, nrows, cellsize)\nfuel_ids = fill(1, ncols, nrows)\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 8.0,\n    wind_direction = 270.0,\n    M1 = 0.06, M10 = 0.08, M100 = 0.10,\n    MLH = 0.60, MLW = 0.90\n)\n\nignite!(state, 50, 50, 0.0)  # Ignite at valley bottom\nsimulate!(state, fuel_ids, fuel_table, weather, slope, aspect, 0.0, 45.0)\n\np1 = heatmap(slope', title = \"Slope (degrees)\", color = :terrain, aspect_ratio = 1)\np2 = heatmap(aspect', title = \"Aspect (degrees)\", color = :hsv, aspect_ratio = 1)\np3 = heatmap(state.burned', title = \"Burned Area\", color = :YlOrRd, aspect_ratio = 1)\n\ntoa = copy(state.time_of_arrival)\ntoa[toa .&lt; 0] .= NaN\np4 = heatmap(toa', title = \"Time of Arrival\", color = :viridis, aspect_ratio = 1)\n\nplot(p1, p2, p3, p4, layout = (2, 2), size = (800, 800))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Terrain Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/terrain-effects.html#ridge-and-valley-effects",
    "href": "tutorials/terrain-effects.html#ridge-and-valley-effects",
    "title": "Terrain Effects",
    "section": "Ridge and Valley Effects",
    "text": "Ridge and Valley Effects\nFire behavior changes dramatically at terrain features:\n\n# Create terrain with ridge\nncols, nrows = 120, 120\nslope = zeros(Float64, ncols, nrows)\naspect = zeros(Float64, ncols, nrows)\n\n# Ridge running N-S at x=60\nfor ix in 1:ncols\n    for iy in 1:nrows\n        dist = abs(ix - 60)\n        if dist &lt; 30\n            slope[ix, iy] = 20.0 * (1 - dist/30)\n            aspect[ix, iy] = ix &lt; 60 ? 90.0 : 270.0  # E or W facing\n        end\n    end\nend\n\nstate = FireState{Float64}(ncols, nrows, 30.0)\nfuel_ids = fill(1, ncols, nrows)\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 10.0,\n    wind_direction = 270.0,  # From west\n    M1 = 0.05, M10 = 0.07, M100 = 0.09,\n    MLH = 0.55, MLW = 0.85\n)\n\nignite!(state, 30, 60, 0.0)  # Ignite west of ridge\nsimulate!(state, fuel_ids, fuel_table, weather, slope, aspect, 0.0, 45.0)\n\np1 = heatmap(slope', title = \"Ridge Terrain (Slope)\", color = :terrain, aspect_ratio = 1)\np2 = heatmap(state.burned', title = \"Fire Spread Over Ridge\", color = :YlOrRd, aspect_ratio = 1)\n\nplot(p1, p2, layout = (1, 2), size = (800, 400))\n\n\n\n\nFire accelerates up the windward slope and may slow on the lee side.",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Terrain Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/terrain-effects.html#steep-terrain-considerations",
    "href": "tutorials/terrain-effects.html#steep-terrain-considerations",
    "title": "Terrain Effects",
    "section": "Steep Terrain Considerations",
    "text": "Steep Terrain Considerations\nOn very steep slopes (&gt;30°), fire behavior can become extreme:\n\n# Extreme slope scenario\nstate = FireState{Float64}(100, 100, 30.0)\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 15.0,\n    wind_direction = 180.0,  # From south (uphill)\n    M1 = 0.04, M10 = 0.06, M100 = 0.08,\n    MLH = 0.40, MLW = 0.70\n)\n\nignite!(state, 50, 20, 0.0)\nsimulate_uniform!(state, 4, fuel_table, weather, 35.0, 180.0, 0.0, 20.0)\n\n# Check fireline intensity\nmax_flin = maximum(state.fireline_intensity)\nprintln(\"Maximum fireline intensity: $(round(max_flin, digits=0)) kW/m\")\n\n# Classify intensity\nif max_flin &gt; 10000\n    println(\"EXTREME fire behavior - spotting likely, aerial suppression ineffective\")\nelseif max_flin &gt; 4000\n    println(\"VERY HIGH intensity - indirect attack recommended\")\nelseif max_flin &gt; 2000\n    println(\"HIGH intensity - mechanical equipment needed\")\nelse\n    println(\"MODERATE intensity - direct attack possible\")\nend\n\nflin = copy(state.fireline_intensity)\nflin[flin .== 0] .= NaN\n\nheatmap(flin',\n    title = \"Fireline Intensity on 35° Slope\\nMax: $(round(max_flin, digits=0)) kW/m\",\n    color = :inferno,\n    aspect_ratio = 1\n)\n\nMaximum fireline intensity: 54264.0 kW/m\nEXTREME fire behavior - spotting likely, aerial suppression ineffective",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Terrain Effects</span>"
    ]
  },
  {
    "objectID": "tutorials/crown-fire.html",
    "href": "tutorials/crown-fire.html",
    "title": "Crown Fire",
    "section": "",
    "text": "Crown Fire Basics\nCrown fire occurs when fire spreads through the canopy layer of trees. This tutorial covers crown fire modeling in Elmfire.jl.\nCrown fire is classified as: - Passive (torching): Individual trees or groups torch, but fire doesn’t spread continuously through canopy - Active: Fire spreads continuously through the canopy, driven by wind",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Crown Fire</span>"
    ]
  },
  {
    "objectID": "tutorials/crown-fire.html#canopy-properties",
    "href": "tutorials/crown-fire.html#canopy-properties",
    "title": "Crown Fire",
    "section": "Canopy Properties",
    "text": "Canopy Properties\nCrown fire requires canopy data:\n\nncols, nrows = 100, 100\ncellsize = 30.0\n\n# Create canopy grid with typical forest values\ncanopy = CanopyGrid{Float64}(\n    fill(0.15, ncols, nrows),   # cbd: Canopy bulk density (kg/m³)\n    fill(2.0, ncols, nrows),     # cbh: Canopy base height (m)\n    fill(0.6, ncols, nrows),     # cc: Canopy cover (fraction)\n    fill(20.0, ncols, nrows)     # ch: Canopy height (m)\n)\n\nprintln(\"Canopy properties:\")\nprintln(\"  Bulk density: 0.15 kg/m³\")\nprintln(\"  Base height: 2.0 m\")\nprintln(\"  Cover: 60%\")\nprintln(\"  Height: 20 m\")\n\nCanopy properties:\n  Bulk density: 0.15 kg/m³\n  Base height: 2.0 m\n  Cover: 60%\n  Height: 20 m",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Crown Fire</span>"
    ]
  },
  {
    "objectID": "tutorials/crown-fire.html#enabling-crown-fire",
    "href": "tutorials/crown-fire.html#enabling-crown-fire",
    "title": "Crown Fire",
    "section": "Enabling Crown Fire",
    "text": "Enabling Crown Fire\nConfigure simulation for crown fire:\n\nconfig = SimulationConfig{Float64}(\n    enable_crown_fire = true,\n    enable_spotting = false,\n    crown_fire_adj = 1.0,\n    critical_canopy_cover = 0.4,\n    foliar_moisture = 100.0\n)\n\nSimulationConfig{Float64}(true, false, 1.0, 0.4, 100.0, nothing, false)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Crown Fire</span>"
    ]
  },
  {
    "objectID": "tutorials/crown-fire.html#surface-fire-vs-crown-fire",
    "href": "tutorials/crown-fire.html#surface-fire-vs-crown-fire",
    "title": "Crown Fire",
    "section": "Surface Fire vs Crown Fire",
    "text": "Surface Fire vs Crown Fire\nCompare simulations with and without crown fire:\n\nfuel_table = create_standard_fuel_table(Float64)\nfuel_ids = fill(10, ncols, nrows)  # FBFM10: Timber understory\n\nslope = zeros(Float64, ncols, nrows)\naspect = zeros(Float64, ncols, nrows)\n\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 20.0,\n    wind_direction = 270.0,\n    M1 = 0.04, M10 = 0.06, M100 = 0.08,\n    MLH = 0.50, MLW = 0.80\n)\n\n# Surface fire only\nstate_surface = FireState{Float64}(ncols, nrows, cellsize)\nignite!(state_surface, 50, 50, 0.0)\n\nconfig_surface = SimulationConfig{Float64}(enable_crown_fire = false)\nweather_interp = create_constant_interpolator(weather, ncols, nrows, cellsize)\n\nsimulate_full!(state_surface, fuel_ids, fuel_table, weather_interp, slope, aspect,\n    0.0, 30.0; config = config_surface)\n\n# Crown fire enabled\nstate_crown = FireState{Float64}(ncols, nrows, cellsize)\nignite!(state_crown, 50, 50, 0.0)\n\nconfig_crown = SimulationConfig{Float64}(\n    enable_crown_fire = true,\n    critical_canopy_cover = 0.4,\n    foliar_moisture = 100.0\n)\n\nsimulate_full!(state_crown, fuel_ids, fuel_table, weather_interp, slope, aspect,\n    0.0, 30.0; canopy = canopy, config = config_crown)\n\n# Compare\np1 = heatmap(state_surface.burned',\n    title = \"Surface Fire Only\\n$(round(get_burned_area_acres(state_surface), digits=1)) acres\",\n    color = :YlOrRd, aspect_ratio = 1)\n\np2 = heatmap(state_crown.burned',\n    title = \"Crown Fire Enabled\\n$(round(get_burned_area_acres(state_crown), digits=1)) acres\",\n    color = :YlOrRd, aspect_ratio = 1)\n\nplot(p1, p2, layout = (1, 2), size = (800, 400))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Crown Fire</span>"
    ]
  },
  {
    "objectID": "tutorials/crown-fire.html#critical-fireline-intensity",
    "href": "tutorials/crown-fire.html#critical-fireline-intensity",
    "title": "Crown Fire",
    "section": "Critical Fireline Intensity",
    "text": "Critical Fireline Intensity\nCrown fire initiation depends on fireline intensity reaching the critical threshold:\n\n# Calculate critical intensity for different canopy base heights\ncbh_values = 1.0:0.5:10.0  # meters\nfoliar_moisture = 100.0  # percent\n\ni_crit = [critical_fireline_intensity(cbh, foliar_moisture) for cbh in cbh_values]\n\nplot(cbh_values, i_crit,\n    xlabel = \"Canopy Base Height (m)\",\n    ylabel = \"Critical Fireline Intensity (kW/m)\",\n    title = \"Crown Fire Initiation Threshold\",\n    linewidth = 2,\n    legend = false\n)\n\n\n\n\nHigher canopy base heights require greater fireline intensity to initiate crown fire.",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Crown Fire</span>"
    ]
  },
  {
    "objectID": "tutorials/crown-fire.html#canopy-bulk-density-effect",
    "href": "tutorials/crown-fire.html#canopy-bulk-density-effect",
    "title": "Crown Fire",
    "section": "Canopy Bulk Density Effect",
    "text": "Canopy Bulk Density Effect\n\ncbd_values = [0.05, 0.10, 0.15, 0.20]\nplots = []\n\nfor cbd in cbd_values\n    canopy_var = CanopyGrid{Float64}(\n        fill(cbd, ncols, nrows),\n        fill(2.0, ncols, nrows),\n        fill(0.6, ncols, nrows),\n        fill(20.0, ncols, nrows)\n    )\n\n    state = FireState{Float64}(ncols, nrows, cellsize)\n    ignite!(state, 50, 50, 0.0)\n\n    simulate_full!(state, fuel_ids, fuel_table, weather_interp, slope, aspect,\n        0.0, 25.0; canopy = canopy_var, config = config_crown)\n\n    push!(plots, heatmap(state.burned',\n        title = \"CBD = $cbd kg/m³\",\n        color = :YlOrRd, aspect_ratio = 1, colorbar = false\n    ))\nend\n\nplot(plots..., layout = (2, 2), size = (700, 700),\n    plot_title = \"Crown Fire vs Canopy Bulk Density\")",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Crown Fire</span>"
    ]
  },
  {
    "objectID": "tutorials/crown-fire.html#foliar-moisture-effect",
    "href": "tutorials/crown-fire.html#foliar-moisture-effect",
    "title": "Crown Fire",
    "section": "Foliar Moisture Effect",
    "text": "Foliar Moisture Effect\n\nfm_values = [80, 100, 120, 140]\nplots = []\n\nfor fm in fm_values\n    config_fm = SimulationConfig{Float64}(\n        enable_crown_fire = true,\n        foliar_moisture = Float64(fm)\n    )\n\n    state = FireState{Float64}(ncols, nrows, cellsize)\n    ignite!(state, 50, 50, 0.0)\n\n    simulate_full!(state, fuel_ids, fuel_table, weather_interp, slope, aspect,\n        0.0, 25.0; canopy = canopy, config = config_fm)\n\n    push!(plots, heatmap(state.burned',\n        title = \"FM = $fm%\",\n        color = :YlOrRd, aspect_ratio = 1, colorbar = false\n    ))\nend\n\nplot(plots..., layout = (2, 2), size = (700, 700),\n    plot_title = \"Crown Fire vs Foliar Moisture\")",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Crown Fire</span>"
    ]
  },
  {
    "objectID": "tutorials/crown-fire.html#combined-spread-rate",
    "href": "tutorials/crown-fire.html#combined-spread-rate",
    "title": "Crown Fire",
    "section": "Combined Spread Rate",
    "text": "Combined Spread Rate\nThe total spread rate combines surface and crown fire components:\n\n# Get canopy properties\ncanopy_props = CanopyProperties{Float64}(0.15, 2.0, 0.6, 20.0)\n\n# Range of surface fireline intensities\nflin_range = 100:100:5000\n\nsurface_ros = 50.0  # ft/min\ncombined_ros = Float64[]\n\nfor flin in flin_range\n    cr = crown_spread_rate(canopy_props, Float64(flin), 20.0, 0.06, surface_ros)\n    # SpreadResult fields: velocity, vs0, ir, hpua, flin, phiw, phis\n    sr = SpreadResult{Float64}(surface_ros, surface_ros, 500.0, 1000.0, Float64(flin), 1.0, 0.0)\n    cros = combined_spread_rate(sr, cr)\n    push!(combined_ros, cros)\nend\n\nplot(flin_range, combined_ros,\n    xlabel = \"Surface Fireline Intensity (kW/m)\",\n    ylabel = \"Combined Spread Rate (ft/min)\",\n    title = \"Crown Fire Contribution to Spread Rate\",\n    linewidth = 2,\n    legend = false\n)\nhline!([surface_ros], linestyle = :dash, label = \"Surface only\")",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Crown Fire</span>"
    ]
  },
  {
    "objectID": "tutorials/spotting.html",
    "href": "tutorials/spotting.html",
    "title": "Spotting",
    "section": "",
    "text": "Spotting Mechanism\nSpotting (ember transport) creates new ignitions downwind of the main fire. This tutorial covers Elmfire.jl’s spotting capabilities.\nEmbers (firebrands) are generated by: - Burning vegetation lofted by convection - Higher intensity fires produce more embers - Crown fires generate significantly more embers",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Spotting</span>"
    ]
  },
  {
    "objectID": "tutorials/spotting.html#configuring-spotting",
    "href": "tutorials/spotting.html#configuring-spotting",
    "title": "Spotting",
    "section": "Configuring Spotting",
    "text": "Configuring Spotting\n\n# Create spotting parameters\nspotting_params = SpottingParameters{Float64}(\n    mean_distance = 100.0,              # Mean spotting distance (m)\n    normalized_variance = 0.5,          # Normalized variance\n    ws_exponent = 1.0,                  # Wind speed exponent\n    flin_exponent = 0.5,                # Fireline intensity exponent\n    nembers_max = 10,                   # Max embers per cell per timestep\n    surface_spotting_percent = 1.0,     # Surface fire spotting probability (%)\n    crown_spotting_percent = 10.0,      # Crown fire spotting probability (%)\n    pign = 50.0,                        # Ignition probability (%)\n    min_distance = 10.0,                # Min distance (m)\n    max_distance = 2000.0               # Max distance (m)\n)\n\nSpottingParameters{Float64}(100.0, 0.5, 1.0, 0.5, 10, 1.0, 10.0, 50.0, 10.0, 2000.0)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Spotting</span>"
    ]
  },
  {
    "objectID": "tutorials/spotting.html#ember-transport",
    "href": "tutorials/spotting.html#ember-transport",
    "title": "Spotting",
    "section": "Ember Transport",
    "text": "Ember Transport\nEmbers are transported downwind with distances that scale with wind speed and fireline intensity. The SpottingParameters control:\n\nmean_distance: Base spotting distance (m)\nws_exponent: How much wind speed increases distance\nflin_exponent: How much intensity increases distance\nnormalized_variance: Randomness in landing location\nmin_distance / max_distance: Distance bounds (m)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Spotting</span>"
    ]
  },
  {
    "objectID": "tutorials/spotting.html#simulation-with-spotting",
    "href": "tutorials/spotting.html#simulation-with-spotting",
    "title": "Spotting",
    "section": "Simulation with Spotting",
    "text": "Simulation with Spotting\n\nncols, nrows = 150, 150\ncellsize = 30.0\n\nstate = FireState{Float64}(ncols, nrows, cellsize)\nfuel_table = create_standard_fuel_table(Float64)\nfuel_ids = fill(4, ncols, nrows)  # Chaparral (high intensity)\n\nslope = zeros(Float64, ncols, nrows)\naspect = zeros(Float64, ncols, nrows)\n\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 20.0,\n    wind_direction = 270.0,\n    M1 = 0.04, M10 = 0.06, M100 = 0.08,\n    MLH = 0.40, MLW = 0.70\n)\n\nconfig = SimulationConfig{Float64}(\n    enable_crown_fire = false,\n    enable_spotting = true,\n    spotting_params = spotting_params\n)\n\nignite!(state, 40, 75, 0.0)\nweather_interp = create_constant_interpolator(weather, ncols, nrows, cellsize)\n\nsimulate_full!(state, fuel_ids, fuel_table, weather_interp, slope, aspect,\n    0.0, 45.0; config = config, rng = MersenneTwister(42))\n\n# Visualize\ntoa = copy(state.time_of_arrival)\ntoa[toa .&lt; 0] .= NaN\n\nheatmap(toa',\n    title = \"Fire Spread with Spotting Enabled\",\n    xlabel = \"X (cells)\",\n    ylabel = \"Y (cells)\",\n    color = :viridis,\n    aspect_ratio = 1,\n    size = (600, 500)\n)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Spotting</span>"
    ]
  },
  {
    "objectID": "tutorials/spotting.html#with-vs-without-spotting",
    "href": "tutorials/spotting.html#with-vs-without-spotting",
    "title": "Spotting",
    "section": "With vs Without Spotting",
    "text": "With vs Without Spotting\n\n# Without spotting\nstate_no_spot = FireState{Float64}(ncols, nrows, cellsize)\nignite!(state_no_spot, 40, 75, 0.0)\nconfig_no_spot = SimulationConfig{Float64}(enable_spotting = false)\n\nsimulate_full!(state_no_spot, fuel_ids, fuel_table, weather_interp, slope, aspect,\n    0.0, 45.0; config = config_no_spot)\n\n# With spotting\nstate_spot = FireState{Float64}(ncols, nrows, cellsize)\nignite!(state_spot, 40, 75, 0.0)\n\nsimulate_full!(state_spot, fuel_ids, fuel_table, weather_interp, slope, aspect,\n    0.0, 45.0; config = config, rng = MersenneTwister(42))\n\np1 = heatmap(state_no_spot.burned',\n    title = \"Without Spotting\\n$(round(get_burned_area_acres(state_no_spot), digits=1)) acres\",\n    color = :YlOrRd, aspect_ratio = 1)\n\np2 = heatmap(state_spot.burned',\n    title = \"With Spotting\\n$(round(get_burned_area_acres(state_spot), digits=1)) acres\",\n    color = :YlOrRd, aspect_ratio = 1)\n\nplot(p1, p2, layout = (1, 2), size = (800, 400))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Spotting</span>"
    ]
  },
  {
    "objectID": "tutorials/spotting.html#ember-generation",
    "href": "tutorials/spotting.html#ember-generation",
    "title": "Spotting",
    "section": "Ember Generation",
    "text": "Ember Generation\nThe number of embers depends on:\n\nFireline intensity: Higher intensity fires loft more embers\nFire type: Crown fires generate more embers than surface fires\nspotting_params.nembers_max: Upper limit on embers per cell\nspotting_params.surface_spotting_percent / crown_spotting_percent: Probability of spotting",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Spotting</span>"
    ]
  },
  {
    "objectID": "tutorials/spotting.html#long-range-spotting",
    "href": "tutorials/spotting.html#long-range-spotting",
    "title": "Spotting",
    "section": "Long-Range Spotting",
    "text": "Long-Range Spotting\nExtreme fires can spot miles ahead:\n\n# High-intensity scenario\nncols_big, nrows_big = 300, 200\n\nstate_big = FireState{Float64}(ncols_big, nrows_big, cellsize)\nfuel_ids_big = fill(4, ncols_big, nrows_big)\nslope_big = zeros(Float64, ncols_big, nrows_big)\naspect_big = zeros(Float64, ncols_big, nrows_big)\n\nextreme_weather = ConstantWeather{Float64}(\n    wind_speed_mph = 35.0,\n    wind_direction = 270.0,\n    M1 = 0.03, M10 = 0.05, M100 = 0.07,\n    MLH = 0.35, MLW = 0.60\n)\n\nextreme_spotting = SpottingParameters{Float64}(\n    mean_distance = 200.0,              # Longer mean distance (m)\n    normalized_variance = 0.5,\n    ws_exponent = 1.0,\n    flin_exponent = 0.5,\n    nembers_max = 20,                   # More embers\n    surface_spotting_percent = 2.0,\n    crown_spotting_percent = 15.0,\n    pign = 60.0,                        # Higher ignition probability\n    min_distance = 10.0,\n    max_distance = 5000.0               # Longer max distance (m)\n)\n\nconfig_extreme = SimulationConfig{Float64}(\n    enable_spotting = true,\n    spotting_params = extreme_spotting\n)\n\nignite!(state_big, 50, 100, 0.0)\nweather_interp_big = create_constant_interpolator(extreme_weather, ncols_big, nrows_big, cellsize)\n\nsimulate_full!(state_big, fuel_ids_big, fuel_table, weather_interp_big,\n    slope_big, aspect_big, 0.0, 60.0;\n    config = config_extreme, rng = MersenneTwister(42))\n\ntoa = copy(state_big.time_of_arrival)\ntoa[toa .&lt; 0] .= NaN\n\nheatmap(toa',\n    title = \"Extreme Fire with Long-Range Spotting\",\n    color = :viridis,\n    aspect_ratio = 1,\n    size = (800, 500)\n)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Spotting</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html",
    "href": "tutorials/ensemble.html",
    "title": "Ensemble Simulations",
    "section": "",
    "text": "Why Ensembles?\nEnsemble simulations run multiple realizations of a fire scenario with perturbed inputs to generate probabilistic forecasts. This tutorial covers Elmfire.jl’s ensemble capabilities.\nFire behavior is inherently uncertain due to:\nEnsembles quantify this uncertainty by running many simulations with slightly different inputs.",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#why-ensembles",
    "href": "tutorials/ensemble.html#why-ensembles",
    "title": "Ensemble Simulations",
    "section": "",
    "text": "Weather variability - Wind speed and direction fluctuate\nFuel moisture uncertainty - Difficult to measure accurately everywhere\nIgnition location uncertainty - GPS errors, multiple potential sources\nModel limitations - Simplified physics can’t capture all dynamics",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#basic-ensemble-configuration",
    "href": "tutorials/ensemble.html#basic-ensemble-configuration",
    "title": "Ensemble Simulations",
    "section": "Basic Ensemble Configuration",
    "text": "Basic Ensemble Configuration\nSet up perturbation parameters:\n\n# Define perturbation ranges\nperturbation = PerturbationConfig{Float64}(\n    ignition_perturb_radius = 3.0,           # ±3 cells around ignition\n    wind_speed_factor_range = (0.8, 1.2),    # ±20% wind speed\n    wind_direction_std = 15.0,               # 15° standard deviation\n    moisture_factor_range = (0.85, 1.15),    # ±15% moisture\n    spread_rate_factor_range = (0.9, 1.1)    # ±10% spread rate\n)\n\n# Configure the ensemble\nconfig = EnsembleConfig{Float64}(\n    n_simulations = 50,                      # Number of ensemble members\n    base_seed = UInt64(12345),               # For reproducibility\n    perturbation = perturbation,\n    simulation_config = SimulationConfig{Float64}(),\n    save_individual_results = true           # Keep individual member results\n)\n\nEnsembleConfig{Float64}(50, 0x0000000000003039, PerturbationConfig{Float64}(3.0, (0.8, 1.2), 15.0, (0.85, 1.15), (0.9, 1.1)), SimulationConfig{Float64}(false, false, 1.0, 0.4, 100.0, nothing, false), true)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#running-an-ensemble",
    "href": "tutorials/ensemble.html#running-an-ensemble",
    "title": "Ensemble Simulations",
    "section": "Running an Ensemble",
    "text": "Running an Ensemble\n\n# Set up the simulation domain\nncols, nrows = 80, 80\ncellsize = 30.0\n\nstate_template = FireState{Float64}(ncols, nrows, cellsize)\nfuel_table = create_standard_fuel_table(Float64)\nfuel_ids = fill(1, ncols, nrows)  # Uniform short grass\nslope = zeros(Float64, ncols, nrows)\naspect = zeros(Float64, ncols, nrows)\n\n# Base weather conditions\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 12.0,\n    wind_direction = 270.0,\n    M1 = 0.06, M10 = 0.08, M100 = 0.10,\n    MLH = 0.60, MLW = 0.90\n)\n\n# Run the ensemble\nresult = run_ensemble!(\n    config,\n    state_template,\n    fuel_ids,\n    fuel_table,\n    weather,\n    slope,\n    aspect,\n    40, 40,     # Ignition point (center)\n    0.0, 45.0;  # 45 minutes\n    show_progress = false\n)\n\nprintln(\"Ensemble completed: $(length(result.members)) members\")\nprintln(\"Mean burned area: $(round(result.mean_burned_area, digits=2)) ± $(round(result.std_burned_area, digits=2)) acres\")\n\nEnsemble completed: 50 members\nMean burned area: 55.64 ± 5.6 acres",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#burn-probability-map",
    "href": "tutorials/ensemble.html#burn-probability-map",
    "title": "Ensemble Simulations",
    "section": "Burn Probability Map",
    "text": "Burn Probability Map\nThe burn probability shows the likelihood each cell burns across all ensemble members:\n\nheatmap(\n    result.burn_probability',\n    title = \"Burn Probability (n=$(config.n_simulations))\",\n    xlabel = \"X (cells)\",\n    ylabel = \"Y (cells)\",\n    color = :YlOrRd,\n    clims = (0, 1),\n    aspect_ratio = 1,\n    size = (600, 500)\n)\n\n\n\n\n\nInterpreting Burn Probability\n\n1.0 (100%): Cell burned in all simulations - high confidence area\n0.5 (50%): Cell burned in half of simulations - moderate uncertainty\n0.0 (0%): Cell never burned - outside potential fire extent\n\n\n# Probability contours\ncontour(\n    result.burn_probability',\n    title = \"Burn Probability Contours\",\n    levels = [0.1, 0.25, 0.5, 0.75, 0.9],\n    color = :reds,\n    fill = true,\n    aspect_ratio = 1,\n    size = (600, 500)\n)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#mean-arrival-time",
    "href": "tutorials/ensemble.html#mean-arrival-time",
    "title": "Ensemble Simulations",
    "section": "Mean Arrival Time",
    "text": "Mean Arrival Time\nAverage time of arrival across ensemble members (for cells that burned):\n\nmean_toa = copy(result.mean_arrival_time)\nmean_toa[mean_toa .&lt; 0] .= NaN\n\nheatmap(\n    mean_toa',\n    title = \"Mean Time of Arrival (minutes)\",\n    color = :viridis,\n    aspect_ratio = 1,\n    size = (600, 500)\n)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#individual-ensemble-members",
    "href": "tutorials/ensemble.html#individual-ensemble-members",
    "title": "Ensemble Simulations",
    "section": "Individual Ensemble Members",
    "text": "Individual Ensemble Members\nWith save_individual_results = true, we can examine specific members:\n\n# Compare smallest and largest fires\nareas = [m.burned_area_acres for m in result.members]\nmin_idx = argmin(areas)\nmax_idx = argmax(areas)\n\np1 = heatmap(result.members[min_idx].burned',\n    title = \"Smallest Fire\\n$(round(areas[min_idx], digits=2)) acres\",\n    color = :YlOrRd, aspect_ratio = 1, colorbar = false)\n\np2 = heatmap(result.members[max_idx].burned',\n    title = \"Largest Fire\\n$(round(areas[max_idx], digits=2)) acres\",\n    color = :YlOrRd, aspect_ratio = 1, colorbar = false)\n\nplot(p1, p2, layout = (1, 2), size = (800, 400))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#burned-area-distribution",
    "href": "tutorials/ensemble.html#burned-area-distribution",
    "title": "Ensemble Simulations",
    "section": "Burned Area Distribution",
    "text": "Burned Area Distribution\nExamine the distribution of burned area across ensemble members:\n\nareas = [m.burned_area_acres for m in result.members]\n\nhistogram(areas,\n    xlabel = \"Burned Area (acres)\",\n    ylabel = \"Frequency\",\n    title = \"Burned Area Distribution\",\n    legend = false,\n    bins = 15,\n    color = :orange\n)\n\n\n\n\n\n# Statistics\nprintln(\"Burned Area Statistics:\")\nprintln(\"  Minimum: $(round(minimum(areas), digits=2)) acres\")\nprintln(\"  25th percentile: $(round(sort(areas)[div(end,4)], digits=2)) acres\")\nprintln(\"  Median: $(round(sort(areas)[div(end,2)], digits=2)) acres\")\nprintln(\"  75th percentile: $(round(sort(areas)[3*div(end,4)], digits=2)) acres\")\nprintln(\"  Maximum: $(round(maximum(areas), digits=2)) acres\")\n\nBurned Area Statistics:\n  Minimum: 36.8 acres\n  25th percentile: 52.23 acres\n  Median: 56.16 acres\n  75th percentile: 58.72 acres\n  Maximum: 64.57 acres",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#exceedance-probability",
    "href": "tutorials/ensemble.html#exceedance-probability",
    "title": "Ensemble Simulations",
    "section": "Exceedance Probability",
    "text": "Exceedance Probability\nCalculate the probability that fire exceeds a given size:\n\nthresholds = 10:5:80\nprobs = [get_exceedance_probability(result, Float64(t)) for t in thresholds]\n\nplot(thresholds, probs .* 100,\n    xlabel = \"Burned Area Threshold (acres)\",\n    ylabel = \"Probability of Exceedance (%)\",\n    title = \"Exceedance Probability Curve\",\n    linewidth = 2,\n    legend = false,\n    ylims = (0, 100)\n)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#percentile-fires",
    "href": "tutorials/ensemble.html#percentile-fires",
    "title": "Ensemble Simulations",
    "section": "Percentile Fires",
    "text": "Percentile Fires\nGet representative fires at specific percentiles:\n\npercentiles = [10, 50, 90]\nplots = []\n\nfor p in percentiles\n    member = get_percentile_fire(result, Float64(p))\n    push!(plots, heatmap(member.burned',\n        title = \"$(p)th Percentile\\n$(round(member.burned_area_acres, digits=1)) acres\",\n        color = :YlOrRd, aspect_ratio = 1, colorbar = false))\nend\n\nplot(plots..., layout = (1, 3), size = (900, 300))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#convergence-analysis",
    "href": "tutorials/ensemble.html#convergence-analysis",
    "title": "Ensemble Simulations",
    "section": "Convergence Analysis",
    "text": "Convergence Analysis\nCheck if the ensemble has converged (burn probability stabilizing):\n\nplot(result.convergence_history,\n    xlabel = \"Ensemble Member\",\n    ylabel = \"RMS Change in Burn Probability\",\n    title = \"Ensemble Convergence\",\n    linewidth = 1.5,\n    legend = false,\n    yscale = :log10\n)\n\nprintln(\"Converged: \", check_convergence(result, threshold = 0.001))\n\nConverged: false",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#effect-of-ensemble-size",
    "href": "tutorials/ensemble.html#effect-of-ensemble-size",
    "title": "Ensemble Simulations",
    "section": "Effect of Ensemble Size",
    "text": "Effect of Ensemble Size\nCompare ensembles of different sizes:\n\nensemble_sizes = [10, 25, 50, 100]\nburn_prob_maps = []\n\nfor n in ensemble_sizes\n    cfg = EnsembleConfig{Float64}(\n        n_simulations = n,\n        base_seed = UInt64(42),\n        perturbation = perturbation,\n        simulation_config = SimulationConfig{Float64}(),\n        save_individual_results = false\n    )\n\n    res = run_ensemble!(cfg, state_template, fuel_ids, fuel_table, weather,\n        slope, aspect, 40, 40, 0.0, 45.0; show_progress = false)\n\n    push!(burn_prob_maps, heatmap(res.burn_probability',\n        title = \"n = $n\",\n        color = :YlOrRd, clims = (0, 1),\n        aspect_ratio = 1, colorbar = false))\nend\n\nplot(burn_prob_maps..., layout = (2, 2), size = (700, 700),\n    plot_title = \"Burn Probability vs Ensemble Size\")",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#parallel-ensemble-execution",
    "href": "tutorials/ensemble.html#parallel-ensemble-execution",
    "title": "Ensemble Simulations",
    "section": "Parallel Ensemble Execution",
    "text": "Parallel Ensemble Execution\nFor large ensembles, use multi-threading:\n\n# Check available threads\nprintln(\"Available threads: \", Threads.nthreads())\n\n# Parallel configuration\nparallel_config = ParallelConfig(n_workers = 0, chunk_size = 1)  # 0 = auto-detect\n\n# Larger ensemble for parallel demo\nlarge_config = EnsembleConfig{Float64}(\n    n_simulations = 100,\n    base_seed = UInt64(99),\n    perturbation = perturbation,\n    save_individual_results = false\n)\n\n# Run threaded ensemble\n@time result_parallel = run_ensemble_threaded!(\n    large_config,\n    state_template,\n    fuel_ids,\n    fuel_table,\n    weather,\n    slope,\n    aspect,\n    40, 40,\n    0.0, 45.0;\n    parallel_config = parallel_config,\n    show_progress = false\n)\n\nprintln(\"Threaded ensemble mean area: $(round(result_parallel.mean_burned_area, digits=2)) acres\")\n\nAvailable threads: 1\n  4.898495 seconds (789.01 k allocations: 51.356 MiB, 0.25% gc time, 9.06% compilation time)\nThreaded ensemble mean area: 55.65 acres",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#sensitivity-to-perturbation-magnitude",
    "href": "tutorials/ensemble.html#sensitivity-to-perturbation-magnitude",
    "title": "Ensemble Simulations",
    "section": "Sensitivity to Perturbation Magnitude",
    "text": "Sensitivity to Perturbation Magnitude\nExplore how uncertainty ranges affect results:\n\n# Low uncertainty\nlow_pert = PerturbationConfig{Float64}(\n    ignition_perturb_radius = 1.0,\n    wind_speed_factor_range = (0.95, 1.05),\n    wind_direction_std = 5.0,\n    moisture_factor_range = (0.95, 1.05)\n)\n\n# High uncertainty\nhigh_pert = PerturbationConfig{Float64}(\n    ignition_perturb_radius = 5.0,\n    wind_speed_factor_range = (0.6, 1.4),\n    wind_direction_std = 30.0,\n    moisture_factor_range = (0.7, 1.3)\n)\n\nplots = []\nfor (pert, label) in [(low_pert, \"Low Uncertainty\"), (high_pert, \"High Uncertainty\")]\n    cfg = EnsembleConfig{Float64}(\n        n_simulations = 50,\n        base_seed = UInt64(42),\n        perturbation = pert,\n        save_individual_results = false\n    )\n\n    res = run_ensemble!(cfg, state_template, fuel_ids, fuel_table, weather,\n        slope, aspect, 40, 40, 0.0, 45.0; show_progress = false)\n\n    push!(plots, heatmap(res.burn_probability',\n        title = \"$label\\nStd Area: $(round(res.std_burned_area, digits=1)) ac\",\n        color = :YlOrRd, clims = (0, 1), aspect_ratio = 1))\nend\n\nplot(plots..., layout = (1, 2), size = (800, 400))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#practical-applications",
    "href": "tutorials/ensemble.html#practical-applications",
    "title": "Ensemble Simulations",
    "section": "Practical Applications",
    "text": "Practical Applications\n\n1. Evacuation Planning\nUse exceedance probabilities to identify areas at risk:\n\n# Areas with &gt;50% chance of burning within 45 minutes\nhigh_risk = result.burn_probability .&gt;= 0.5\n\nheatmap(high_risk',\n    title = \"High Risk Zone (≥50% burn probability)\",\n    color = [:white, :red],\n    aspect_ratio = 1,\n    colorbar = false\n)\n\n\n\n\n\n\n2. Resource Pre-positioning\nIdentify areas where fire is likely to spread next:\n\n# Areas with 10-50% probability (transition zone)\ntransition_zone = (result.burn_probability .&gt;= 0.1) .& (result.burn_probability .&lt; 0.5)\n\nheatmap(transition_zone',\n    title = \"Transition Zone (10-50% probability)\",\n    color = [:white, :yellow],\n    aspect_ratio = 1,\n    colorbar = false\n)\n\n\n\n\n\n\n3. Communicating Uncertainty\nPresent multiple scenarios to decision makers:\n\n# Get 10th, 50th, and 90th percentile scenarios\nsmall = get_percentile_fire(result, 10.0)\nmedian = get_percentile_fire(result, 50.0)\nlarge = get_percentile_fire(result, 90.0)\n\n# Overlay contours\np = plot(aspect_ratio = 1, legend = :topleft,\n    title = \"Fire Spread Scenarios\",\n    xlabel = \"X\", ylabel = \"Y\")\n\n# Find perimeters (simplified as contours of burned area)\ncontour!(p, Float64.(small.burned)', levels = [0.5],\n    linecolor = :green, linewidth = 2, label = \"10th percentile\")\ncontour!(p, Float64.(median.burned)', levels = [0.5],\n    linecolor = :orange, linewidth = 2, label = \"50th percentile\")\ncontour!(p, Float64.(large.burned)', levels = [0.5],\n    linecolor = :red, linewidth = 2, label = \"90th percentile\")\n\np",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/ensemble.html#best-practices",
    "href": "tutorials/ensemble.html#best-practices",
    "title": "Ensemble Simulations",
    "section": "Best Practices",
    "text": "Best Practices\n\nEnsemble Size: Start with 50-100 members; increase if convergence is poor\nPerturbation Ranges: Base on actual measurement/forecast uncertainty\nSeed Setting: Use consistent seeds for reproducibility\nSave Results: Store ensemble output for post-processing\nParallel Execution: Use threading for ensembles &gt; 50 members",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ensemble Simulations</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html",
    "href": "tutorials/wui.html",
    "title": "WUI Modeling",
    "section": "",
    "text": "WUI Concepts\nThe Wildland-Urban Interface (WUI) is where homes and structures meet wildland vegetation. This tutorial covers modeling building ignition during wildfires.\nBuildings in the WUI can ignite from:",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#wui-concepts",
    "href": "tutorials/wui.html#wui-concepts",
    "title": "WUI Modeling",
    "section": "",
    "text": "Direct flame contact - Fire reaches the structure\nRadiative heat - Heat flux from nearby flames\nEmbers (firebrands) - Burning debris lands on combustibles\nBuilding-to-building spread - Fire spreads between structures",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#creating-buildings",
    "href": "tutorials/wui.html#creating-buildings",
    "title": "WUI Modeling",
    "section": "Creating Buildings",
    "text": "Creating Buildings\nDefine individual buildings:\n\n# Create a wood-frame building\nbuilding = WUIBuilding{Float64}(\n    1,              # ID\n    30, 30;         # Grid coordinates\n    construction_type = :wood,\n    combustible_fraction = 0.7,\n    ignition_temperature = 300.0\n)\n\nprintln(\"Building $(building.id) at ($(building.ix), $(building.iy))\")\nprintln(\"  Type: $(building.construction_type)\")\nprintln(\"  Combustible fraction: $(building.combustible_fraction)\")\n\nBuilding 1 at (30, 30)\n  Type: wood\n  Combustible fraction: 0.7\n\n\n\nConstruction Types\nDifferent construction materials have different vulnerability:\n\nconstruction_types = [:wood, :masonry, :mixed]\n\nfor ctype in construction_types\n    b = WUIBuilding{Float64}(1, 10, 10; construction_type = ctype)\n    # Test ignition probability at same heat flux\n    prob = building_ignition_probability(b, 30.0, 10.0)\n    println(\"$ctype: Ignition probability = $(round(prob * 100, digits=1))%\")\nend\n\nwood: Ignition probability = 100.0%\nmasonry: Ignition probability = 83.2%\nmixed: Ignition probability = 99.8%",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#creating-a-wui-grid",
    "href": "tutorials/wui.html#creating-a-wui-grid",
    "title": "WUI Modeling",
    "section": "Creating a WUI Grid",
    "text": "Creating a WUI Grid\nFor simulations, create a grid of buildings:\n\nncols, nrows = 100, 100\n\n# Create a grid of buildings\nbuildings = create_building_grid(\n    Float64,\n    ncols, nrows,\n    10,             # Building spacing (cells)\n    3,              # Building footprint (cells)\n    20, 20;         # Starting position\n    construction_type = :wood\n)\n\n# Create WUI grid\nwui_grid = WUIGrid{Float64}(buildings, ncols, nrows)\n\nprintln(\"Created $(length(buildings)) buildings\")\n\n# Visualize building locations\nbuilding_map = zeros(ncols, nrows)\nfor b in buildings\n    building_map[b.ix, b.iy] = 1\nend\n\nheatmap(building_map',\n    title = \"Building Locations\",\n    color = [:white, :blue],\n    aspect_ratio = 1,\n    colorbar = false\n)\n\nCreated 64 buildings",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#radiative-heat-flux",
    "href": "tutorials/wui.html#radiative-heat-flux",
    "title": "WUI Modeling",
    "section": "Radiative Heat Flux",
    "text": "Radiative Heat Flux\nBuildings ignite from radiant heat when nearby fire intensities are high:\n\n# Heat flux vs distance for different fireline intensities\ndistances = 1:1:50  # meters\nintensities = [500, 1000, 2000, 4000]  # kW/m\n\np = plot(xlabel = \"Distance (m)\", ylabel = \"Heat Flux (kW/m²)\",\n    title = \"Radiative Heat Flux from Fire\", legend = :topright)\n\nfor I in intensities\n    fluxes = [compute_radiative_heat_flux(Float64(I), Float64(d), 5.0) for d in distances]\n    plot!(p, distances, fluxes, label = \"I = $I kW/m\", linewidth = 2)\nend\n\n# Add ignition threshold\nhline!(p, [12.5], linestyle = :dash, color = :red, label = \"Wood ignition threshold\")\n\np",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#building-ignition-probability",
    "href": "tutorials/wui.html#building-ignition-probability",
    "title": "WUI Modeling",
    "section": "Building Ignition Probability",
    "text": "Building Ignition Probability\nIgnition probability depends on heat flux and exposure time:\n\nwood_building = WUIBuilding{Float64}(1, 10, 10; construction_type = :wood)\nmasonry_building = WUIBuilding{Float64}(2, 10, 10; construction_type = :masonry)\n\n# Heat flux range\nheat_fluxes = 5:5:50  # kW/m²\nexposure_time = 10.0  # minutes\n\np = plot(xlabel = \"Heat Flux (kW/m²)\", ylabel = \"Ignition Probability\",\n    title = \"Building Ignition Probability (10 min exposure)\",\n    legend = :bottomright)\n\nwood_probs = [building_ignition_probability(wood_building, Float64(q), exposure_time)\n    for q in heat_fluxes]\nmasonry_probs = [building_ignition_probability(masonry_building, Float64(q), exposure_time)\n    for q in heat_fluxes]\n\nplot!(p, heat_fluxes, wood_probs, label = \"Wood\", linewidth = 2)\nplot!(p, heat_fluxes, masonry_probs, label = \"Masonry\", linewidth = 2)\n\np\n\n\n\n\n\nEffect of Exposure Time\n\nexposure_times = [1, 5, 10, 20, 30]  # minutes\nheat_flux = 25.0  # kW/m²\n\nprobs = [building_ignition_probability(wood_building, heat_flux, Float64(t))\n    for t in exposure_times]\n\nbar(string.(exposure_times),\n    probs .* 100,\n    xlabel = \"Exposure Time (min)\",\n    ylabel = \"Ignition Probability (%)\",\n    title = \"Ignition Probability vs Exposure Time\\n(Wood building, 25 kW/m² heat flux)\",\n    legend = false,\n    color = :orange\n)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#hamada-urban-fire-spread",
    "href": "tutorials/wui.html#hamada-urban-fire-spread",
    "title": "WUI Modeling",
    "section": "Hamada Urban Fire Spread",
    "text": "Hamada Urban Fire Spread\nThe Hamada model describes fire spread between buildings:\n\nsource = WUIBuilding{Float64}(1, 10, 10; construction_type = :wood)\nparams = HamadaParameters{Float64}(\n    critical_separation = 15.0,  # meters\n    wind_spread_factor = 1.5,\n    ember_generation_rate = 0.1,\n    base_spread_rate = 1.0\n)\n\n# Probability vs distance\nseparations = 1:1:20  # cells\ncellsize = 1.0  # feet (small for test)\n\nprobs = Float64[]\nfor sep in separations\n    target = WUIBuilding{Float64}(2, 10 + sep, 10; construction_type = :wood)\n    prob = hamada_spread_probability(source, target, params, 10.0, 270.0, cellsize)\n    push!(probs, prob)\nend\n\n# Convert cell distance to meters\ndist_m = separations .* cellsize .* 0.3048\n\nplot(dist_m, probs,\n    xlabel = \"Building Separation (m)\",\n    ylabel = \"Spread Probability\",\n    title = \"Hamada Building-to-Building Spread\",\n    linewidth = 2,\n    legend = false\n)\nvline!([params.critical_separation], linestyle = :dash, label = \"Critical separation\")",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#wui-simulation-example",
    "href": "tutorials/wui.html#wui-simulation-example",
    "title": "WUI Modeling",
    "section": "WUI Simulation Example",
    "text": "WUI Simulation Example\nSimulate a fire approaching a residential area:\n\nncols, nrows = 120, 120\ncellsize = 30.0\n\n# Create fire state\nstate = FireState{Float64}(ncols, nrows, cellsize)\nfuel_table = create_standard_fuel_table(Float64)\n\n# Fuel: grass with houses in upper portion\nfuel_ids = fill(1, ncols, nrows)\n\n# Terrain\nslope = zeros(Float64, ncols, nrows)\naspect = zeros(Float64, ncols, nrows)\n\n# Weather - wind blowing north\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 12.0,\n    wind_direction = 180.0,  # From south\n    M1 = 0.05, M10 = 0.07, M100 = 0.09,\n    MLH = 0.50, MLW = 0.80\n)\n\n# Create WUI with buildings in northern portion\nbuildings = WUIBuilding{Float64}[]\nid = 0\nfor ix in 30:15:90\n    for iy in 70:15:100\n        id += 1\n        ctype = rand([:wood, :wood, :masonry])  # 2/3 wood, 1/3 masonry\n        push!(buildings, WUIBuilding{Float64}(id, ix, iy; construction_type = ctype))\n    end\nend\n\nwui_grid = WUIGrid{Float64}(buildings, ncols, nrows)\nprintln(\"Created $(length(buildings)) buildings\")\n\n# Ignite in southern portion\nignite!(state, 60, 20, 0.0)\n\n# Run simulation and track WUI state\nweather_interp = create_constant_interpolator(weather, ncols, nrows, cellsize)\nrng = MersenneTwister(42)\n\n# Simple simulation loop with WUI updates\nt = 0.0\ndt = 1.0\nt_end = 60.0\n\nwhile t &lt; t_end\n    # Update WUI state\n    ignitions = update_wui_state!(wui_grid, state, weather, t, dt, rng)\n\n    if !isempty(ignitions)\n        for ig in ignitions\n            println(\"Building $(ig.building_id) ignited at t=$(round(t, digits=1)) via $(ig.ignition_source)\")\n        end\n    end\n\n    t += dt\nend\n\n# Also run fire simulation\nstate2 = FireState{Float64}(ncols, nrows, cellsize)\nignite!(state2, 60, 20, 0.0)\nsimulate_uniform!(state2, 1, fuel_table, weather, 0.0, 0.0, 0.0, t_end)\n\n# Visualize\np1 = heatmap(state2.burned',\n    title = \"Fire Spread\",\n    color = :YlOrRd,\n    aspect_ratio = 1\n)\n\n# Add building markers\nbuilding_x = [b.ix for b in buildings]\nbuilding_y = [b.iy for b in buildings]\ncolors = [wui_grid.ignited[i] ? :red : :blue for i in 1:length(buildings)]\n\nscatter!(p1, building_x, building_y,\n    color = colors,\n    markersize = 6,\n    markershape = :square,\n    label = false\n)\n\np1\n\nCreated 15 buildings",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#wui-statistics",
    "href": "tutorials/wui.html#wui-statistics",
    "title": "WUI Modeling",
    "section": "WUI Statistics",
    "text": "WUI Statistics\nGet summary statistics from the simulation:\n\nstats = get_wui_statistics(wui_grid)\n\nprintln(\"WUI Simulation Results:\")\nprintln(\"  Total buildings: $(stats.total_buildings)\")\nprintln(\"  Ignited buildings: $(stats.ignited_buildings)\")\nprintln(\"  Ignition fraction: $(round(stats.ignition_fraction * 100, digits=1))%\")\nprintln(\"  Mean ignition time: $(round(stats.mean_ignition_time, digits=1)) min\")\nprintln(\"  First ignition: $(round(stats.first_ignition_time, digits=1)) min\")\nprintln(\"  Last ignition: $(round(stats.last_ignition_time, digits=1)) min\")\nprintln(\"  Wood ignited: $(stats.wood_ignited)\")\nprintln(\"  Masonry ignited: $(stats.masonry_ignited)\")\n\nWUI Simulation Results:\n  Total buildings: 15\n  Ignited buildings: 0\n  Ignition fraction: 0.0%\n  Mean ignition time: 0.0 min\n  First ignition: -1.0 min\n  Last ignition: -1.0 min\n  Wood ignited: 0\n  Masonry ignited: 0",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#view-factor-calculation",
    "href": "tutorials/wui.html#view-factor-calculation",
    "title": "WUI Modeling",
    "section": "View Factor Calculation",
    "text": "View Factor Calculation\nThe view factor determines how much radiative heat a building receives:\n\nflame_heights = [2, 5, 10, 20]  # meters\ndistances = 1:1:30  # meters\n\np = plot(xlabel = \"Distance (m)\", ylabel = \"View Factor\",\n    title = \"View Factor vs Distance\", legend = :topright)\n\nfor H in flame_heights\n    vfs = [compute_view_factor(Float64(H), Float64(d)) for d in distances]\n    plot!(p, distances, vfs, label = \"Flame = $H m\", linewidth = 2)\nend\n\np",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#defense-zone-effectiveness",
    "href": "tutorials/wui.html#defense-zone-effectiveness",
    "title": "WUI Modeling",
    "section": "Defense Zone Effectiveness",
    "text": "Defense Zone Effectiveness\nSimulate different defensible space configurations:\n\n# Test different buffer distances\nbuffer_distances = [0, 30, 60, 100]  # feet\nresults = []\n\nfor buffer in buffer_distances\n    # Create scenario where fire approaches building\n    state = FireState{Float64}(80, 80, 30.0)\n\n    # Create fuel map with buffer zone\n    fuel_ids = fill(4, 80, 80)  # Chaparral\n    if buffer &gt; 0\n        buffer_cells = div(buffer, 30)\n        # Clear area around building at (40, 60)\n        for ix in max(1, 40-buffer_cells):min(80, 40+buffer_cells)\n            for iy in max(1, 60-buffer_cells):min(80, 60+buffer_cells)\n                fuel_ids[ix, iy] = 1  # Grass (lower intensity)\n            end\n        end\n    end\n\n    ignite!(state, 40, 20, 0.0)\n    simulate!(state, fuel_ids, fuel_table, weather, slope, aspect, 0.0, 45.0)\n\n    # Check if fire reached building location\n    reached = state.burned[40, 60]\n    intensity = state.fireline_intensity[40, 60]\n\n    push!(results, (buffer, reached, intensity))\nend\n\nfor (buf, reached, intensity) in results\n    status = reached ? \"REACHED (I=$(round(intensity, digits=0)) kW/m)\" : \"Did not reach\"\n    println(\"Buffer $(buf)ft: $status\")\nend\n\nBuffer 0ft: REACHED (I=23501.0 kW/m)\nBuffer 30ft: REACHED (I=442.0 kW/m)\nBuffer 60ft: REACHED (I=442.0 kW/m)\nBuffer 100ft: REACHED (I=442.0 kW/m)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#best-practices-for-wui-modeling",
    "href": "tutorials/wui.html#best-practices-for-wui-modeling",
    "title": "WUI Modeling",
    "section": "Best Practices for WUI Modeling",
    "text": "Best Practices for WUI Modeling\n\nBuilding Data: Use actual building footprints and construction types when available\nDefensible Space: Model vegetation clearing around structures\nEmber Transport: Enable spotting for long-range ignitions\nEnsemble Approach: Run multiple scenarios to capture uncertainty\nValidation: Compare with post-fire damage assessments",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/wui.html#limitations",
    "href": "tutorials/wui.html#limitations",
    "title": "WUI Modeling",
    "section": "Limitations",
    "text": "Limitations\n\nSimplified building geometry (point representation)\nUniform construction within building type\nNo interior fire dynamics\nLimited suppression effects\n\nFor detailed structure loss modeling, consider coupling with dedicated WUI loss models.",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>WUI Modeling</span>"
    ]
  },
  {
    "objectID": "tutorials/suppression.html",
    "href": "tutorials/suppression.html",
    "title": "Suppression",
    "section": "",
    "text": "Suppression Resources\nThis tutorial covers fire suppression modeling in Elmfire.jl.\nElmfire supports different resource types:\n# Create different resource types\nhand_crew = SuppressionResource{Float64}(1, :hand_crew; location_x = 10.0, location_y = 10.0)\nengine = SuppressionResource{Float64}(2, :engine; location_x = 15.0, location_y = 10.0)\ndozer = SuppressionResource{Float64}(3, :dozer; location_x = 20.0, location_y = 10.0)\naircraft = SuppressionResource{Float64}(4, :aircraft; location_x = 50.0, location_y = 50.0)\n\nfor r in [hand_crew, engine, dozer, aircraft]\n    println(\"$(r.resource_type): Production rate = $(r.line_production_rate) ft/min, Width = $(r.effective_width) ft\")\nend\n\nhand_crew: Production rate = 2.5 ft/min, Width = 6.0 ft\nengine: Production rate = 5.0 ft/min, Width = 10.0 ft\ndozer: Production rate = 20.0 ft/min, Width = 15.0 ft\naircraft: Production rate = 100.0 ft/min, Width = 100.0 ft",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Suppression</span>"
    ]
  },
  {
    "objectID": "tutorials/suppression.html#creating-suppression-state",
    "href": "tutorials/suppression.html#creating-suppression-state",
    "title": "Suppression",
    "section": "Creating Suppression State",
    "text": "Creating Suppression State\n\nncols, nrows = 100, 100\n\nsupp_state = SuppressionState{Float64}(ncols, nrows)\n\n# Add resources\nadd_resource!(supp_state, hand_crew)\nadd_resource!(supp_state, engine)\nadd_resource!(supp_state, dozer)\n\nprintln(\"Total resources: $(length(supp_state.resources))\")\n\nTotal resources: 3",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Suppression</span>"
    ]
  },
  {
    "objectID": "tutorials/suppression.html#resource-assignment",
    "href": "tutorials/suppression.html#resource-assignment",
    "title": "Suppression",
    "section": "Resource Assignment",
    "text": "Resource Assignment\nAssign resources to build containment lines:\n\n# Assign dozer to build line from (30,30) to (30,70)\ntargets = [(30, y) for y in 30:5:70]\nassign_resource!(supp_state, 3, targets)\n\n# Check assignment\nprintln(\"Dozer status: $(supp_state.resources[3].status)\")\nprintln(\"Assignment targets: $(length(supp_state.active_assignments[3])) cells\")\n\nDozer status: deployed\nAssignment targets: 9 cells",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Suppression</span>"
    ]
  },
  {
    "objectID": "tutorials/suppression.html#building-containment-lines",
    "href": "tutorials/suppression.html#building-containment-lines",
    "title": "Suppression",
    "section": "Building Containment Lines",
    "text": "Building Containment Lines\n\nfire_state = FireState{Float64}(ncols, nrows, 30.0)\n\n# Manually construct a line\ncells_built, length_built = construct_containment_line!(\n    supp_state,\n    supp_state.resources[3],  # Dozer\n    30, 30,                    # Start\n    30, 50,                    # Target\n    20.0,                      # Time (minutes)\n    30.0,                      # Cell size\n    0.0                        # Current time\n)\n\nprintln(\"Built $(length(cells_built)) cells\")\nprintln(\"Length: $(round(length_built, digits=0)) ft\")\n\n# Visualize\nheatmap(supp_state.contained_cells',\n    title = \"Containment Line\",\n    color = [:white, :blue],\n    aspect_ratio = 1\n)\n\nBuilt 14 cells\nLength: 420.0 ft",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Suppression</span>"
    ]
  },
  {
    "objectID": "tutorials/suppression.html#containment-effectiveness",
    "href": "tutorials/suppression.html#containment-effectiveness",
    "title": "Suppression",
    "section": "Containment Effectiveness",
    "text": "Containment Effectiveness\nContainment lines reduce fire spread:\n\n# Check effectiveness at contained cells\nix, iy = cells_built[1]\neff = supp_state.containment_effectiveness[ix, iy]\nprintln(\"Effectiveness at ($ix, $iy): $(round((1-eff)*100, digits=0))% reduction\")\n\nEffectiveness at (30, 30): 95.0% reduction",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Suppression</span>"
    ]
  },
  {
    "objectID": "tutorials/suppression.html#simulation-with-suppression",
    "href": "tutorials/suppression.html#simulation-with-suppression",
    "title": "Suppression",
    "section": "Simulation with Suppression",
    "text": "Simulation with Suppression\n\nncols, nrows = 100, 100\ncellsize = 30.0\n\nfire_state = FireState{Float64}(ncols, nrows, cellsize)\nsupp_state = SuppressionState{Float64}(ncols, nrows)\nfuel_table = create_standard_fuel_table(Float64)\nfuel_ids = fill(1, ncols, nrows)\nslope = zeros(Float64, ncols, nrows)\naspect = zeros(Float64, ncols, nrows)\n\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 10.0,\n    wind_direction = 270.0,\n    M1 = 0.06, M10 = 0.08, M100 = 0.10,\n    MLH = 0.60, MLW = 0.90\n)\n\n# Add a dozer\ndozer = SuppressionResource{Float64}(1, :dozer; location_x = 70.0, location_y = 30.0)\nadd_resource!(supp_state, dozer)\n\n# Pre-build containment line ahead of fire\nfor y in 30:70\n    supp_state.contained_cells[70, y] = true\n    supp_state.containment_effectiveness[70, y] = 0.1  # 90% reduction\nend\n\n# Ignite fire\nignite!(fire_state, 40, 50, 0.0)\n\n# Run simulation with suppression\nsimulate_with_suppression!(\n    fire_state,\n    supp_state,\n    fuel_ids,\n    fuel_table,\n    weather,\n    slope,\n    aspect,\n    0.0, 45.0\n)\n\n# Visualize\np1 = heatmap(fire_state.burned',\n    title = \"Fire with Containment Line\",\n    color = :YlOrRd, aspect_ratio = 1)\n\n# Overlay containment line\ncontained_x = [ix for ix in 1:ncols for iy in 1:nrows if supp_state.contained_cells[ix, iy]]\ncontained_y = [iy for ix in 1:ncols for iy in 1:nrows if supp_state.contained_cells[ix, iy]]\nscatter!(p1, contained_x, contained_y, color = :blue, markersize = 2, label = \"Containment\")\n\np1",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Suppression</span>"
    ]
  },
  {
    "objectID": "tutorials/suppression.html#comparing-with-and-without-suppression",
    "href": "tutorials/suppression.html#comparing-with-and-without-suppression",
    "title": "Suppression",
    "section": "Comparing With and Without Suppression",
    "text": "Comparing With and Without Suppression\n\n# Without suppression\nstate_no_supp = FireState{Float64}(ncols, nrows, cellsize)\nignite!(state_no_supp, 40, 50, 0.0)\nsimulate_uniform!(state_no_supp, 1, fuel_table, weather, 0.0, 0.0, 0.0, 45.0)\n\n# With suppression (already run above as fire_state)\n\np1 = heatmap(state_no_supp.burned',\n    title = \"No Suppression\\n$(round(get_burned_area_acres(state_no_supp), digits=1)) acres\",\n    color = :YlOrRd, aspect_ratio = 1)\n\np2 = heatmap(fire_state.burned',\n    title = \"With Containment Line\\n$(round(get_burned_area_acres(fire_state), digits=1)) acres\",\n    color = :YlOrRd, aspect_ratio = 1)\n\nplot(p1, p2, layout = (1, 2), size = (800, 400))",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Suppression</span>"
    ]
  },
  {
    "objectID": "tutorials/suppression.html#suppression-statistics",
    "href": "tutorials/suppression.html#suppression-statistics",
    "title": "Suppression",
    "section": "Suppression Statistics",
    "text": "Suppression Statistics\n\nstats = get_suppression_statistics(supp_state)\n\nprintln(\"Suppression Summary:\")\nprintln(\"  Total resources: $(stats.total_resources)\")\nprintln(\"  Available: $(stats.available)\")\nprintln(\"  Deployed: $(stats.deployed)\")\nprintln(\"  Resting: $(stats.resting)\")\nprintln(\"  Contained cells: $(stats.contained_cells)\")\nprintln(\"  Total line: $(round(stats.total_line_feet, digits=0)) ft ($(round(stats.total_line_miles, digits=2)) miles)\")\n\nSuppression Summary:\n  Total resources: 1\n  Available: 1\n  Deployed: 0\n  Resting: 0\n  Contained cells: 41\n  Total line: 0.0 ft (0.0 miles)",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Suppression</span>"
    ]
  },
  {
    "objectID": "tutorials/suppression.html#tactical-planning",
    "href": "tutorials/suppression.html#tactical-planning",
    "title": "Suppression",
    "section": "Tactical Planning",
    "text": "Tactical Planning\nPlan indirect attack ahead of fire:\n\n# Get current fire state\nstate = FireState{Float64}(ncols, nrows, cellsize)\nfor ix in 35:45, iy in 45:55\n    state.burned[ix, iy] = true\nend\n\n# Plan indirect line 5 cells ahead\nline_cells = plan_indirect_attack(state, weather, 5)\n\nprintln(\"Planned $(length(line_cells)) cells for indirect attack\")\n\nPlanned 19 cells for indirect attack",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Suppression</span>"
    ]
  },
  {
    "objectID": "tutorials/suppression.html#direct-attack",
    "href": "tutorials/suppression.html#direct-attack",
    "title": "Suppression",
    "section": "Direct Attack",
    "text": "Direct Attack\nTarget the perimeter directly:\n\nperimeter = plan_direct_attack(state)\nprintln(\"Perimeter has $(length(perimeter)) cells for direct attack\")\n\nPerimeter has 40 cells for direct attack",
    "crumbs": [
      "Tutorials",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Suppression</span>"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "Core Modules\nThis section provides comprehensive API documentation for Elmfire.jl.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "reference/index.html#core-modules",
    "href": "reference/index.html#core-modules",
    "title": "API Reference",
    "section": "",
    "text": "Rothermel Fire Spread Model\nThe mathematical foundation of fire behavior prediction:\n\nsurface_spread_rate() - Calculate spread rate from Rothermel model\nelliptical_spread() - Compute elliptical fire shape (Anderson 1982)\nSpreadResult - Fire behavior outputs (velocity, intensity, heat)\nEllipticalSpread - Head, back, and flank fire rates\n\n\n\nFuel Models\nTypes and functions for managing fuel model data:\n\nFuelModel - Processed fuel model with derived quantities\nFuelModelTable - Collection of fuel models\ncreate_standard_fuel_table() - Create standard 13 FBFM fuel models\n\n\n\nSimulation\nFire simulation state and execution:\n\nFireState - Main simulation state container\nSimulationConfig - Configuration options\nsimulate!() / simulate_full!() - Run simulations\nignite!() - Start fires\n\n\n\nWeather\nWeather data management and interpolation:\n\nConstantWeather - Uniform weather conditions\nWeatherInterpolator - Spatiotemporal weather\ncreate_constant_interpolator() - Create interpolator from constant weather\n\n\n\nGeospatial I/O\nReading and writing geospatial data:\n\nread_geotiff() / write_geotiff() - GeoTIFF I/O\nread_landscape() - Load complete landscape data\ncompute_slope_aspect() - Derive terrain from DEM\n\n\n\nEnsemble\nMonte Carlo ensemble simulations:\n\nEnsembleConfig - Ensemble configuration\nrun_ensemble!() - Run Monte Carlo ensemble\nrun_ensemble_threaded!() - Parallel ensemble execution\n\n\n\nWUI & Suppression\nWildland-urban interface and fire suppression:\n\nWUIBuilding / WUIGrid - Building representation\nSuppressionResource / SuppressionState - Suppression modeling\nsimulate_with_suppression!() - Integrated suppression simulation",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "reference/index.html#quick-reference",
    "href": "reference/index.html#quick-reference",
    "title": "API Reference",
    "section": "Quick Reference",
    "text": "Quick Reference\n\nMain Types\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nFireState{T}\nSimulation state with level set, arrival times, burned area\n\n\nFuelModel{T}\nFuel model properties with derived spread coefficients\n\n\nSimulationConfig{T}\nCrown fire, spotting, and solver settings\n\n\nConstantWeather{T}\nUniform wind and moisture conditions\n\n\nEnsembleResult{T}\nMonte Carlo ensemble results and statistics\n\n\n\n\n\nMain Functions\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nsimulate!(state, ...)\nRun fire simulation\n\n\nsimulate_full!(state, ...)\nFull simulation with crown fire/spotting\n\n\nignite!(state, ix, iy, t)\nIgnite fire at grid location\n\n\nrun_ensemble!(config, ...)\nRun Monte Carlo ensemble\n\n\nread_landscape(T, paths...)\nLoad landscape from GeoTIFF files\n\n\n\n\n\nConstants\n# Unit conversions\nFT_TO_M = 0.3048        # Feet to meters\nM_TO_FT = 3.28084       # Meters to feet\nBTUPFT2MIN_TO_KWPM2 = 0.18956  # BTU/ft²/min to kW/m²",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "reference/index.html#type-parameters",
    "href": "reference/index.html#type-parameters",
    "title": "API Reference",
    "section": "Type Parameters",
    "text": "Type Parameters\nMost types in Elmfire.jl are parametric on the floating-point type T:\n# Float64 for maximum precision\nstate = FireState{Float64}(100, 100, 30.0)\n\n# Float32 for memory efficiency\nstate = FireState{Float32}(100, 100, 30.0f0)\nThis allows trading precision for memory when running large ensembles or high-resolution simulations.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "reference/rothermel.html",
    "href": "reference/rothermel.html",
    "title": "Rothermel Fire Spread Model",
    "section": "",
    "text": "Overview\nThe Rothermel surface fire spread model (Rothermel 1972) is the foundation of fire behavior prediction in Elmfire.jl. This page describes the mathematical equations and how they are implemented.\nThe Rothermel model predicts the rate of spread of a surface fire based on:\nThe model outputs several key fire behavior metrics:",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Rothermel Fire Spread Model</span>"
    ]
  },
  {
    "objectID": "reference/rothermel.html#overview",
    "href": "reference/rothermel.html#overview",
    "title": "Rothermel Fire Spread Model",
    "section": "",
    "text": "Fuel properties: Loading, particle size, moisture content, heat content\nEnvironmental factors: Wind speed and terrain slope\nPhysical processes: Heat transfer, combustion chemistry, and energy balance\n\n\n\n\n\n\n\n\n\n\n\nOutput\nSymbol\nUnits\nDescription\n\n\n\n\nRate of Spread\n\\(R\\)\nft/min\nFire front velocity\n\n\nReaction Intensity\n\\(I_R\\)\nBTU/ft²/min\nHeat release rate per unit area\n\n\nHeat per Unit Area\n\\(H_A\\)\nBTU/ft²\nTotal heat released\n\n\nFireline Intensity\n\\(I\\)\nBTU/ft/s\nByram’s fireline intensity",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Rothermel Fire Spread Model</span>"
    ]
  },
  {
    "objectID": "reference/rothermel.html#the-rothermel-equation",
    "href": "reference/rothermel.html#the-rothermel-equation",
    "title": "Rothermel Fire Spread Model",
    "section": "The Rothermel Equation",
    "text": "The Rothermel Equation\nThe fundamental equation for rate of spread is:\n\\[\nR = \\frac{I_R \\xi (1 + \\phi_w + \\phi_s)}{\\rho_b \\varepsilon Q_{ig}}\n\\]\nWhere:\n\n\n\nSymbol\nDescription\n\n\n\n\n\\(I_R\\)\nReaction intensity (BTU/ft²/min)\n\n\n\\(\\xi\\)\nPropagating flux ratio\n\n\n\\(\\phi_w\\)\nWind factor\n\n\n\\(\\phi_s\\)\nSlope factor\n\n\n\\(\\rho_b\\)\nFuel bed bulk density (lb/ft³)\n\n\n\\(\\varepsilon\\)\nEffective heating number\n\n\n\\(Q_{ig}\\)\nHeat of pre-ignition (BTU/lb)\n\n\n\n\nReaction Intensity\nReaction intensity represents the rate of heat release:\n\\[\nI_R = \\Gamma' w_n h \\eta_M \\eta_s\n\\]\nWhere: - \\(\\Gamma'\\) = optimum reaction velocity (1/min) - \\(w_n\\) = net fuel loading (lb/ft²) - \\(h\\) = heat of combustion (BTU/lb) - \\(\\eta_M\\) = moisture damping coefficient - \\(\\eta_s\\) = mineral damping coefficient\n\n\nMoisture Damping\nThe moisture damping coefficient reduces fire spread as fuel moisture increases:\n\\[\n\\eta_M = 1 - 2.59r + 5.11r^2 - 3.52r^3\n\\]\nWhere \\(r = M/M_{ex}\\) is the ratio of fuel moisture to moisture of extinction.\n\n# Visualize moisture damping\nr_values = 0:0.01:1\neta_m = [Elmfire.moisture_damping(r) for r in r_values]\n\nplot(r_values, eta_m,\n    xlabel = \"Moisture Ratio (M/Mₑₓ)\",\n    ylabel = \"Moisture Damping (ηₘ)\",\n    title = \"Rothermel Moisture Damping Coefficient\",\n    linewidth = 2,\n    legend = false,\n    ylims = (0, 1.1)\n)\n\n\n\n\n\n\nWind and Slope Factors\nWind accelerates fire spread through convective heat transfer:\n\\[\n\\phi_w = C \\left(\\frac{\\beta}{\\beta_{op}}\\right)^{-E} U^B\n\\]\nSlope accelerates uphill spread through radiant heat transfer:\n\\[\n\\phi_s = 5.275 \\beta^{-0.3} \\tan^2\\theta\n\\]\nWhere: - \\(\\beta\\) = packing ratio (dimensionless, fuel volume / bed volume) - \\(\\beta_{op}\\) = optimal packing ratio (dimensionless) - \\(U\\) = midflame wind speed (ft/min) - \\(\\tan^2\\theta\\) = squared tangent of slope angle (dimensionless) - \\(B\\), \\(C\\), \\(E\\) = empirical coefficients (dimensionless, functions of SAV ratio)",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Rothermel Fire Spread Model</span>"
    ]
  },
  {
    "objectID": "reference/rothermel.html#implementation-in-elmfire.jl",
    "href": "reference/rothermel.html#implementation-in-elmfire.jl",
    "title": "Rothermel Fire Spread Model",
    "section": "Implementation in Elmfire.jl",
    "text": "Implementation in Elmfire.jl\n\nSpreadResult Type\nThe surface_spread_rate function returns a SpreadResult struct:\nstruct SpreadResult{T&lt;:AbstractFloat}\n    velocity::T       # Spread rate (ft/min)\n    vs0::T            # Base spread rate without wind/slope (ft/min)\n    ir::T             # Reaction intensity (kW/m²)\n    hpua::T           # Heat per unit area (kJ/m²)\n    flin::T           # Fireline intensity (kW/m)\n    phiw::T           # Wind factor\n    phis::T           # Slope factor\nend\n\n\nComputing Spread Rate\n\n# Create fuel table and get fuel model\nfuel_table = create_standard_fuel_table(Float64)\nfm = get_fuel_model(fuel_table, 1, 60)  # Short grass at 60% live moisture\n\n# Define conditions\nM1 = 0.06    # 1-hour moisture (6%)\nM10 = 0.08   # 10-hour moisture (8%)\nM100 = 0.10  # 100-hour moisture (10%)\nMLH = 0.60   # Live herbaceous moisture (60%)\nMLW = 0.90   # Live woody moisture (90%)\nwind = 440.0 # Midflame wind speed (ft/min ≈ 5 mph)\nslope = 0.0  # tan²(slope angle)\n\n# Calculate spread rate\nresult = Elmfire.surface_spread_rate(fm, M1, M10, M100, MLH, MLW, wind, slope)\n\nprintln(\"Fire Spread Results:\")\nprintln(\"  Rate of spread: $(round(result.velocity, digits=1)) ft/min\")\nprintln(\"  Base rate (no wind/slope): $(round(result.vs0, digits=1)) ft/min\")\nprintln(\"  Reaction intensity: $(round(result.ir, digits=1)) kW/m²\")\nprintln(\"  Heat per unit area: $(round(result.hpua, digits=0)) kJ/m²\")\nprintln(\"  Fireline intensity: $(round(result.flin, digits=1)) kW/m\")\nprintln(\"  Wind factor (φw): $(round(result.phiw, digits=2))\")\nprintln(\"  Slope factor (φs): $(round(result.phis, digits=2))\")\n\nFire Spread Results:\n  Rate of spread: 103.3 ft/min\n  Base rate (no wind/slope): 4.6 ft/min\n  Reaction intensity: 156.4 kW/m²\n  Heat per unit area: 1030.0 kJ/m²\n  Fireline intensity: 540.6 kW/m\n  Wind factor (φw): 21.43\n  Slope factor (φs): 0.0\n\n\n\n\nEffect of Wind Speed\n\n# Spread rate vs wind speed for different fuel models\nfuel_ids = [1, 3, 4, 8]  # Short grass, tall grass, chaparral, timber litter\nfuel_names = [\"Short grass\", \"Tall grass\", \"Chaparral\", \"Timber litter\"]\nwind_speeds = 0.0:50.0:1000.0  # ft/min\n\np = plot(\n    xlabel = \"Midflame Wind Speed (ft/min)\",\n    ylabel = \"Rate of Spread (ft/min)\",\n    title = \"Wind Speed Effect on Fire Spread\",\n    legend = :topleft\n)\n\nfor (i, fuel_id) in enumerate(fuel_ids)\n    fm = get_fuel_model(fuel_table, fuel_id, 60)\n    rates = [Elmfire.surface_spread_rate(fm, 0.06, 0.08, 0.10, 0.60, 0.90, w, 0.0).velocity\n             for w in wind_speeds]\n    plot!(p, wind_speeds, rates, label=fuel_names[i], linewidth=2)\nend\np\n\n\n\n\n\n\nEffect of Fuel Moisture\n\n# Spread rate vs 1-hour fuel moisture\nfm = get_fuel_model(fuel_table, 1, 60)  # Short grass\nmoistures = 0.02:0.01:0.15  # 2% to 15%\nwind = 440.0\n\nrates = [Elmfire.surface_spread_rate(fm, m, m+0.02, m+0.04, 0.60, 0.90, wind, 0.0).velocity\n         for m in moistures]\n\nplot(moistures .* 100, rates,\n    xlabel = \"1-Hour Fuel Moisture (%)\",\n    ylabel = \"Rate of Spread (ft/min)\",\n    title = \"Fuel Moisture Effect on Fire Spread (Short Grass)\",\n    linewidth = 2,\n    legend = false\n)\n\n\n\n\n\n\nEffect of Slope\n\n# Spread rate vs slope angle\nfm = get_fuel_model(fuel_table, 1, 60)\nslopes_deg = 0.0:5.0:45.0\nslopes_tan2 = tan.(deg2rad.(slopes_deg)).^2\n\nrates_no_wind = [Elmfire.surface_spread_rate(fm, 0.06, 0.08, 0.10, 0.60, 0.90, 0.0, s).velocity\n                 for s in slopes_tan2]\nrates_with_wind = [Elmfire.surface_spread_rate(fm, 0.06, 0.08, 0.10, 0.60, 0.90, 440.0, s).velocity\n                   for s in slopes_tan2]\n\nplot(slopes_deg, [rates_no_wind rates_with_wind],\n    xlabel = \"Slope Angle (degrees)\",\n    ylabel = \"Rate of Spread (ft/min)\",\n    title = \"Slope Effect on Fire Spread\",\n    label = [\"No wind\" \"5 mph wind\"],\n    linewidth = 2\n)",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Rothermel Fire Spread Model</span>"
    ]
  },
  {
    "objectID": "reference/rothermel.html#elliptical-fire-spread",
    "href": "reference/rothermel.html#elliptical-fire-spread",
    "title": "Rothermel Fire Spread Model",
    "section": "Elliptical Fire Spread",
    "text": "Elliptical Fire Spread\nReal fires don’t spread uniformly in all directions. Under the influence of wind or slope, fires spread in an elliptical pattern (Anderson 1982).\n\nLength-to-Breadth Ratio\nThe ellipse shape is characterized by the length-to-breadth ratio:\n\\[\n\\frac{L}{B} = 0.936 e^{0.2566U} + 0.461 e^{-0.1548U} - 0.397\n\\]\nWhere \\(U\\) is the effective wind speed in mi/h.\n\n# Length-to-breadth ratio vs wind speed\nwind_mph = 0:0.5:20\nlb_ratios = [Elmfire.elliptical_spread(100.0, w).length_to_breadth for w in wind_mph]\n\nplot(wind_mph, lb_ratios,\n    xlabel = \"Effective Wind Speed (mi/h)\",\n    ylabel = \"Length-to-Breadth Ratio\",\n    title = \"Fire Shape vs Wind Speed\",\n    linewidth = 2,\n    legend = false,\n    ylims = (0, 10)\n)\n\n\n\n\n\n\nEllipticalSpread Type\nstruct EllipticalSpread{T&lt;:AbstractFloat}\n    head::T           # Head fire spread rate (ft/min)\n    back::T           # Backing fire spread rate (ft/min)\n    flank::T          # Flanking fire spread rate (ft/min)\n    eccentricity::T   # Ellipse eccentricity\n    length_to_breadth::T  # Length to breadth ratio\nend\n\n\nComputing Elliptical Spread\n\n# Head fire velocity from Rothermel\nhead_velocity = 50.0  # ft/min\nwind_mph = 10.0\n\nes = Elmfire.elliptical_spread(head_velocity, wind_mph)\n\nprintln(\"Elliptical Fire Spread:\")\nprintln(\"  Head fire rate: $(round(es.head, digits=1)) ft/min\")\nprintln(\"  Backing fire rate: $(round(es.back, digits=1)) ft/min\")\nprintln(\"  Flanking fire rate: $(round(es.flank, digits=1)) ft/min\")\nprintln(\"  Eccentricity: $(round(es.eccentricity, digits=3))\")\nprintln(\"  Length/Breadth ratio: $(round(es.length_to_breadth, digits=2))\")\n\nElliptical Fire Spread:\n  Head fire rate: 50.0 ft/min\n  Backing fire rate: 0.4 ft/min\n  Flanking fire rate: 4.4 ft/min\n  Eccentricity: 0.984\n  Length/Breadth ratio: 8.0\n\n\n\n\nVisualizing Elliptical Spread\n\n# Plot fire ellipse shape for different wind speeds\nwind_speeds = [0.0, 5.0, 10.0, 15.0]\np = plot(aspect_ratio=:equal, xlabel=\"Distance (ft)\", ylabel=\"Distance (ft)\",\n         title=\"Fire Spread Ellipses (1 hour)\", legend=:topright)\n\nfor wind in wind_speeds\n    es = Elmfire.elliptical_spread(50.0, wind)\n\n    # Generate ellipse points (60 minutes of spread)\n    t = 60.0  # minutes\n    theta = range(0, 2π, length=100)\n\n    # Semi-axes from spread rates\n    a = (es.head + es.back) / 2 * t  # semi-major axis\n    c = (es.head - es.back) / 2 * t  # focus distance from center\n\n    if es.eccentricity &gt; 0.001\n        b = a * sqrt(1 - es.eccentricity^2)  # semi-minor axis\n    else\n        b = a\n    end\n\n    # Ellipse centered at origin with focus at (c, 0)\n    x = a .* cos.(theta)\n    y = b .* sin.(theta)\n\n    # Shift so ignition point (focus) is at origin\n    x = x .- c\n\n    plot!(p, x, y, label=\"$(Int(wind)) mph\", linewidth=2)\nend\np",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Rothermel Fire Spread Model</span>"
    ]
  },
  {
    "objectID": "reference/rothermel.html#derivation-of-constants",
    "href": "reference/rothermel.html#derivation-of-constants",
    "title": "Rothermel Fire Spread Model",
    "section": "Derivation of Constants",
    "text": "Derivation of Constants\nThe Rothermel model constants were derived through a combination of theoretical analysis, laboratory experiments, and field observations. This section documents the origin of each constant.\n\nPhysical Constants\nThese constants describe fundamental properties of wildland fuels (Rothermel 1972, Table II; Albini 1976):\n\n\n\n\n\n\n\n\n\n\nConstant\nValue\nUnits\nDescription\nSource\n\n\n\n\n\\(\\rho_p\\)\n32\nlb/ft³\nParticle density (ovendry wood)\nRothermel (1972)\n\n\n\\(S_T\\)\n0.055\nlb/lb (mass fraction)\nTotal mineral content (mass fraction)\nRothermel (1972)\n\n\n\\(S_e\\)\n0.01\nlb/lb (mass fraction)\nEffective (silica-free) mineral content\nRothermel (1972)\n\n\n\\(h\\)\n8000\nBTU/lb\nLow heat of combustion (typical)\nRothermel (1972)\n\n\n\nThe particle density of 32 lb/ft³ is representative of ovendry wood and was measured by Byram et al. (1952). The mineral content values are averages for forest fuels from laboratory analysis.\n\n\nFixed Surface-Area-to-Volume Ratios\n\n\n\nFuel Class\nSAV (1/ft)\nSource\n\n\n\n\n10-hour dead\n109\nRothermel (1972), Table I\n\n\n100-hour dead\n30\nRothermel (1972), Table I\n\n\n\nThese values are fixed because the timelag fuel classes (10-hr, 100-hr) are defined by particle diameter, which directly determines SAV for cylindrical fuel elements.\n\n\nEmpirically-Derived Coefficients\nThe following coefficients were derived by fitting experimental data from laboratory fire spread tests (Rothermel 1972, pp. 16-26):\n\nWind Coefficients (A, B, C, E)\n\n\n\n\n\n\n\n\nCoefficient\nFormula\nDerivation\n\n\n\n\n\\(A\\)\n\\(133.0 / \\sigma^{0.7913}\\)\nReaction velocity exponent (Eq. 38)\n\n\n\\(B\\)\n\\(0.02526 \\times \\sigma^{0.54}\\)\nWind velocity exponent (Eq. 49)\n\n\n\\(C\\)\n\\(7.47 \\times e^{-0.133 \\times \\sigma^{0.55}}\\)\nWind coefficient (Eq. 48)\n\n\n\\(E\\)\n\\(0.715 \\times e^{-0.000359 \\times \\sigma}\\)\nWind/packing exponent (Eq. 50)\n\n\n\nThese were determined by regression analysis of 31 laboratory fires in ponderosa pine needle fuel beds with SAV ratios from 1,140 to 2,000 ft⁻¹ and wind speeds from 0 to 9 mi/h (Rothermel 1972, Table IV).\n\n\nOptimal Packing Ratio\n\\[\n\\beta_{op} = 3.348 \\times \\sigma^{-0.8189} \\quad \\text{(dimensionless)}\n\\]\nWhere \\(\\sigma\\) is the characteristic surface-area-to-volume ratio (ft⁻¹). The coefficient 3.348 has units of ft⁻⁰·⁸¹⁸⁹.\nDerived from the relationship between packing ratio and reaction velocity that maximizes heat release (Rothermel 1972, Eq. 37). The optimal packing provides the best balance between fuel availability and oxygen access.\n\n\nPropagating Flux Ratio\n\\[\n\\xi = \\frac{\\exp[(0.792 + 0.681\\sqrt{\\sigma})(0.1 + \\beta)]}{192 + 0.2595\\sigma}\n\\]\nThis ratio represents the fraction of reaction intensity that heats adjacent fuel particles. Derived from no-wind fire spread experiments (Rothermel 1972, Eq. 42).\n\n\nReaction Velocity\n\\[\n\\Gamma' = \\Gamma'_{max} \\left(\\frac{\\beta}{\\beta_{op}}\\right)^A \\exp\\left[A\\left(1 - \\frac{\\beta}{\\beta_{op}}\\right)\\right]\n\\]\nwhere:\n\\[\n\\Gamma'_{max} = \\frac{\\sigma^{1.5}}{495 + 0.0594\\sigma^{1.5}}\n\\]\nThe maximum reaction velocity equation (Rothermel 1972, Eq. 36) was fitted to data from Fons (1946) and Anderson (1969) for cribs and fuel beds.\n\n\nResidence Time\n\\[\n\\tau_r = \\frac{384}{\\sigma} \\quad \\text{(min)}\n\\]\nWhere \\(\\sigma\\) is in ft⁻¹ and the coefficient 384 has units of ft⁻¹·min.\nThe residence time represents how long the flaming front persists at a given point. The coefficient 384 was derived from laboratory observations of flame duration vs. fuel particle size (Rothermel 1972, Eq. 77; Anderson 1969).\n\n\n\nDamping Coefficients\n\nMoisture Damping\n\\[\n\\eta_M = 1 - 2.59r + 5.11r^2 - 3.52r^3 \\quad \\text{(dimensionless)}\n\\]\nwhere \\(r = M/M_{ex}\\) is the ratio of fuel moisture content \\(M\\) (lb water/lb dry fuel) to moisture of extinction \\(M_{ex}\\) (lb water/lb dry fuel). Both are typically expressed as fractions (e.g., 0.06 = 6% moisture).\nThis polynomial was fitted to laboratory data showing the reduction in reaction intensity as fuel moisture increases (Rothermel 1972, Eq. 29). The curve passes through (0, 1) at zero moisture and (1, 0) at extinction moisture.\n\n\nMineral Damping\n\\[\n\\eta_s = 0.174 \\times S_e^{-0.19} \\quad \\text{(dimensionless)}\n\\]\nwhere \\(S_e\\) is the effective (silica-free) mineral content (lb mineral/lb fuel).\nAccounts for the heat-absorbing effect of fuel minerals. Derived from laboratory combustion experiments (Rothermel 1972, Eq. 30). With the standard effective mineral content of 0.01, this gives \\(\\eta_s \\approx 0.42\\).\n\n\n\nHeat Transfer Constants\n\nHeat of Pre-ignition\n\\[\nQ_{ig} = 250 + 1116M \\quad \\text{(BTU/lb)}\n\\]\nWhere \\(M\\) is fuel moisture content (lb water/lb dry fuel, e.g., 0.06 for 6%).\nThe heat required to raise fuel to ignition temperature. The constant 250 BTU/lb represents the sensible heat to raise dry fuel to ignition (~600°F), while the coefficient 1116 BTU/lb accounts for the latent heat of vaporizing fuel moisture (Rothermel 1972, Eq. 12).\n\n\nEffective Heating Number\n\\[\n\\varepsilon = \\exp\\left(\\frac{-138}{\\sigma}\\right) \\quad \\text{(dimensionless)}\n\\]\nWhere \\(\\sigma\\) is surface-area-to-volume ratio (ft⁻¹) and the coefficient 138 has units of ft⁻¹.\nThe fraction of a fuel particle that is heated to ignition temperature before the flame front passes. Smaller particles (higher SAV) heat more completely (Rothermel 1972, Eq. 14). The coefficient 138 ft⁻¹ was calibrated from experimental data.\n\n\n\nSlope Factor\n\\[\n\\phi_s = 5.275 \\times \\beta^{-0.3} \\times \\tan^2\\theta \\quad \\text{(dimensionless)}\n\\]\nWhere \\(\\beta\\) is packing ratio (dimensionless) and \\(\\tan^2\\theta\\) is passed directly to the function (dimensionless).\nThe slope factor accounts for radiant heat transfer to upslope fuels. The coefficients 5.275 and -0.3 are dimensionless and were derived from laboratory experiments on inclined fuel beds (Rothermel 1972, Eq. 52). The dependence on \\(\\tan^2\\theta\\) reflects the geometric increase in view factor with slope angle.\n\n\nElliptical Spread (Anderson 1982)\nThe length-to-breadth ratio equation:\n\\[\n\\frac{L}{B} = 0.936 e^{0.2566U} + 0.461 e^{-0.1548U} - 0.397\n\\]\nwas derived by Anderson (1982) from aerial observations of 28 wildfires in Australia and the United States. The data showed that fire shape depends primarily on effective wind speed \\(U\\) (mi/h), with fires becoming more elongated at higher wind speeds.\n\n\nViewing Computed Coefficients\n\nfm = get_fuel_model(fuel_table, 1, 60)\n\nprintln(\"Rothermel Coefficients (Fuel Model 1 - Short Grass):\")\nprintln(\"  A = $(round(fm.A, digits=4))\")\nprintln(\"  B = $(round(fm.B, digits=4))\")\nprintln(\"  C = $(round(fm.C, digits=4))\")\nprintln(\"  E = $(round(fm.E, digits=6))\")\nprintln(\"\")\nprintln(\"Derived Properties:\")\nprintln(\"  Overall SAV (σ): $(round(fm.SIG_overall, digits=0)) 1/ft\")\nprintln(\"  Bulk density (ρb): $(round(fm.rhob, digits=4)) lb/ft³\")\nprintln(\"  Packing ratio (β): $(round(fm.beta, digits=5))\")\nprintln(\"  Optimal packing (βop): $(round(fm.betaop, digits=5))\")\nprintln(\"  Reaction velocity (Γ'): $(round(fm.gammaprime, digits=3)) 1/min\")\nprintln(\"  Propagating flux (ξ): $(round(fm.xi, digits=4))\")\nprintln(\"  Residence time (τr): $(round(fm.tr, digits=3)) min\")\nprintln(\"  Mineral damping (ηs): $(round(fm.etas, digits=4))\")\n\nRothermel Coefficients (Fuel Model 1 - Short Grass):\n  A = 0.2087\n  B = 2.0712\n  C = 0.0001\n  E = 0.203524\n\nDerived Properties:\n  Overall SAV (σ): 3500.0 1/ft\n  Bulk density (ρb): 0.034 lb/ft³\n  Packing ratio (β): 0.00106\n  Optimal packing (βop): 0.00419\n  Reaction velocity (Γ'): 14.201 1/min\n  Propagating flux (ξ): 0.0578\n  Residence time (τr): 0.11 min\n  Mineral damping (ηs): 0.4174",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Rothermel Fire Spread Model</span>"
    ]
  },
  {
    "objectID": "reference/rothermel.html#references",
    "href": "reference/rothermel.html#references",
    "title": "Rothermel Fire Spread Model",
    "section": "References",
    "text": "References\n\nPrimary Sources\n\nRothermel, R.C. (1972). A mathematical model for predicting fire spread in wildland fuels. USDA Forest Service Research Paper INT-115. Ogden, UT. 40 p.\n\nThe foundational paper defining the spread rate equation and deriving all major coefficients.\n\nAnderson, H.E. (1982). Aids to determining fuel models for estimating fire behavior. USDA Forest Service General Technical Report INT-122. Ogden, UT. 22 p.\n\nDefines the 13 standard fuel models and elliptical fire spread equations.\n\nAlbini, F.A. (1976). Estimating wildfire behavior and effects. USDA Forest Service General Technical Report INT-30. Ogden, UT. 92 p.\n\nProvides physical constants and fuel property values used in fire modeling.\n\n\n\n\nHistorical Sources (cited by Rothermel)\n\nByram, G.M., Sauer, F.M., Fons, W.L., & Arnold, R.K. (1952). Thermal properties of forest fuels. USDA Forest Service, Division of Fire Research. Berkeley, CA.\n\nSource of particle density (32 lb/ft³) measurements.\n\nFons, W.L. (1946). Analysis of fire spread in light forest fuels. Journal of Agricultural Research 72(3): 93-121.\n\nEarly fire spread experiments used to calibrate reaction velocity.\n\nAnderson, H.E. (1969). Heat transfer and fire spread. USDA Forest Service Research Paper INT-69. Ogden, UT. 20 p.\n\nLaboratory data on heat transfer and residence time.\n\n\n\n\nModern Interpretations\n\nAndrews, P.L. (2018). The Rothermel surface fire spread model and associated developments: A comprehensive explanation. USDA Forest Service General Technical Report RMRS-GTR-371. Fort Collins, CO. 121 p.\n\nComprehensive modern explanation of the Rothermel model with derivations and examples.\n\nScott, J.H. & Burgan, R.E. (2005). Standard fire behavior fuel models: A comprehensive set for use with Rothermel’s surface fire spread model. USDA Forest Service General Technical Report RMRS-GTR-153. Fort Collins, CO. 72 p.\n\nExpanded set of 40 fuel models (Scott/Burgan models) for diverse fuel types.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Rothermel Fire Spread Model</span>"
    ]
  },
  {
    "objectID": "reference/rothermel.html#see-also",
    "href": "reference/rothermel.html#see-also",
    "title": "Rothermel Fire Spread Model",
    "section": "See Also",
    "text": "See Also\n\nFuel Models - Detailed fuel model documentation\nSimulation - Running fire simulations\nWeather - Weather inputs to the model",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Rothermel Fire Spread Model</span>"
    ]
  },
  {
    "objectID": "reference/fuel-models.html",
    "href": "reference/fuel-models.html",
    "title": "Fuel Models",
    "section": "",
    "text": "Types\nFuel models describe the physical characteristics of wildland fuels and are essential inputs to the Rothermel fire spread model.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Fuel Models</span>"
    ]
  },
  {
    "objectID": "reference/fuel-models.html#types",
    "href": "reference/fuel-models.html#types",
    "title": "Fuel Models",
    "section": "",
    "text": "RawFuelModel\nRaw fuel model parameters as read from CSV files before coefficient calculation.\nstruct RawFuelModel{T&lt;:AbstractFloat}\n    id::Int              # Fuel model ID\n    name::String         # Descriptive name\n    dynamic::Bool        # Whether herbaceous fuel transfers based on moisture\n\n    # Fuel loadings (lb/ft²)\n    W0_1hr::T            # 1-hour dead fuel\n    W0_10hr::T           # 10-hour dead fuel\n    W0_100hr::T          # 100-hour dead fuel\n    W0_herb::T           # Live herbaceous\n    W0_woody::T          # Live woody\n\n    # Surface area to volume ratios (1/ft)\n    SIG_1hr::T           # 1-hour SAV\n    SIG_live_herb::T     # Live herbaceous SAV\n    SIG_live_woody::T    # Live woody SAV\n\n    # Fuel bed properties\n    delta::T             # Fuel bed thickness (ft)\n    mex_dead::T          # Dead fuel moisture of extinction (fraction)\n    hoc::T               # Heat of combustion (Btu/lb)\nend\n\n\nFuelModel\nComplete fuel model with all computed Rothermel coefficients. Created from RawFuelModel via compute_fuel_model().\nFields (selected):\n\n\n\nField\nType\nDescription\n\n\n\n\nid\nInt\nFuel model identifier\n\n\nname\nString\nDescriptive name\n\n\ndynamic\nBool\nDynamic fuel transfer flag\n\n\nW0\nNTuple{6,T}\nFuel loadings for 6 size classes\n\n\nSIG\nNTuple{6,T}\nSAV ratios for 6 size classes\n\n\ndelta\nT\nFuel bed depth (ft)\n\n\nmex_dead\nT\nDead fuel moisture of extinction\n\n\nrhob\nT\nBulk density (lb/ft³)\n\n\nbeta\nT\nPacking ratio\n\n\nbetaop\nT\nOptimal packing ratio\n\n\ngammaprime\nT\nReaction velocity (1/min)\n\n\ntr\nT\nResidence time (min)\n\n\n\nThe 6 size classes are:\n\n1-hour dead\n10-hour dead\n100-hour dead\nDynamic dead (transferred herbaceous)\nLive herbaceous\nLive woody\n\n\n\nFuelModelTable\nCollection of fuel models indexed by (fuel_id, live_moisture_class).\nstruct FuelModelTable{T&lt;:AbstractFloat}\n    models::Dict{Tuple{Int,Int}, FuelModel{T}}\n    raw_models::Dict{Int, RawFuelModel{T}}\nend",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Fuel Models</span>"
    ]
  },
  {
    "objectID": "reference/fuel-models.html#functions",
    "href": "reference/fuel-models.html#functions",
    "title": "Fuel Models",
    "section": "Functions",
    "text": "Functions\n\ncreate_standard_fuel_table\ncreate_standard_fuel_table(::Type{T}) -&gt; FuelModelTable{T}\nCreate a fuel model table with the standard 13 Anderson (1982) fuel models.\n\nfuel_table = create_standard_fuel_table(Float64)\nprintln(\"Loaded $(length(fuel_table.raw_models)) fuel models\")\n\nLoaded 14 fuel models\n\n\n\n\ncompute_fuel_model\ncompute_fuel_model(raw::RawFuelModel{T}, live_moisture_class::Int=30) -&gt; FuelModel{T}\nCompute all Rothermel coefficients from raw fuel model data.\nFor dynamic fuel models, live herbaceous fuel is partitioned between dead and live classes based on the live moisture class (30-120, representing 30% to 120% moisture content).\n\n# Get raw fuel model 1 (short grass)\nraw = fuel_table.raw_models[1]\n\n# Compute fuel model at different moisture levels\nfm_dry = compute_fuel_model(raw, 30)   # Very dry\nfm_wet = compute_fuel_model(raw, 120)  # Green\n\nprintln(\"Fuel model: $(fm_dry.name)\")\nprintln(\"Dynamic: $(fm_dry.dynamic)\")\nprintln(\"Reaction velocity: $(round(fm_dry.gammaprime, digits=2)) 1/min\")\n\nFuel model: FBFM01\nDynamic: false\nReaction velocity: 14.2 1/min\n\n\n\n\nadd_raw_model!\nadd_raw_model!(table::FuelModelTable{T}, raw::RawFuelModel) -&gt; FuelModelTable\nAdd a raw fuel model to the table and compute coefficients for all live moisture classes (30-120).\n\n# Create custom fuel model\ncustom = RawFuelModel(\n    100,                    # id\n    \"Custom tall grass\",    # name\n    true,                   # dynamic\n    0.20, 0.0, 0.0,        # 1hr, 10hr, 100hr loading\n    0.30, 0.0,             # herb, woody loading\n    2000.0, 1500.0, 1500.0, # SAV ratios\n    3.0,                    # depth (ft)\n    0.15,                   # moisture of extinction\n    8000.0                  # heat of combustion\n)\n\nadd_raw_model!(fuel_table, custom)\nprintln(\"Added fuel model $(custom.id): $(custom.name)\")\n\nAdded fuel model 100: Custom tall grass\n\n\n\n\nget_fuel_model\nget_fuel_model(table::FuelModelTable, fuel_id::Int, live_moisture) -&gt; FuelModel\nGet the fuel model for the given fuel ID and live moisture content. Live moisture can be specified as a fraction (0.3 to 1.2) or as an integer class (30 to 120).\n\n# By moisture fraction\nfm = get_fuel_model(fuel_table, 1, 0.6)  # 60% live moisture\nprintln(\"Fuel: $(fm.name), SAV: $(round(fm.SIG_overall, digits=0)) 1/ft\")\n\n# By moisture class\nfm2 = get_fuel_model(fuel_table, 1, 60)\nprintln(\"Same model: $(fm.SIG_overall == fm2.SIG_overall)\")\n\nFuel: FBFM01, SAV: 3500.0 1/ft\nSame model: true\n\n\n\n\nisnonburnable\nisnonburnable(fm::FuelModel) -&gt; Bool\nCheck if a fuel model is non-burnable (ID 256 or zero fuel loading).\n\nfm1 = get_fuel_model(fuel_table, 1, 60)\nprintln(\"Fuel 1 burnable: $(! isnonburnable(fm1))\")\n\nFuel 1 burnable: true",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Fuel Models</span>"
    ]
  },
  {
    "objectID": "reference/fuel-models.html#standard-fuel-models",
    "href": "reference/fuel-models.html#standard-fuel-models",
    "title": "Fuel Models",
    "section": "Standard Fuel Models",
    "text": "Standard Fuel Models\nThe 13 standard Anderson (1982) fuel models:\n\n\n\nID\nName\nFuel Type\nSpread Rate\n\n\n\n\n1\nShort grass\nGrass\nFast\n\n\n2\nTimber grass/understory\nGrass\nFast\n\n\n3\nTall grass\nGrass\nVery fast\n\n\n4\nChaparral\nBrush\nFast\n\n\n5\nBrush\nBrush\nModerate\n\n\n6\nDormant brush\nBrush\nModerate\n\n\n7\nSouthern rough\nBrush\nSlow\n\n\n8\nCompact timber litter\nTimber\nSlow\n\n\n9\nHardwood litter\nTimber\nModerate\n\n\n10\nTimber understory\nTimber\nModerate\n\n\n11\nLight slash\nSlash\nModerate\n\n\n12\nMedium slash\nSlash\nFast\n\n\n13\nHeavy slash\nSlash\nFast\n\n\n\n\nusing Plots\n\n# Compare spread rates across fuel models\nfuel_table = create_standard_fuel_table(Float64)\nfm_ids = 1:13\nrates = Float64[]\n\nfor id in fm_ids\n    fm = get_fuel_model(fuel_table, id, 60)\n    # Approximate no-wind, no-slope rate of spread\n    push!(rates, fm.gammaprime * fm.xi * 10)  # Scaled for visualization\nend\n\nbar(fm_ids, rates,\n    xlabel = \"Fuel Model ID\",\n    ylabel = \"Relative Spread Rate\",\n    title = \"Comparison of 13 Standard Fuel Models\",\n    legend = false,\n    xticks = 1:13\n)",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Fuel Models</span>"
    ]
  },
  {
    "objectID": "reference/fuel-models.html#dynamic-fuel-models",
    "href": "reference/fuel-models.html#dynamic-fuel-models",
    "title": "Fuel Models",
    "section": "Dynamic Fuel Models",
    "text": "Dynamic Fuel Models\nDynamic fuel models transfer live herbaceous fuel to the dead fuel category as live moisture content decreases. This simulates curing of grasses.\n\n# Fuel model 1 is dynamic (short grass)\nraw = fuel_table.raw_models[1]\n\nmoistures = 30:10:120\ndead_loadings = Float64[]\nlive_loadings = Float64[]\n\nfor m in moistures\n    fm = compute_fuel_model(raw, m)\n    push!(dead_loadings, sum(fm.W0[1:4]))  # Dead classes\n    push!(live_loadings, sum(fm.W0[5:6]))  # Live classes\nend\n\nplot(moistures, [dead_loadings live_loadings],\n    xlabel = \"Live Moisture Class (%)\",\n    ylabel = \"Fuel Loading (lb/ft²)\",\n    title = \"Dynamic Fuel Transfer in Model 1\",\n    label = [\"Dead\" \"Live\"],\n    linewidth = 2\n)",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Fuel Models</span>"
    ]
  },
  {
    "objectID": "reference/fuel-models.html#rothermel-coefficients",
    "href": "reference/fuel-models.html#rothermel-coefficients",
    "title": "Fuel Models",
    "section": "Rothermel Coefficients",
    "text": "Rothermel Coefficients\nThe FuelModel type pre-computes many Rothermel model coefficients for efficiency:\n\nfm = get_fuel_model(fuel_table, 1, 60)\n\nprintln(\"Rothermel Coefficients for $(fm.name):\")\nprintln(\"  A coefficient: $(round(fm.A, digits=4))\")\nprintln(\"  B coefficient: $(round(fm.B, digits=4))\")\nprintln(\"  C coefficient: $(round(fm.C, digits=4))\")\nprintln(\"  E coefficient: $(round(fm.E, digits=4))\")\nprintln(\"  Reaction velocity (Γ'): $(round(fm.gammaprime, digits=3)) 1/min\")\nprintln(\"  Propagating flux ratio (ξ): $(round(fm.xi, digits=4))\")\nprintln(\"  Residence time (τr): $(round(fm.tr, digits=2)) min\")\nprintln(\"  Packing ratio (β): $(round(fm.beta, digits=5))\")\nprintln(\"  Optimal packing ratio (βop): $(round(fm.betaop, digits=5))\")\n\nRothermel Coefficients for FBFM01:\n  A coefficient: 0.2087\n  B coefficient: 2.0712\n  C coefficient: 0.0001\n  E coefficient: 0.2035\n  Reaction velocity (Γ'): 14.201 1/min\n  Propagating flux ratio (ξ): 0.0578\n  Residence time (τr): 0.11 min\n  Packing ratio (β): 0.00106\n  Optimal packing ratio (βop): 0.00419",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Fuel Models</span>"
    ]
  },
  {
    "objectID": "reference/simulation.html",
    "href": "reference/simulation.html",
    "title": "Simulation",
    "section": "",
    "text": "Types\nThis module provides the core fire simulation state and execution functions.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Simulation</span>"
    ]
  },
  {
    "objectID": "reference/simulation.html#types",
    "href": "reference/simulation.html#types",
    "title": "Simulation",
    "section": "",
    "text": "FireState\nComplete state of a fire simulation, including the level set field, burned area, and fire behavior outputs.\nmutable struct FireState{T&lt;:AbstractFloat}\n    # Level set field (with 2-cell padding for stencil operations)\n    phi::Matrix{T}\n    phi_old::Matrix{T}\n\n    # Output fields (no padding, matches grid dimensions)\n    time_of_arrival::Matrix{T}    # -1 if not burned\n    burned::BitMatrix             # True if cell has burned\n    spread_rate::Matrix{T}        # Final spread rate (ft/min)\n    fireline_intensity::Matrix{T} # Fireline intensity (kW/m)\n    flame_length::Matrix{T}       # Flame length (ft)\n\n    # Velocity components (with padding)\n    ux::Matrix{T}\n    uy::Matrix{T}\n\n    # Narrow band tracking\n    narrow_band::NarrowBand\n\n    # Grid parameters\n    ncols::Int           # Number of columns (without padding)\n    nrows::Int           # Number of rows (without padding)\n    cellsize::T          # Cell size (ft)\n    xllcorner::T         # X coordinate of lower-left corner\n    yllcorner::T         # Y coordinate of lower-left corner\n    padding::Int         # Padding for stencil operations\nend\nConstructor:\nFireState{T}(ncols, nrows, cellsize;\n    xllcorner = zero(T),\n    yllcorner = zero(T),\n    padding = 2,\n    band_thickness = 5\n) -&gt; FireState{T}\n\n# Create a 100x100 grid with 30ft cells\nstate = FireState{Float64}(100, 100, 30.0)\n\nprintln(\"Grid size: $(state.ncols) x $(state.nrows)\")\nprintln(\"Cell size: $(state.cellsize) ft\")\nprintln(\"Domain: $(state.ncols * state.cellsize) x $(state.nrows * state.cellsize) ft\")\n\nGrid size: 100 x 100\nCell size: 30.0 ft\nDomain: 3000.0 x 3000.0 ft\n\n\n\n\nSimulationConfig\nConfiguration for full simulation with crown fire, spotting, and weather interpolation.\nstruct SimulationConfig{T&lt;:AbstractFloat}\n    enable_crown_fire::Bool        # Enable crown fire modeling\n    enable_spotting::Bool          # Enable ember transport\n    crown_fire_adj::T              # Crown fire adjustment factor\n    critical_canopy_cover::T       # Minimum CC for active crown fire\n    foliar_moisture::T             # Foliar moisture content (%)\n    spotting_params::Union{Nothing, SpottingParameters{T}}\n    use_sardoy::Bool               # Use Sardoy model for spotting\nend\nConstructor:\nSimulationConfig{T}(;\n    enable_crown_fire = false,\n    enable_spotting = false,\n    crown_fire_adj = 1.0,\n    critical_canopy_cover = 0.4,\n    foliar_moisture = 100.0,\n    spotting_params = nothing,\n    use_sardoy = false\n) -&gt; SimulationConfig{T}\n\n# Basic configuration (surface fire only)\nconfig_basic = SimulationConfig{Float64}()\n\n# Crown fire enabled\nconfig_crown = SimulationConfig{Float64}(\n    enable_crown_fire = true,\n    foliar_moisture = 100.0\n)\n\n# Full configuration with spotting\nspotting = SpottingParameters{Float64}(\n    mean_distance = 100.0,\n    normalized_variance = 0.5,\n    ws_exponent = 1.0,\n    flin_exponent = 0.5,\n    nembers_max = 10,\n    surface_spotting_percent = 1.0,\n    crown_spotting_percent = 10.0,\n    pign = 50.0,\n    min_distance = 10.0,\n    max_distance = 2000.0\n)\n\nconfig_full = SimulationConfig{Float64}(\n    enable_crown_fire = true,\n    enable_spotting = true,\n    spotting_params = spotting\n)\n\nSimulationConfig{Float64}(true, true, 1.0, 0.4, 100.0, SpottingParameters{Float64}(100.0, 0.5, 1.0, 0.5, 10, 1.0, 10.0, 50.0, 10.0, 2000.0), false)\n\n\n\n\nCanopyGrid\nGrid of canopy properties for crown fire modeling.\nstruct CanopyGrid{T&lt;:AbstractFloat}\n    cbd::Matrix{T}      # Canopy bulk density (kg/m³)\n    cbh::Matrix{T}      # Canopy base height (m)\n    cc::Matrix{T}       # Canopy cover (fraction 0-1)\n    ch::Matrix{T}       # Canopy height (m)\nend\n\n# Create uniform canopy\ncanopy = CanopyGrid{Float64}(\n    fill(0.15, 100, 100),  # CBD\n    fill(2.0, 100, 100),   # CBH\n    fill(0.6, 100, 100),   # CC\n    fill(20.0, 100, 100)   # CH\n)\n\nprintln(\"Canopy bulk density: $(canopy.cbd[1,1]) kg/m³\")\nprintln(\"Canopy base height: $(canopy.cbh[1,1]) m\")\nprintln(\"Canopy cover: $(canopy.cc[1,1] * 100)%\")\nprintln(\"Canopy height: $(canopy.ch[1,1]) m\")\n\nCanopy bulk density: 0.15 kg/m³\nCanopy base height: 2.0 m\nCanopy cover: 60.0%\nCanopy height: 20.0 m",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Simulation</span>"
    ]
  },
  {
    "objectID": "reference/simulation.html#simulation-functions",
    "href": "reference/simulation.html#simulation-functions",
    "title": "Simulation",
    "section": "Simulation Functions",
    "text": "Simulation Functions\n\nsimulate!\nRun fire simulation with spatially-varying conditions.\nsimulate!(\n    state::FireState{T},\n    fuel_ids::AbstractMatrix{Int},\n    fuel_table::FuelModelTable{T},\n    weather::ConstantWeather{T},\n    slope::AbstractMatrix{T},\n    aspect::AbstractMatrix{T},\n    t_start::T,\n    t_stop::T;\n    dt_initial = 1.0,\n    target_cfl = 0.9,\n    dt_max = 10.0,\n    callback = nothing\n)\n\n\n\nArgument\nDescription\n\n\n\n\nstate\nFire state (modified in place)\n\n\nfuel_ids\nMatrix of fuel model IDs\n\n\nfuel_table\nFuel model lookup table\n\n\nweather\nConstant weather conditions\n\n\nslope\nSlope in degrees for each cell\n\n\naspect\nAspect direction in degrees\n\n\nt_start\nStart time (minutes)\n\n\nt_stop\nStop time (minutes)\n\n\n\n\nfuel_table = create_standard_fuel_table(Float64)\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 10.0,\n    wind_direction = 270.0,\n    M1 = 0.06, M10 = 0.08, M100 = 0.10,\n    MLH = 0.60, MLW = 0.90\n)\n\nstate = FireState{Float64}(100, 100, 30.0)\nfuel_ids = fill(1, 100, 100)\nslope = zeros(Float64, 100, 100)\naspect = zeros(Float64, 100, 100)\n\nignite!(state, 50, 50, 0.0)\nsimulate!(state, fuel_ids, fuel_table, weather, slope, aspect, 0.0, 30.0)\n\nprintln(\"Burned area: $(round(get_burned_area_acres(state), digits=2)) acres\")\n\nheatmap(state.burned', title = \"Burned Area\", color = :YlOrRd, aspect_ratio = 1)\n\nBurned area: 27.89 acres\n\n\n\n\n\n\n\nsimulate_uniform!\nRun simulation with uniform fuel, slope, and aspect across the entire domain.\nsimulate_uniform!(\n    state::FireState{T},\n    fuel_id::Int,\n    fuel_table::FuelModelTable{T},\n    weather::ConstantWeather{T},\n    slope_deg::T,\n    aspect_deg::T,\n    t_start::T,\n    t_stop::T;\n    kwargs...\n)\n\nstate = FireState{Float64}(100, 100, 30.0)\nignite!(state, 50, 50, 0.0)\n\n# Uniform fuel model 1 (short grass), 10° slope facing east\nsimulate_uniform!(state, 1, fuel_table, weather, 10.0, 90.0, 0.0, 30.0)\n\nprintln(\"Burned area: $(round(get_burned_area_acres(state), digits=2)) acres\")\n\nBurned area: 29.5 acres\n\n\n\n\nsimulate_full!\nRun full simulation with crown fire, spotting, and weather interpolation support.\nsimulate_full!(\n    state::FireState{T},\n    fuel_ids::AbstractMatrix{Int},\n    fuel_table::FuelModelTable{T},\n    weather_interp::WeatherInterpolator{T},\n    slope::AbstractMatrix{T},\n    aspect::AbstractMatrix{T},\n    t_start::T,\n    t_stop::T;\n    canopy = nothing,\n    config = SimulationConfig{T}(),\n    dt_initial = 1.0,\n    target_cfl = 0.9,\n    dt_max = 10.0,\n    callback = nothing,\n    rng = Random.default_rng()\n) -&gt; SpotFireTracker\n\nusing Random\n\nstate = FireState{Float64}(100, 100, 30.0)\nfuel_ids = fill(10, 100, 100)  # Timber understory\nslope = zeros(Float64, 100, 100)\naspect = zeros(Float64, 100, 100)\n\n# Create canopy\ncanopy = CanopyGrid{Float64}(\n    fill(0.15, 100, 100),\n    fill(2.0, 100, 100),\n    fill(0.6, 100, 100),\n    fill(20.0, 100, 100)\n)\n\n# Configuration with crown fire\nconfig = SimulationConfig{Float64}(\n    enable_crown_fire = true,\n    foliar_moisture = 100.0\n)\n\nweather_interp = create_constant_interpolator(weather, 100, 100, 30.0)\n\nignite!(state, 50, 50, 0.0)\nsimulate_full!(state, fuel_ids, fuel_table, weather_interp, slope, aspect,\n    0.0, 30.0; canopy = canopy, config = config)\n\nprintln(\"Burned area: $(round(get_burned_area_acres(state), digits=2)) acres\")\nprintln(\"Max fireline intensity: $(round(maximum(state.fireline_intensity), digits=0)) kW/m\")\n\nBurned area: 87.17 acres\nMax fireline intensity: 21165.0 kW/m",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Simulation</span>"
    ]
  },
  {
    "objectID": "reference/simulation.html#ignition-functions",
    "href": "reference/simulation.html#ignition-functions",
    "title": "Simulation",
    "section": "Ignition Functions",
    "text": "Ignition Functions\n\nignite!\nIgnite a cell at grid coordinates.\nignite!(state::FireState{T}, ix::Int, iy::Int, t::T)\nSets up the level set as a signed distance function near the ignition point.\n\nstate = FireState{Float64}(50, 50, 30.0)\nignite!(state, 25, 25, 0.0)\n\nprintln(\"Cell (25,25) burned: $(state.burned[25, 25])\")\nprintln(\"Time of arrival: $(state.time_of_arrival[25, 25]) min\")\n\nCell (25,25) burned: true\nTime of arrival: 0.0 min\n\n\n\n\nignite_point!\nIgnite a cell at world coordinates.\nignite_point!(state::FireState{T}, x::T, y::T, t::T)\nConverts world coordinates to grid indices and ignites the corresponding cell.\n\n\nignite_circle!\nIgnite all cells within a circular area.\nignite_circle!(state::FireState{T}, center_x::Int, center_y::Int, radius_cells::T, t::T)\n\nstate = FireState{Float64}(50, 50, 30.0)\nignite_circle!(state, 25, 25, 3.0, 0.0)  # 3-cell radius\n\nprintln(\"Burned cells: $(count(state.burned))\")\n\nBurned cells: 29",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Simulation</span>"
    ]
  },
  {
    "objectID": "reference/simulation.html#state-management",
    "href": "reference/simulation.html#state-management",
    "title": "Simulation",
    "section": "State Management",
    "text": "State Management\n\nreset!\nReset a FireState to initial conditions for reuse in ensemble simulations.\nreset!(state::FireState{T})\n\nstate = FireState{Float64}(50, 50, 30.0)\nignite!(state, 25, 25, 0.0)\nsimulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 10.0)\n\nprintln(\"Before reset: $(count(state.burned)) burned cells\")\nreset!(state)\nprintln(\"After reset: $(count(state.burned)) burned cells\")\n\nBefore reset: 66 burned cells\nAfter reset: 0 burned cells\n\n\n\n\ncopy\nCreate a deep copy of a FireState for thread-safe parallel execution.\nBase.copy(state::FireState{T}) -&gt; FireState{T}",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Simulation</span>"
    ]
  },
  {
    "objectID": "reference/simulation.html#output-functions",
    "href": "reference/simulation.html#output-functions",
    "title": "Simulation",
    "section": "Output Functions",
    "text": "Output Functions\n\nget_fire_perimeter\nGet the grid coordinates of cells on the fire perimeter.\nget_fire_perimeter(state::FireState) -&gt; Vector{Tuple{Int, Int}}\nReturns burned cells adjacent to unburned cells.\n\nstate = FireState{Float64}(50, 50, 30.0)\nignite!(state, 25, 25, 0.0)\nsimulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 15.0)\n\nperimeter = get_fire_perimeter(state)\nprintln(\"Perimeter cells: $(length(perimeter))\")\n\nPerimeter cells: 106\n\n\n\n\nget_burned_area\nGet the total burned area in square feet.\nget_burned_area(state::FireState{T}) -&gt; T\n\n\nget_burned_area_acres\nGet the total burned area in acres.\nget_burned_area_acres(state::FireState{T}) -&gt; T\n\nstate = FireState{Float64}(100, 100, 30.0)\nignite!(state, 50, 50, 0.0)\nsimulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 30.0)\n\nprintln(\"Burned area: $(round(get_burned_area(state), digits=0)) ft²\")\nprintln(\"Burned area: $(round(get_burned_area_acres(state), digits=2)) acres\")\n\nBurned area: 1.215e6 ft²\nBurned area: 27.89 acres",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Simulation</span>"
    ]
  },
  {
    "objectID": "reference/simulation.html#helper-functions",
    "href": "reference/simulation.html#helper-functions",
    "title": "Simulation",
    "section": "Helper Functions",
    "text": "Helper Functions\n\nwind_adjustment_factor\nCalculate wind adjustment factor (WAF) from 20-ft wind to mid-flame wind.\nwind_adjustment_factor(fuel_bed_depth::T) -&gt; T\nUses the unsheltered (no canopy) formula.\n\ndepths = [0.5, 1.0, 2.0, 3.0, 4.0]\nwafs = [wind_adjustment_factor(d) for d in depths]\n\nfor (d, w) in zip(depths, wafs)\n    println(\"Depth $d ft: WAF = $(round(w, digits=3))\")\nend\n\nDepth 0.5 ft: WAF = 0.319\nDepth 1.0 ft: WAF = 0.362\nDepth 2.0 ft: WAF = 0.418\nDepth 3.0 ft: WAF = 0.459\nDepth 4.0 ft: WAF = 0.492\n\n\n\n\ncalculate_tanslp2\nCalculate tan²(slope) from slope in degrees.\ncalculate_tanslp2(slope_degrees::T) -&gt; T\n\nslopes = [0, 10, 20, 30, 45]\nfor s in slopes\n    println(\"Slope $(s)°: tan²(slope) = $(round(calculate_tanslp2(Float64(s)), digits=4))\")\nend\n\nSlope 0°: tan²(slope) = 0.0\nSlope 10°: tan²(slope) = 0.0311\nSlope 20°: tan²(slope) = 0.1325\nSlope 30°: tan²(slope) = 0.3333\nSlope 45°: tan²(slope) = 1.0\n\n\n\n\nCoordinate Conversion\ngrid_to_padded(state::FireState, ix::Int, iy::Int) -&gt; Tuple{Int, Int}\npadded_to_grid(state::FireState, px::Int, py::Int) -&gt; Tuple{Int, Int}\nConvert between grid coordinates (1:ncols, 1:nrows) and padded array coordinates.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Simulation</span>"
    ]
  },
  {
    "objectID": "reference/simulation.html#callbacks",
    "href": "reference/simulation.html#callbacks",
    "title": "Simulation",
    "section": "Callbacks",
    "text": "Callbacks\nThe simulation functions accept an optional callback that is called after each timestep:\ncallback(state, t, dt, iteration)\n\nstate = FireState{Float64}(50, 50, 30.0)\nignite!(state, 25, 25, 0.0)\n\nareas = Float64[]\ntimes = Float64[]\n\nfunction track_area(state, t, dt, iter)\n    push!(times, t)\n    push!(areas, get_burned_area_acres(state))\nend\n\nsimulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 20.0;\n    callback = track_area)\n\nplot(times, areas,\n    xlabel = \"Time (min)\",\n    ylabel = \"Burned Area (acres)\",\n    title = \"Fire Growth Over Time\",\n    linewidth = 2,\n    legend = false\n)",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Simulation</span>"
    ]
  },
  {
    "objectID": "reference/weather.html",
    "href": "reference/weather.html",
    "title": "Weather",
    "section": "",
    "text": "Types\nThis module handles weather data for fire simulations, including spatially and temporally varying conditions.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Weather</span>"
    ]
  },
  {
    "objectID": "reference/weather.html#types",
    "href": "reference/weather.html#types",
    "title": "Weather",
    "section": "",
    "text": "ConstantWeather\nConstant (spatially and temporally uniform) weather conditions.\nstruct ConstantWeather{T&lt;:AbstractFloat}\n    wind_speed_20ft::T      # 20-ft wind speed (mph)\n    wind_direction::T       # Wind direction (degrees, meteorological: FROM)\n    M1::T                   # 1-hr dead fuel moisture (fraction)\n    M10::T                  # 10-hr dead fuel moisture (fraction)\n    M100::T                 # 100-hr dead fuel moisture (fraction)\n    MLH::T                  # Live herbaceous moisture (fraction)\n    MLW::T                  # Live woody moisture (fraction)\nend\nConstructor:\nConstantWeather{T}(;\n    wind_speed_mph = 10.0,\n    wind_direction = 0.0,\n    M1 = 0.06,\n    M10 = 0.08,\n    M100 = 0.10,\n    MLH = 0.60,\n    MLW = 0.90\n) -&gt; ConstantWeather{T}\n\n# Create weather with default values\nweather = ConstantWeather{Float64}()\nprintln(\"Wind: $(weather.wind_speed_20ft) mph from $(weather.wind_direction)°\")\nprintln(\"Dead fuel moisture: M1=$(weather.M1), M10=$(weather.M10), M100=$(weather.M100)\")\nprintln(\"Live fuel moisture: MLH=$(weather.MLH), MLW=$(weather.MLW)\")\n\nWind: 10.0 mph from 0.0°\nDead fuel moisture: M1=0.06, M10=0.08, M100=0.1\nLive fuel moisture: MLH=0.6, MLW=0.9\n\n\n\n# Custom weather conditions\ndry_weather = ConstantWeather{Float64}(\n    wind_speed_mph = 25.0,     # Strong wind\n    wind_direction = 270.0,    # From west\n    M1 = 0.03,                 # Very dry fine fuels\n    M10 = 0.04,\n    M100 = 0.06,\n    MLH = 0.30,                # Dry live fuels\n    MLW = 0.50\n)\n\nConstantWeather{Float64}(25.0, 270.0, 0.03, 0.04, 0.06, 0.3, 0.5)\n\n\n\nWeather Variables\n\n\n\n\n\n\n\n\nVariable\nDescription\nTypical Range\n\n\n\n\nwind_speed_20ft\nWind speed at 20 ft height (mph)\n0-40\n\n\nwind_direction\nDirection wind is FROM (degrees, N=0, E=90)\n0-360\n\n\nM1\n1-hour dead fuel moisture (fraction)\n0.03-0.15\n\n\nM10\n10-hour dead fuel moisture (fraction)\n0.04-0.20\n\n\nM100\n100-hour dead fuel moisture (fraction)\n0.06-0.25\n\n\nMLH\nLive herbaceous moisture (fraction)\n0.30-1.20\n\n\nMLW\nLive woody moisture (fraction)\n0.50-1.50\n\n\n\n\n\n\nWeatherGrid\nA grid of weather values at a single time, for spatially varying conditions.\nstruct WeatherGrid{T&lt;:AbstractFloat}\n    ws::Matrix{T}      # Wind speed (mph)\n    wd::Matrix{T}      # Wind direction (degrees, FROM)\n    m1::Matrix{T}      # 1-hour dead fuel moisture\n    m10::Matrix{T}     # 10-hour dead fuel moisture\n    m100::Matrix{T}    # 100-hour dead fuel moisture\n    mlh::Matrix{T}     # Live herbaceous moisture\n    mlw::Matrix{T}     # Live woody moisture\n    ncols::Int         # Number of columns\n    nrows::Int         # Number of rows\n    cellsize::T        # Cell size (meters)\n    xllcorner::T       # X coordinate of lower-left corner\n    yllcorner::T       # Y coordinate of lower-left corner\nend\nConstructors:\n# Create empty weather grid\nWeatherGrid{T}(ncols, nrows, cellsize; xllcorner=0.0, yllcorner=0.0)\n\n# Create uniform grid from ConstantWeather\nWeatherGrid{T}(weather::ConstantWeather, ncols, nrows, cellsize)\n\n# Create a weather grid with spatial variation\nncols, nrows = 10, 10\ncellsize = 1000.0  # 1km cells\n\nwgrid = WeatherGrid{Float64}(ncols, nrows, cellsize)\n\n# Add wind gradient (wind speed increases to the east)\nfor ix in 1:ncols\n    wgrid.ws[ix, :] .= 5.0 + 2.0 * ix  # 7-25 mph gradient\n    wgrid.wd[ix, :] .= 270.0            # From west\nend\n\nprintln(\"Wind speed range: $(minimum(wgrid.ws)) - $(maximum(wgrid.ws)) mph\")\n\nWind speed range: 7.0 - 25.0 mph\n\n\n\n\nWeatherTimeSeries\nA time series of weather grids for temporally varying conditions.\nstruct WeatherTimeSeries{T&lt;:AbstractFloat}\n    grids::Vector{WeatherGrid{T}}  # Weather grids at each time\n    times::Vector{T}               # Times (minutes from start)\n    dt::T                          # Time step between grids\nend\nConstructors:\n# From vector of grids and times\nWeatherTimeSeries{T}(grids::Vector{WeatherGrid}, times::Vector)\n\n# Constant weather over duration\nWeatherTimeSeries{T}(weather::ConstantWeather, ncols, nrows, cellsize, duration)\n\n# Create time-varying weather\nweather1 = ConstantWeather{Float64}(wind_speed_mph = 10.0, wind_direction = 270.0,\n    M1 = 0.08, M10 = 0.10, M100 = 0.12, MLH = 0.70, MLW = 1.0)\nweather2 = ConstantWeather{Float64}(wind_speed_mph = 20.0, wind_direction = 315.0,\n    M1 = 0.05, M10 = 0.07, M100 = 0.09, MLH = 0.50, MLW = 0.80)\n\ngrid1 = WeatherGrid{Float64}(weather1, 1, 1, 1e6)\ngrid2 = WeatherGrid{Float64}(weather2, 1, 1, 1e6)\n\nwts = WeatherTimeSeries{Float64}([grid1, grid2], [0.0, 60.0])\n\nprintln(\"Weather at t=0: $(wts.grids[1].ws[1,1]) mph from $(wts.grids[1].wd[1,1])°\")\nprintln(\"Weather at t=60: $(wts.grids[2].ws[1,1]) mph from $(wts.grids[2].wd[1,1])°\")\n\nWeather at t=0: 10.0 mph from 270.0°\nWeather at t=60: 20.0 mph from 315.0°\n\n\n\n\nWeatherInterpolator\nHandles interpolation of weather data to simulation grid and time.\nstruct WeatherInterpolator{T&lt;:AbstractFloat}\n    weather_series::WeatherTimeSeries{T}\n    icol_map::Vector{Int}    # Mapping from sim column to weather column\n    irow_map::Vector{Int}    # Mapping from sim row to weather row\n    sim_ncols::Int\n    sim_nrows::Int\nend",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Weather</span>"
    ]
  },
  {
    "objectID": "reference/weather.html#functions",
    "href": "reference/weather.html#functions",
    "title": "Weather",
    "section": "Functions",
    "text": "Functions\n\ncreate_constant_interpolator\nCreate a weather interpolator for constant (uniform) weather conditions.\ncreate_constant_interpolator(\n    weather::ConstantWeather{T},\n    sim_ncols::Int, sim_nrows::Int,\n    sim_cellsize::T\n) -&gt; WeatherInterpolator{T}\n\nweather = ConstantWeather{Float64}(wind_speed_mph = 15.0, wind_direction = 270.0,\n    M1 = 0.06, M10 = 0.08, M100 = 0.10, MLH = 0.60, MLW = 0.90)\n\ninterp = create_constant_interpolator(weather, 100, 100, 30.0)\n\n# Get weather at any cell - always returns the same values\nw = get_weather_at(interp, 50, 50, 30.0)\nprintln(\"Wind: $(w.ws) mph from $(w.wd)°\")\n\nWind: 15.0 mph from 270.0°\n\n\n\n\nget_weather_at\nGet interpolated weather values at a simulation grid cell and time.\nget_weather_at(interp::WeatherInterpolator, ix::Int, iy::Int, t::T) -&gt; NamedTuple\nReturns a named tuple with fields: ws, wd, m1, m10, m100, mlh, mlw\n\nw = get_weather_at(interp, 25, 75, 0.0)\n\nprintln(\"Wind speed: $(w.ws) mph\")\nprintln(\"Wind direction: $(w.wd)°\")\nprintln(\"1-hr moisture: $(w.m1)\")\nprintln(\"Live herb moisture: $(w.mlh)\")\n\nWind speed: 15.0 mph\nWind direction: 270.0°\n1-hr moisture: 0.06\nLive herb moisture: 0.6\n\n\n\n\nfind_time_indices\nFind the indices and interpolation weight for a given time.\nfind_time_indices(wts::WeatherTimeSeries, t::T) -&gt; Tuple{Int, Int, T}\nReturns (i_lo, i_hi, f) where the interpolated value is: value = (1-f) * grids[i_lo] + f * grids[i_hi]\n\n# Time series with weather at t=0 and t=60\ni_lo, i_hi, f = find_time_indices(wts, 30.0)\nprintln(\"At t=30: i_lo=$i_lo, i_hi=$i_hi, f=$f (50% interpolation)\")\n\nAt t=30: i_lo=1, i_hi=2, f=0.5 (50% interpolation)\n\n\n\n\ninterpolate_wind_direction\nInterpolate wind direction, properly handling the 0°/360° wrap-around.\ninterpolate_wind_direction(wd1::T, wd2::T, f::T) -&gt; T\n\n# Normal interpolation\nwd = interpolate_wind_direction(270.0, 315.0, 0.5)\nprintln(\"Interpolated direction (270° to 315°): $(round(wd, digits=1))°\")\n\n# Wrap-around interpolation\nwd = interpolate_wind_direction(350.0, 10.0, 0.5)\nprintln(\"Interpolated direction (350° to 10°): $(round(wd, digits=1))°\")\n\nInterpolated direction (270° to 315°): 292.5°\nInterpolated direction (350° to 10°): 360.0°\n\n\n\n\ncreate_grid_mapping\nCreate mapping from simulation grid to weather grid indices.\ncreate_grid_mapping(\n    weather_grid::WeatherGrid,\n    sim_ncols, sim_nrows, sim_cellsize,\n    sim_xllcorner, sim_yllcorner\n) -&gt; Tuple{Vector{Int}, Vector{Int}}\nReturns (icol_weather, irow_weather) vectors such that simulation cell (ix, iy) maps to weather cell (icol_weather[ix], irow_weather[iy]).",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Weather</span>"
    ]
  },
  {
    "objectID": "reference/weather.html#weather-effects-on-fire-spread",
    "href": "reference/weather.html#weather-effects-on-fire-spread",
    "title": "Weather",
    "section": "Weather Effects on Fire Spread",
    "text": "Weather Effects on Fire Spread\n\nWind Speed Effects\n\nfuel_table = create_standard_fuel_table(Float64)\nwind_speeds = [5, 10, 15, 20, 25, 30]\nareas = Float64[]\n\nfor ws in wind_speeds\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = Float64(ws),\n        wind_direction = 270.0,\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n\n    state = FireState{Float64}(100, 100, 30.0)\n    ignite!(state, 50, 50, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 20.0)\n\n    push!(areas, get_burned_area_acres(state))\nend\n\nplot(wind_speeds, areas,\n    xlabel = \"Wind Speed (mph)\",\n    ylabel = \"Burned Area (acres)\",\n    title = \"Effect of Wind Speed on Fire Spread (20 min)\",\n    linewidth = 2,\n    marker = :circle,\n    legend = false\n)\n\n\n\n\n\n\nFuel Moisture Effects\n\nmoisture_levels = [0.03, 0.06, 0.09, 0.12, 0.15]\nareas = Float64[]\n\nfor m1 in moisture_levels\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 10.0,\n        wind_direction = 270.0,\n        M1 = m1, M10 = m1 + 0.02, M100 = m1 + 0.04,\n        MLH = 0.60, MLW = 0.90\n    )\n\n    state = FireState{Float64}(100, 100, 30.0)\n    ignite!(state, 50, 50, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 20.0)\n\n    push!(areas, get_burned_area_acres(state))\nend\n\nplot(moisture_levels .* 100, areas,\n    xlabel = \"1-hr Fuel Moisture (%)\",\n    ylabel = \"Burned Area (acres)\",\n    title = \"Effect of Fuel Moisture on Fire Spread (20 min)\",\n    linewidth = 2,\n    marker = :circle,\n    legend = false\n)\n\n\n\n\n\n\nWind Direction\nWind direction is specified in meteorological convention: the direction the wind is blowing FROM.\n\n\n\nDirection\nDegrees\nFire Spreads To\n\n\n\n\nNorth\n0° or 360°\nSouth\n\n\nEast\n90°\nWest\n\n\nSouth\n180°\nNorth\n\n\nWest\n270°\nEast\n\n\n\n\ndirections = [0, 90, 180, 270]\nlabels = [\"From N\", \"From E\", \"From S\", \"From W\"]\nplots_arr = []\n\nfor (dir, lbl) in zip(directions, labels)\n    weather = ConstantWeather{Float64}(\n        wind_speed_mph = 15.0,\n        wind_direction = Float64(dir),\n        M1 = 0.06, M10 = 0.08, M100 = 0.10,\n        MLH = 0.60, MLW = 0.90\n    )\n\n    state = FireState{Float64}(80, 80, 30.0)\n    ignite!(state, 40, 40, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 20.0)\n\n    push!(plots_arr, heatmap(state.burned', title = lbl, color = :YlOrRd,\n        aspect_ratio = 1, colorbar = false))\nend\n\nplot(plots_arr..., layout = (2, 2), size = (600, 600))",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Weather</span>"
    ]
  },
  {
    "objectID": "reference/weather.html#fire-weather-scenarios",
    "href": "reference/weather.html#fire-weather-scenarios",
    "title": "Weather",
    "section": "Fire Weather Scenarios",
    "text": "Fire Weather Scenarios\n\nTypical Conditions\n\n# Moderate conditions\nmoderate = ConstantWeather{Float64}(\n    wind_speed_mph = 8.0,\n    wind_direction = 270.0,\n    M1 = 0.08, M10 = 0.10, M100 = 0.12,\n    MLH = 0.80, MLW = 1.00\n)\n\n# Hot/dry conditions\nhot_dry = ConstantWeather{Float64}(\n    wind_speed_mph = 15.0,\n    wind_direction = 270.0,\n    M1 = 0.04, M10 = 0.06, M100 = 0.08,\n    MLH = 0.40, MLW = 0.60\n)\n\n# Red flag conditions\nred_flag = ConstantWeather{Float64}(\n    wind_speed_mph = 25.0,\n    wind_direction = 45.0,  # Santa Ana direction\n    M1 = 0.02, M10 = 0.04, M100 = 0.06,\n    MLH = 0.30, MLW = 0.50\n)\n\nprintln(\"Moderate: $(moderate.wind_speed_20ft) mph, $(moderate.M1*100)% M1\")\nprintln(\"Hot/Dry: $(hot_dry.wind_speed_20ft) mph, $(hot_dry.M1*100)% M1\")\nprintln(\"Red Flag: $(red_flag.wind_speed_20ft) mph, $(red_flag.M1*100)% M1\")\n\nModerate: 8.0 mph, 8.0% M1\nHot/Dry: 15.0 mph, 4.0% M1\nRed Flag: 25.0 mph, 2.0% M1\n\n\n\n\nComparing Scenarios\n\nscenarios = [\n    (\"Moderate\", moderate),\n    (\"Hot/Dry\", hot_dry),\n    (\"Red Flag\", red_flag)\n]\n\nplots_arr = []\n\nfor (name, weather) in scenarios\n    state = FireState{Float64}(100, 100, 30.0)\n    ignite!(state, 30, 50, 0.0)\n    simulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 30.0)\n\n    acres = round(get_burned_area_acres(state), digits=1)\n    push!(plots_arr, heatmap(state.burned',\n        title = \"$name\\n$acres acres\",\n        color = :YlOrRd, aspect_ratio = 1, colorbar = false))\nend\n\nplot(plots_arr..., layout = (1, 3), size = (900, 300))",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Weather</span>"
    ]
  },
  {
    "objectID": "reference/geospatial.html",
    "href": "reference/geospatial.html",
    "title": "Geospatial I/O",
    "section": "",
    "text": "Types\nThis module provides GeoTIFF reading/writing, raster processing, and landscape data management for fire simulations.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Geospatial I/O</span>"
    ]
  },
  {
    "objectID": "reference/geospatial.html#types",
    "href": "reference/geospatial.html#types",
    "title": "Geospatial I/O",
    "section": "",
    "text": "GeoMetadata\nGeospatial metadata for a raster dataset.\nstruct GeoMetadata{T&lt;:AbstractFloat}\n    ncols::Int          # Number of columns\n    nrows::Int          # Number of rows\n    cellsize::T         # Cell size (same units as CRS)\n    xllcorner::T        # X coordinate of lower-left corner\n    yllcorner::T        # Y coordinate of lower-left corner\n    nodata_value::T     # NoData value\n    crs::String         # Coordinate reference system (PROJ4 string)\n    transform::NTuple{6,T}  # GDAL GeoTransform\nend\nConstructor:\nGeoMetadata{T}(;\n    ncols::Int,\n    nrows::Int,\n    cellsize::T,\n    xllcorner = zero(T),\n    yllcorner = zero(T),\n    nodata_value = T(-9999),\n    crs = \"EPSG:4326\",\n    transform = nothing\n)\nThe GDAL GeoTransform is a 6-element tuple: (xmin, xres, xskew, ymax, yskew, -yres)\n\nmetadata = GeoMetadata{Float64}(\n    ncols = 100,\n    nrows = 100,\n    cellsize = 30.0,\n    xllcorner = 0.0,\n    yllcorner = 0.0,\n    crs = \"EPSG:32610\"  # UTM Zone 10N\n)\n\nprintln(\"Grid size: $(metadata.ncols) x $(metadata.nrows)\")\nprintln(\"Cell size: $(metadata.cellsize)\")\nprintln(\"CRS: $(metadata.crs)\")\n\nGrid size: 100 x 100\nCell size: 30.0\nCRS: EPSG:32610\n\n\n\n\nGeoRaster\nA raster dataset with geospatial metadata.\nstruct GeoRaster{T&lt;:AbstractFloat}\n    data::Matrix{T}\n    metadata::GeoMetadata{T}\nend\n\n# Create a simple raster\ndata = randn(Float64, 50, 50) .* 100 .+ 500  # Elevation-like data\nmetadata = GeoMetadata{Float64}(ncols=50, nrows=50, cellsize=30.0)\nraster = GeoRaster{Float64}(data, metadata)\n\nprintln(\"Raster size: $(size(raster))\")\nprintln(\"Data range: $(minimum(raster.data)) - $(maximum(raster.data))\")\n\nRaster size: (50, 50)\nData range: 114.17104503348315 - 832.3897920927398\n\n\n\n\nLandscapeData\nComplete landscape data for fire simulation including fuel, topography, and canopy.\nstruct LandscapeData{T&lt;:AbstractFloat}\n    fuel_ids::Matrix{Int}                 # Fuel model IDs\n    slope::Matrix{T}                      # Slope (degrees)\n    aspect::Matrix{T}                     # Aspect (degrees from north)\n    elevation::Matrix{T}                  # Elevation\n    canopy::Union{Nothing, CanopyGrid{T}} # Optional canopy data\n    metadata::GeoMetadata{T}              # Geospatial metadata\nend",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Geospatial I/O</span>"
    ]
  },
  {
    "objectID": "reference/geospatial.html#reading-functions",
    "href": "reference/geospatial.html#reading-functions",
    "title": "Geospatial I/O",
    "section": "Reading Functions",
    "text": "Reading Functions\n\nread_geotiff\nRead a GeoTIFF file and return a GeoRaster.\nread_geotiff(::Type{T}, path::String) -&gt; GeoRaster{T}\nread_geotiff(path::String) -&gt; GeoRaster{Float64}\nThe data is automatically transposed to match Julia’s column-major order.\n\n\nread_fuel_raster\nRead a fuel model raster (integer fuel IDs) and return the matrix with metadata.\nread_fuel_raster(::Type{T}, path::String) -&gt; Tuple{Matrix{Int}, GeoMetadata{T}}\n\n\nread_dem\nRead a Digital Elevation Model raster.\nread_dem(::Type{T}, path::String) -&gt; GeoRaster{T}\n\n\nread_landscape\nRead a complete landscape dataset from GeoTIFF files.\nread_landscape(::Type{T}, fuel_path, dem_path;\n    cbd_path = nothing,    # Canopy bulk density\n    cbh_path = nothing,    # Canopy base height\n    cc_path = nothing,     # Canopy cover\n    ch_path = nothing      # Canopy height\n) -&gt; LandscapeData{T}\nExample usage:\n# Read basic landscape\nlandscape = read_landscape(Float64,\n    \"fuel_model.tif\",\n    \"elevation.tif\"\n)\n\n# Read with canopy data for crown fire\nlandscape = read_landscape(Float64,\n    \"fuel_model.tif\",\n    \"elevation.tif\";\n    cbd_path = \"canopy_bulk_density.tif\",\n    cbh_path = \"canopy_base_height.tif\",\n    cc_path = \"canopy_cover.tif\",\n    ch_path = \"canopy_height.tif\"\n)",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Geospatial I/O</span>"
    ]
  },
  {
    "objectID": "reference/geospatial.html#writing-functions",
    "href": "reference/geospatial.html#writing-functions",
    "title": "Geospatial I/O",
    "section": "Writing Functions",
    "text": "Writing Functions\n\nwrite_geotiff\nWrite a GeoRaster to a GeoTIFF file.\nwrite_geotiff(path::String, raster::GeoRaster)\nwrite_geotiff(path::String, data::Matrix, metadata::GeoMetadata)\n\n\nwrite_fire_perimeter\nWrite fire perimeter to a GeoJSON file.\nwrite_fire_perimeter(path::String, state::FireState, metadata::GeoMetadata; format=:geojson)",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Geospatial I/O</span>"
    ]
  },
  {
    "objectID": "reference/geospatial.html#terrain-processing",
    "href": "reference/geospatial.html#terrain-processing",
    "title": "Geospatial I/O",
    "section": "Terrain Processing",
    "text": "Terrain Processing\n\ncompute_slope_aspect\nCompute slope and aspect from a DEM using a 3x3 moving window.\ncompute_slope_aspect(dem::GeoRaster) -&gt; Tuple{Matrix, Matrix}\ncompute_slope_aspect(elevation::Matrix, cellsize) -&gt; Tuple{Matrix, Matrix}\nReturns (slope_degrees, aspect_degrees) where: - Slope is in degrees (0-90) - Aspect is in degrees clockwise from north (0-360), with flat areas set to 0\n\n# Create synthetic elevation data (a hill)\nncols, nrows = 100, 100\nelevation = zeros(Float64, ncols, nrows)\n\nfor ix in 1:ncols\n    for iy in 1:nrows\n        # Distance from center\n        dx = ix - 50\n        dy = iy - 50\n        dist = sqrt(dx^2 + dy^2)\n        # Gaussian hill\n        elevation[ix, iy] = 100 * exp(-dist^2 / 500)\n    end\nend\n\n# Compute slope and aspect\nslope, aspect = compute_slope_aspect(elevation, 30.0)\n\nprintln(\"Slope range: $(round(minimum(slope), digits=1))° - $(round(maximum(slope), digits=1))°\")\nprintln(\"Aspect range: $(round(minimum(aspect), digits=1))° - $(round(maximum(aspect), digits=1))°\")\n\nSlope range: 0.0° - 7.3°\nAspect range: 0.0° - 358.8°\n\n\n\nusing Plots\n\np1 = heatmap(elevation', title = \"Elevation\", color = :terrain)\np2 = heatmap(slope', title = \"Slope (degrees)\", color = :YlOrRd)\np3 = heatmap(aspect', title = \"Aspect (degrees)\", color = :hsv)\n\nplot(p1, p2, p3, layout = (1, 3), size = (900, 300))",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Geospatial I/O</span>"
    ]
  },
  {
    "objectID": "reference/geospatial.html#coordinate-conversion",
    "href": "reference/geospatial.html#coordinate-conversion",
    "title": "Geospatial I/O",
    "section": "Coordinate Conversion",
    "text": "Coordinate Conversion\n\ngrid_to_geo\nConvert grid coordinates to geographic coordinates.\ngrid_to_geo(ix::Int, iy::Int, metadata::GeoMetadata) -&gt; Tuple{T, T}\n\n\ngeo_to_grid\nConvert geographic coordinates to grid coordinates.\ngeo_to_grid(x::T, y::T, metadata::GeoMetadata) -&gt; Tuple{Int, Int}\n\nmetadata = GeoMetadata{Float64}(\n    ncols = 100,\n    nrows = 100,\n    cellsize = 30.0,\n    xllcorner = 500000.0,  # UTM easting\n    yllcorner = 4000000.0  # UTM northing\n)\n\n# Grid to geo\nx, y = grid_to_geo(50, 50, metadata)\nprintln(\"Grid (50, 50) -&gt; Geo ($(x), $(y))\")\n\n# Geo to grid\nix, iy = geo_to_grid(x, y, metadata)\nprintln(\"Geo ($(x), $(y)) -&gt; Grid ($ix, $iy)\")\n\nGrid (50, 50) -&gt; Geo (501485.0, 4.001515e6)\nGeo (501485.0, 4.001515e6) -&gt; Grid (50, 50)",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Geospatial I/O</span>"
    ]
  },
  {
    "objectID": "reference/geospatial.html#resampling",
    "href": "reference/geospatial.html#resampling",
    "title": "Geospatial I/O",
    "section": "Resampling",
    "text": "Resampling\n\nresample_to_match\nResample a raster to match the resolution and extent of a target raster.\nresample_to_match(source::GeoRaster, target::GeoMetadata; method=:nearest) -&gt; GeoRaster\nMethods: - :nearest - Nearest neighbor (default, preserves discrete values like fuel IDs) - :bilinear - Bilinear interpolation (good for continuous data like elevation)",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Geospatial I/O</span>"
    ]
  },
  {
    "objectID": "reference/geospatial.html#workflow-example",
    "href": "reference/geospatial.html#workflow-example",
    "title": "Geospatial I/O",
    "section": "Workflow Example",
    "text": "Workflow Example\n\n# This example shows the typical workflow for loading landscape data\n# and running a simulation (using synthetic data since we don't have real files)\n\n# Create synthetic landscape data\nncols, nrows = 100, 100\ncellsize = 30.0\n\n# Synthetic elevation (valley)\nelevation = zeros(Float64, ncols, nrows)\nfor ix in 1:ncols, iy in 1:nrows\n    elevation[ix, iy] = 100 + abs(iy - 50) * 5  # Valley at y=50\nend\n\n# Compute terrain from elevation\nslope, aspect = compute_slope_aspect(elevation, cellsize)\n\n# Synthetic fuel (grass with some timber)\nfuel_ids = fill(1, ncols, nrows)  # Grass\nfuel_ids[40:60, :] .= 10           # Timber along valley\n\n# Create fire state\nstate = FireState{Float64}(ncols, nrows, cellsize)\nfuel_table = create_standard_fuel_table(Float64)\n\n# Weather\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 10.0,\n    wind_direction = 270.0,\n    M1 = 0.06, M10 = 0.08, M100 = 0.10,\n    MLH = 0.60, MLW = 0.90\n)\n\n# Ignite and run\nignite!(state, 50, 50, 0.0)\nsimulate!(state, fuel_ids, fuel_table, weather, slope, aspect, 0.0, 30.0)\n\n# Visualize results\np1 = heatmap(elevation', title = \"Elevation\", color = :terrain)\np2 = heatmap(fuel_ids', title = \"Fuel Model\", color = [:green, :darkgreen])\np3 = heatmap(state.burned', title = \"Burned Area\", color = :YlOrRd)\n\nplot(p1, p2, p3, layout = (1, 3), size = (900, 300))",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Geospatial I/O</span>"
    ]
  },
  {
    "objectID": "reference/geospatial.html#data-sources",
    "href": "reference/geospatial.html#data-sources",
    "title": "Geospatial I/O",
    "section": "Data Sources",
    "text": "Data Sources\nElmfire.jl can read landscape data from common sources:\n\n\n\nData Type\nCommon Sources\nFile Format\n\n\n\n\nFuel Models\nLANDFIRE, FCCS\nGeoTIFF\n\n\nElevation\nUSGS 3DEP, SRTM\nGeoTIFF\n\n\nCanopy\nLANDFIRE\nGeoTIFF\n\n\nWeather\nRTMA, RAP, HRRR\nNetCDF, GRIB2",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Geospatial I/O</span>"
    ]
  },
  {
    "objectID": "reference/geospatial.html#coordinate-reference-systems",
    "href": "reference/geospatial.html#coordinate-reference-systems",
    "title": "Geospatial I/O",
    "section": "Coordinate Reference Systems",
    "text": "Coordinate Reference Systems\nFire simulations require projected coordinates (not lat/lon) for accurate distance calculations. Common projections:\n\nUTM - Universal Transverse Mercator (e.g., EPSG:32610 for zone 10N)\nAlbers Equal Area - Good for large areas (e.g., EPSG:5070 for CONUS)\nState Plane - US state-specific projections\n\nAll input rasters should be in the same CRS before loading.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Geospatial I/O</span>"
    ]
  },
  {
    "objectID": "reference/ensemble.html",
    "href": "reference/ensemble.html",
    "title": "Ensemble",
    "section": "",
    "text": "Types\nThis module implements Monte Carlo ensemble simulations with parameter perturbations for probabilistic fire spread forecasting.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Ensemble</span>"
    ]
  },
  {
    "objectID": "reference/ensemble.html#types",
    "href": "reference/ensemble.html#types",
    "title": "Ensemble",
    "section": "",
    "text": "PerturbationConfig\nConfiguration for stochastic parameter perturbations.\nstruct PerturbationConfig{T&lt;:AbstractFloat}\n    ignition_perturb_radius::T         # Radius for ignition point perturbation (cells)\n    wind_speed_factor_range::Tuple{T,T}  # (min, max) multiplier for wind speed\n    wind_direction_std::T              # Standard deviation for wind direction (degrees)\n    moisture_factor_range::Tuple{T,T}  # (min, max) multiplier for fuel moisture\n    spread_rate_factor_range::Tuple{T,T}  # (min, max) multiplier for spread rate\nend\nConstructor:\nPerturbationConfig{T}(;\n    ignition_perturb_radius = 0.0,\n    wind_speed_factor_range = (1.0, 1.0),\n    wind_direction_std = 0.0,\n    moisture_factor_range = (1.0, 1.0),\n    spread_rate_factor_range = (1.0, 1.0)\n)\n\n# No perturbations (deterministic)\nperturb_none = PerturbationConfig{Float64}()\n\n# Moderate perturbations\nperturb_moderate = PerturbationConfig{Float64}(\n    ignition_perturb_radius = 2.0,\n    wind_speed_factor_range = (0.8, 1.2),\n    wind_direction_std = 15.0,\n    moisture_factor_range = (0.9, 1.1)\n)\n\n# High uncertainty\nperturb_high = PerturbationConfig{Float64}(\n    ignition_perturb_radius = 5.0,\n    wind_speed_factor_range = (0.6, 1.4),\n    wind_direction_std = 30.0,\n    moisture_factor_range = (0.7, 1.3)\n)\n\nPerturbationConfig{Float64}(5.0, (0.6, 1.4), 30.0, (0.7, 1.3), (1.0, 1.0))\n\n\n\n\nEnsembleConfig\nConfiguration for ensemble simulation runs.\nstruct EnsembleConfig{T&lt;:AbstractFloat}\n    n_simulations::Int                   # Number of ensemble members\n    base_seed::UInt64                    # Base random seed for reproducibility\n    perturbation::PerturbationConfig{T}  # Perturbation settings\n    simulation_config::SimulationConfig{T}  # Base simulation configuration\n    save_individual_results::Bool        # Save individual member results\nend\nConstructor:\nEnsembleConfig{T}(;\n    n_simulations = 100,\n    base_seed = UInt64(12345),\n    perturbation = PerturbationConfig{T}(),\n    simulation_config = SimulationConfig{T}(),\n    save_individual_results = false\n)\n\nconfig = EnsembleConfig{Float64}(\n    n_simulations = 50,\n    base_seed = UInt64(42),\n    perturbation = perturb_moderate,\n    save_individual_results = true\n)\n\nprintln(\"Ensemble size: $(config.n_simulations)\")\nprintln(\"Base seed: $(config.base_seed)\")\n\nEnsemble size: 50\nBase seed: 42\n\n\n\n\nEnsembleMember\nResults from a single ensemble member simulation.\nstruct EnsembleMember{T&lt;:AbstractFloat}\n    id::Int                      # Member ID (1 to n_simulations)\n    seed::UInt64                 # Random seed used\n    burned::BitMatrix            # Burned area\n    time_of_arrival::Matrix{T}   # Time of arrival\n    burned_area_acres::T         # Total burned area\n    max_spread_rate::T           # Maximum spread rate\nend\n\n\nEnsembleResult\nAggregated results from an ensemble of simulations.\nmutable struct EnsembleResult{T&lt;:AbstractFloat}\n    config::EnsembleConfig{T}\n    members::Vector{EnsembleMember{T}}  # Individual results (if saved)\n    burn_probability::Matrix{T}         # Probability of each cell burning\n    mean_arrival_time::Matrix{T}        # Mean arrival time (for cells that burn)\n    std_arrival_time::Matrix{T}         # Std dev of arrival time\n    mean_burned_area::T                 # Mean burned area across ensemble\n    std_burned_area::T                  # Std dev of burned area\n    convergence_history::Vector{T}      # RMS change in burn probability\nend",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Ensemble</span>"
    ]
  },
  {
    "objectID": "reference/ensemble.html#functions",
    "href": "reference/ensemble.html#functions",
    "title": "Ensemble",
    "section": "Functions",
    "text": "Functions\n\nrun_ensemble!\nRun a Monte Carlo ensemble of fire simulations.\nrun_ensemble!(\n    config::EnsembleConfig{T},\n    state_template::FireState{T},\n    fuel_ids::Matrix{Int},\n    fuel_table::FuelModelTable{T},\n    weather::ConstantWeather{T},\n    slope::Matrix{T},\n    aspect::Matrix{T},\n    ignition_ix::Int, ignition_iy::Int,\n    t_start::T, t_stop::T;\n    show_progress = true\n) -&gt; EnsembleResult{T}\n\n# Setup\nncols, nrows = 80, 80\nfuel_table = create_standard_fuel_table(Float64)\n\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 12.0,\n    wind_direction = 270.0,\n    M1 = 0.06, M10 = 0.08, M100 = 0.10,\n    MLH = 0.60, MLW = 0.90\n)\n\nfuel_ids = fill(1, ncols, nrows)\nslope = zeros(Float64, ncols, nrows)\naspect = zeros(Float64, ncols, nrows)\nstate_template = FireState{Float64}(ncols, nrows, 30.0)\n\n# Run small ensemble\nconfig = EnsembleConfig{Float64}(\n    n_simulations = 30,\n    base_seed = UInt64(42),\n    perturbation = PerturbationConfig{Float64}(\n        wind_speed_factor_range = (0.8, 1.2),\n        wind_direction_std = 20.0\n    )\n)\n\nresult = run_ensemble!(\n    config,\n    state_template,\n    fuel_ids, fuel_table, weather,\n    slope, aspect,\n    40, 40,  # Ignition point\n    0.0, 25.0;\n    show_progress = false\n)\n\nprintln(\"Mean burned area: $(round(result.mean_burned_area, digits=1)) acres\")\nprintln(\"Std burned area: $(round(result.std_burned_area, digits=1)) acres\")\n\nMean burned area: 33.9 acres\nStd burned area: 10.5 acres\n\n\n\n\nrun_ensemble_threaded!\nRun ensemble using multiple threads for parallel execution.\nrun_ensemble_threaded!(\n    config::EnsembleConfig{T},\n    state_template::FireState{T},\n    fuel_ids::Matrix{Int},\n    fuel_table::FuelModelTable{T},\n    weather::ConstantWeather{T},\n    slope::Matrix{T},\n    aspect::Matrix{T},\n    ignition_ix::Int, ignition_iy::Int,\n    t_start::T, t_stop::T;\n    show_progress = true\n) -&gt; EnsembleResult{T}\nThis function distributes ensemble members across available threads for faster execution.\n\n\nperturb_weather\nApply stochastic perturbations to weather conditions.\nperturb_weather(weather::ConstantWeather{T}, config::PerturbationConfig{T}, rng) -&gt; ConstantWeather{T}\n\nbase_weather = ConstantWeather{Float64}(\n    wind_speed_mph = 15.0,\n    wind_direction = 270.0,\n    M1 = 0.06, M10 = 0.08, M100 = 0.10,\n    MLH = 0.60, MLW = 0.90\n)\n\nperturb = PerturbationConfig{Float64}(\n    wind_speed_factor_range = (0.7, 1.3),\n    wind_direction_std = 25.0,\n    moisture_factor_range = (0.8, 1.2)\n)\n\nrng = MersenneTwister(42)\n\nprintln(\"Base weather: $(base_weather.wind_speed_20ft) mph from $(base_weather.wind_direction)°\")\nprintln(\"\\nPerturbed samples:\")\nfor i in 1:5\n    w = perturb_weather(base_weather, perturb, rng)\n    println(\"  $(round(w.wind_speed_20ft, digits=1)) mph from $(round(w.wind_direction, digits=0))°, M1=$(round(w.M1, digits=3))\")\nend\n\nBase weather: 15.0 mph from 270.0°\n\nPerturbed samples:\n  16.9 mph from 268.0°, M1=0.059\n  12.1 mph from 268.0°, M1=0.055\n  14.5 mph from 269.0°, M1=0.053\n  14.7 mph from 265.0°, M1=0.067\n  13.9 mph from 237.0°, M1=0.051\n\n\n\n\nperturb_ignition\nPerturb ignition location within a given radius.\nperturb_ignition(ix::Int, iy::Int, radius::T, ncols::Int, nrows::Int, rng) -&gt; Tuple{Int, Int}\n\n\ncompute_burn_probability\nCompute burn probability from ensemble members.\ncompute_burn_probability(members::Vector{EnsembleMember}, ncols::Int, nrows::Int) -&gt; Matrix{T}\n\n\ncompute_mean_arrival_time\nCompute mean arrival time from ensemble members.\ncompute_mean_arrival_time(members::Vector{EnsembleMember}, ncols::Int, nrows::Int) -&gt; Matrix{T}\n\n\naggregate_ensemble_statistics!\nUpdate aggregated statistics in an EnsembleResult.\naggregate_ensemble_statistics!(result::EnsembleResult)\n\n\ncheck_convergence\nCheck if the ensemble has converged based on burn probability stability.\ncheck_convergence(result::EnsembleResult, threshold::T = T(0.01)) -&gt; Bool\n\n\nget_exceedance_probability\nGet probability of burned area exceeding a threshold.\nget_exceedance_probability(result::EnsembleResult, area_threshold::T) -&gt; T\n\n# What's the probability of burning more than 2 acres?\nprob_exceed = get_exceedance_probability(result, 2.0)\nprintln(\"P(burned area &gt; 2 acres) = $(round(prob_exceed * 100, digits=1))%\")\n\nP(burned area &gt; 2 acres) = 100.0%\n\n\n\n\nget_percentile_fire\nGet the ensemble member closest to a given percentile of burned area.\nget_percentile_fire(result::EnsembleResult, percentile::T) -&gt; EnsembleMember",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Ensemble</span>"
    ]
  },
  {
    "objectID": "reference/ensemble.html#visualization",
    "href": "reference/ensemble.html#visualization",
    "title": "Ensemble",
    "section": "Visualization",
    "text": "Visualization\n\nBurn Probability Map\n\nheatmap(result.burn_probability',\n    title = \"Burn Probability\",\n    color = :YlOrRd,\n    clims = (0, 1),\n    aspect_ratio = 1,\n    xlabel = \"X (cells)\",\n    ylabel = \"Y (cells)\"\n)\n\n\n\n\n\n\nComparing Percentiles\n\n# Run larger ensemble for percentile analysis\nconfig_large = EnsembleConfig{Float64}(\n    n_simulations = 50,\n    base_seed = UInt64(123),\n    perturbation = PerturbationConfig{Float64}(\n        wind_speed_factor_range = (0.7, 1.3),\n        wind_direction_std = 25.0\n    ),\n    save_individual_results = true\n)\n\nresult_large = run_ensemble!(\n    config_large, state_template,\n    fuel_ids, fuel_table, weather,\n    slope, aspect, 40, 40, 0.0, 25.0;\n    show_progress = false\n)\n\n# Get percentile fires\np10 = get_percentile_fire(result_large, 0.10)\np50 = get_percentile_fire(result_large, 0.50)\np90 = get_percentile_fire(result_large, 0.90)\n\nplots_arr = [\n    heatmap(p10.burned', title = \"10th percentile\\n$(round(p10.burned_area_acres, digits=1)) acres\",\n        color = :YlOrRd, aspect_ratio = 1, colorbar = false),\n    heatmap(p50.burned', title = \"50th percentile\\n$(round(p50.burned_area_acres, digits=1)) acres\",\n        color = :YlOrRd, aspect_ratio = 1, colorbar = false),\n    heatmap(p90.burned', title = \"90th percentile\\n$(round(p90.burned_area_acres, digits=1)) acres\",\n        color = :YlOrRd, aspect_ratio = 1, colorbar = false)\n]\n\nplot(plots_arr..., layout = (1, 3), size = (900, 300))\n\n\n\n\n\n\nBurned Area Distribution\n\nif !isempty(result_large.members)\n    areas = [m.burned_area_acres for m in result_large.members]\n\n    histogram(areas,\n        xlabel = \"Burned Area (acres)\",\n        ylabel = \"Frequency\",\n        title = \"Distribution of Burned Area\",\n        bins = 15,\n        legend = false\n    )\nend",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Ensemble</span>"
    ]
  },
  {
    "objectID": "reference/ensemble.html#best-practices",
    "href": "reference/ensemble.html#best-practices",
    "title": "Ensemble",
    "section": "Best Practices",
    "text": "Best Practices\n\nEnsemble Size\n\nSmall ensembles (20-50): Quick analysis, rough probability estimates\nMedium ensembles (100-200): Good balance of accuracy and speed\nLarge ensembles (500+): High-precision probability maps, convergence testing\n\n\n# Check convergence history\nif !isempty(result_large.convergence_history)\n    plot(result_large.convergence_history,\n        xlabel = \"Ensemble Member\",\n        ylabel = \"RMS Change in Burn Probability\",\n        title = \"Convergence History\",\n        linewidth = 2,\n        legend = false\n    )\nend\n\n\n\n\n\n\nPerturbation Settings\n\n\n\nUncertainty Level\nWind Speed Range\nWind Dir Std\nMoisture Range\n\n\n\n\nLow\n(0.9, 1.1)\n10°\n(0.95, 1.05)\n\n\nModerate\n(0.8, 1.2)\n20°\n(0.85, 1.15)\n\n\nHigh\n(0.7, 1.3)\n30°\n(0.75, 1.25)\n\n\nVery High\n(0.5, 1.5)\n45°\n(0.6, 1.4)\n\n\n\n\n\nReproducibility\nAlways set a base seed for reproducible results:\nconfig = EnsembleConfig{Float64}(\n    n_simulations = 100,\n    base_seed = UInt64(12345)  # Set for reproducibility\n)\nEach ensemble member uses base_seed + member_id as its random seed.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Ensemble</span>"
    ]
  },
  {
    "objectID": "reference/ensemble.html#parallel-execution",
    "href": "reference/ensemble.html#parallel-execution",
    "title": "Ensemble",
    "section": "Parallel Execution",
    "text": "Parallel Execution\nUse run_ensemble_threaded! for multi-core execution:\n# Start Julia with multiple threads: julia -t 8\nresult = run_ensemble_threaded!(config, ...)\nThread scaling is approximately linear up to the number of physical cores.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Ensemble</span>"
    ]
  },
  {
    "objectID": "reference/wui-suppression.html",
    "href": "reference/wui-suppression.html",
    "title": "WUI & Suppression",
    "section": "",
    "text": "WUI Types\nThis module provides models for building ignition in the Wildland-Urban Interface (WUI) and fire suppression resource management.",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>WUI & Suppression</span>"
    ]
  },
  {
    "objectID": "reference/wui-suppression.html#wui-types",
    "href": "reference/wui-suppression.html#wui-types",
    "title": "WUI & Suppression",
    "section": "",
    "text": "WUIBuilding\nRepresents a building that can be ignited by a wildfire.\nstruct WUIBuilding{T&lt;:AbstractFloat}\n    id::Int                       # Building identifier\n    ix::Int                       # Grid X coordinate\n    iy::Int                       # Grid Y coordinate\n    construction_type::Symbol     # :wood, :masonry, :mixed\n    combustible_fraction::T       # Fraction of combustible materials\n    ignition_temperature::T       # Critical ignition temperature (°C)\nend\nConstructor:\nWUIBuilding{T}(id, ix, iy;\n    construction_type = :mixed,\n    combustible_fraction = 0.5,\n    ignition_temperature = 350.0\n)\n\n# Create buildings of different types\nwood_house = WUIBuilding{Float64}(1, 30, 30;\n    construction_type = :wood,\n    combustible_fraction = 0.7,\n    ignition_temperature = 300.0\n)\n\nmasonry_house = WUIBuilding{Float64}(2, 40, 30;\n    construction_type = :masonry,\n    combustible_fraction = 0.3,\n    ignition_temperature = 400.0\n)\n\nprintln(\"Wood building: combustible=$(wood_house.combustible_fraction)\")\nprintln(\"Masonry building: combustible=$(masonry_house.combustible_fraction)\")\n\nWood building: combustible=0.7\nMasonry building: combustible=0.3\n\n\n\n\nWUIGrid\nGrid of buildings for WUI simulation.\nstruct WUIGrid{T&lt;:AbstractFloat}\n    buildings::Vector{WUIBuilding{T}}\n    building_map::Matrix{Int}      # Building ID at each cell (0 = no building)\n    ignited::BitVector             # Whether each building has ignited\n    ignition_time::Vector{T}       # Time of ignition (-1 = not ignited)\nend\n\nncols, nrows = 100, 100\n\n# Create a few buildings\nbuildings = [\n    WUIBuilding{Float64}(1, 60, 40; construction_type = :wood),\n    WUIBuilding{Float64}(2, 65, 45; construction_type = :wood),\n    WUIBuilding{Float64}(3, 70, 40; construction_type = :masonry),\n    WUIBuilding{Float64}(4, 60, 50; construction_type = :mixed)\n]\n\nwui_grid = WUIGrid{Float64}(buildings, ncols, nrows)\n\nprintln(\"Total buildings: $(length(wui_grid.buildings))\")\n\nTotal buildings: 4\n\n\n\n\nBuildingIgnitionResult\nResult of a building ignition event.\nstruct BuildingIgnitionResult{T&lt;:AbstractFloat}\n    building_id::Int\n    ignition_time::T\n    ignition_source::Symbol    # :radiation, :ember, :flame_contact, :building_spread\n    ignition_probability::T\nend\n\n\nHamadaParameters\nParameters for the Hamada urban fire spread model.\nstruct HamadaParameters{T&lt;:AbstractFloat}\n    critical_separation::T      # Critical building separation (m)\n    wind_spread_factor::T       # Wind effect on spread\n    ember_generation_rate::T    # Ember generation rate\n    base_spread_rate::T         # Base spread rate between buildings\nend\n\nhamada = HamadaParameters{Float64}(\n    critical_separation = 10.0,\n    wind_spread_factor = 1.5,\n    ember_generation_rate = 0.1,\n    base_spread_rate = 1.0\n)\n\nHamadaParameters{Float64}(10.0, 1.5, 0.1, 1.0)",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>WUI & Suppression</span>"
    ]
  },
  {
    "objectID": "reference/wui-suppression.html#wui-functions",
    "href": "reference/wui-suppression.html#wui-functions",
    "title": "WUI & Suppression",
    "section": "WUI Functions",
    "text": "WUI Functions\n\ncompute_radiative_heat_flux\nCalculate radiative heat flux from fire to a building.\ncompute_radiative_heat_flux(flin::T, distance::T, flame_height::T) -&gt; T  # kW/m²\n\n# Heat flux vs distance for different fire intensities\ndistances = 5:5:50\nintensities = [500, 1000, 2000, 4000]\n\np = plot(xlabel = \"Distance (m)\", ylabel = \"Heat Flux (kW/m²)\",\n    title = \"Radiative Heat Flux from Fire\", legend = :topright)\n\nfor I in intensities\n    fluxes = [compute_radiative_heat_flux(Float64(I), Float64(d), 5.0) for d in distances]\n    plot!(p, distances, fluxes, label = \"I = $I kW/m\", linewidth = 2)\nend\n\nhline!(p, [12.5], linestyle = :dash, color = :red, label = \"Wood ignition threshold\")\np\n\n\n\n\n\n\ncompute_view_factor\nCalculate view factor for radiation calculation.\ncompute_view_factor(flame_height::T, distance::T) -&gt; T\n\n\nbuilding_ignition_probability\nCalculate probability of building ignition given heat flux and exposure time.\nbuilding_ignition_probability(building::WUIBuilding, heat_flux::T, exposure_time::T) -&gt; T\n\nwood = WUIBuilding{Float64}(1, 10, 10; construction_type = :wood)\nmasonry = WUIBuilding{Float64}(2, 10, 10; construction_type = :masonry)\n\nheat_fluxes = 5:5:50\nexposure = 10.0  # minutes\n\nwood_probs = [building_ignition_probability(wood, Float64(q), exposure) for q in heat_fluxes]\nmasonry_probs = [building_ignition_probability(masonry, Float64(q), exposure) for q in heat_fluxes]\n\nplot(heat_fluxes, [wood_probs masonry_probs],\n    xlabel = \"Heat Flux (kW/m²)\",\n    ylabel = \"Ignition Probability\",\n    title = \"Building Ignition Probability (10 min exposure)\",\n    label = [\"Wood\" \"Masonry\"],\n    linewidth = 2\n)\n\n\n\n\n\n\nhamada_spread_probability\nCalculate probability of fire spreading between buildings using Hamada model.\nhamada_spread_probability(source::WUIBuilding, target::WUIBuilding, params::HamadaParameters,\n    wind_speed::T, wind_direction::T, cellsize::T) -&gt; T\n\n\nupdate_wui_state!\nUpdate WUI state based on current fire conditions.\nupdate_wui_state!(wui_grid::WUIGrid, fire_state::FireState, weather, t::T, dt::T, rng) -&gt; Vector{BuildingIgnitionResult}\nReturns a vector of any buildings that ignited during this timestep.\n\n\nget_wui_statistics\nGet summary statistics from a WUI simulation.\nget_wui_statistics(wui_grid::WUIGrid) -&gt; NamedTuple\n\n\ncreate_building_grid\nCreate a regular grid of buildings.\ncreate_building_grid(::Type{T}, ncols, nrows, spacing, footprint, start_x, start_y;\n    construction_type = :mixed) -&gt; Vector{WUIBuilding{T}}\n\n# Create a 4x4 grid of buildings\nbuildings = create_building_grid(Float64, 100, 100, 15, 3, 60, 30;\n    construction_type = :wood)\n\nprintln(\"Created $(length(buildings)) buildings\")\n\nCreated 15 buildings",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>WUI & Suppression</span>"
    ]
  },
  {
    "objectID": "reference/wui-suppression.html#suppression-types",
    "href": "reference/wui-suppression.html#suppression-types",
    "title": "WUI & Suppression",
    "section": "Suppression Types",
    "text": "Suppression Types\n\nSuppressionResource\nA suppression resource (crew, engine, etc.).\nstruct SuppressionResource{T&lt;:AbstractFloat}\n    id::Int\n    resource_type::Symbol          # :hand_crew, :engine, :dozer, :aircraft\n    location_x::T                  # Current X location\n    location_y::T                  # Current Y location\n    line_production_rate::T        # Line production (ft/min)\n    effective_width::T             # Line width (ft)\n    status::Symbol                 # :available, :deployed, :resting\nend\nConstructor:\nSuppressionResource{T}(id, resource_type;\n    location_x = zero(T),\n    location_y = zero(T)\n)\nResource types have default production rates:\n\n\n\nType\nProduction Rate\nEffective Width\n\n\n\n\n:hand_crew\n30 ft/min\n6 ft\n\n\n:engine\n20 ft/min\n10 ft\n\n\n:dozer\n200 ft/min\n12 ft\n\n\n:aircraft\n500 ft/min\n50 ft\n\n\n\n\nhand_crew = SuppressionResource{Float64}(1, :hand_crew; location_x = 10.0, location_y = 10.0)\nengine = SuppressionResource{Float64}(2, :engine; location_x = 15.0, location_y = 10.0)\ndozer = SuppressionResource{Float64}(3, :dozer; location_x = 20.0, location_y = 10.0)\n\nprintln(\"Hand crew: $(hand_crew.line_production_rate) ft/min\")\nprintln(\"Engine: $(engine.line_production_rate) ft/min\")\nprintln(\"Dozer: $(dozer.line_production_rate) ft/min\")\n\nHand crew: 2.5 ft/min\nEngine: 5.0 ft/min\nDozer: 20.0 ft/min\n\n\n\n\nSuppressionState\nCurrent state of suppression activities.\nmutable struct SuppressionState{T&lt;:AbstractFloat}\n    resources::Vector{SuppressionResource{T}}\n    contained_cells::BitMatrix           # Cells with containment line\n    containment_effectiveness::Matrix{T} # Effectiveness (0-1, lower = more effective)\n    active_assignments::Dict{Int, Vector{Tuple{Int,Int}}}  # Resource assignments\n    total_line_constructed::T            # Total line length (ft)\nend\n\nncols, nrows = 100, 100\nsupp_state = SuppressionState{Float64}(ncols, nrows)\n\n# Add resources\nadd_resource!(supp_state, hand_crew)\nadd_resource!(supp_state, engine)\nadd_resource!(supp_state, dozer)\n\nprintln(\"Total resources: $(length(supp_state.resources))\")\n\nTotal resources: 3",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>WUI & Suppression</span>"
    ]
  },
  {
    "objectID": "reference/wui-suppression.html#suppression-functions",
    "href": "reference/wui-suppression.html#suppression-functions",
    "title": "WUI & Suppression",
    "section": "Suppression Functions",
    "text": "Suppression Functions\n\nadd_resource!\nAdd a suppression resource to the state.\nadd_resource!(state::SuppressionState, resource::SuppressionResource)\n\n\nconstruct_containment_line!\nBuild a containment line from start to target.\nconstruct_containment_line!(state::SuppressionState, resource::SuppressionResource,\n    start_ix, start_iy, target_ix, target_iy, dt::T, cellsize::T, t::T\n) -&gt; Tuple{Vector{Tuple{Int,Int}}, T}\nReturns (cells_built, length_built).\n\n# Build a containment line\ncells, length_ft = construct_containment_line!(\n    supp_state,\n    supp_state.resources[3],  # Dozer (fast)\n    30, 30,                   # Start\n    30, 50,                   # Target\n    10.0,                     # Time available (min)\n    30.0,                     # Cell size (ft)\n    0.0                       # Current time\n)\n\nprintln(\"Built $(length(cells)) cells ($(round(length_ft, digits=0)) ft)\")\n\nBuilt 0 cells (0.0 ft)\n\n\n\n\nassign_resource!\nAssign a resource to build line along specified targets.\nassign_resource!(state::SuppressionState, resource_id::Int, targets::Vector{Tuple{Int,Int}})\n\n\napply_containment!\nApply containment line effects to reduce fire spread.\napply_containment!(fire_state::FireState, suppression_state::SuppressionState)\n\n\nplan_indirect_attack\nPlan an indirect attack line ahead of the fire.\nplan_indirect_attack(fire_state::FireState, weather, buffer_cells::Int) -&gt; Vector{Tuple{Int,Int}}\n\n\nplan_direct_attack\nPlan a direct attack on the fire perimeter.\nplan_direct_attack(fire_state::FireState) -&gt; Vector{Tuple{Int,Int}}\n\n\nsimulate_with_suppression!\nRun simulation with suppression activities.\nsimulate_with_suppression!(\n    fire_state::FireState,\n    supp_state::SuppressionState,\n    fuel_ids, fuel_table, weather,\n    slope, aspect, t_start, t_stop;\n    kwargs...\n)\n\n\nget_suppression_statistics\nGet summary statistics from suppression operations.\nget_suppression_statistics(state::SuppressionState) -&gt; NamedTuple\n\nstats = get_suppression_statistics(supp_state)\n\nprintln(\"Suppression Statistics:\")\nprintln(\"  Total resources: $(stats.total_resources)\")\nprintln(\"  Available: $(stats.available)\")\nprintln(\"  Deployed: $(stats.deployed)\")\nprintln(\"  Contained cells: $(stats.contained_cells)\")\nprintln(\"  Total line: $(round(stats.total_line_feet, digits=0)) ft\")\n\nSuppression Statistics:\n  Total resources: 3\n  Available: 3\n  Deployed: 0\n  Contained cells: 0\n  Total line: 0.0 ft",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>WUI & Suppression</span>"
    ]
  },
  {
    "objectID": "reference/wui-suppression.html#example-fire-with-suppression",
    "href": "reference/wui-suppression.html#example-fire-with-suppression",
    "title": "WUI & Suppression",
    "section": "Example: Fire with Suppression",
    "text": "Example: Fire with Suppression\n\nncols, nrows = 100, 100\ncellsize = 30.0\n\nfire_state = FireState{Float64}(ncols, nrows, cellsize)\nsupp_state = SuppressionState{Float64}(ncols, nrows)\nfuel_table = create_standard_fuel_table(Float64)\nfuel_ids = fill(1, ncols, nrows)\nslope = zeros(Float64, ncols, nrows)\naspect = zeros(Float64, ncols, nrows)\n\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 10.0,\n    wind_direction = 270.0,\n    M1 = 0.06, M10 = 0.08, M100 = 0.10,\n    MLH = 0.60, MLW = 0.90\n)\n\n# Add a dozer\ndozer = SuppressionResource{Float64}(1, :dozer; location_x = 70.0, location_y = 50.0)\nadd_resource!(supp_state, dozer)\n\n# Pre-build containment line\nfor y in 30:70\n    supp_state.contained_cells[70, y] = true\n    supp_state.containment_effectiveness[70, y] = 0.1  # 90% reduction\nend\n\n# Ignite and run\nignite!(fire_state, 40, 50, 0.0)\n\nsimulate_with_suppression!(\n    fire_state, supp_state,\n    fuel_ids, fuel_table, weather,\n    slope, aspect, 0.0, 45.0\n)\n\n# Visualize\np = heatmap(fire_state.burned',\n    title = \"Fire with Containment Line\",\n    color = :YlOrRd,\n    aspect_ratio = 1\n)\n\n# Overlay containment line\ncontained_x = [ix for ix in 1:ncols for iy in 1:nrows if supp_state.contained_cells[ix, iy]]\ncontained_y = [iy for ix in 1:ncols for iy in 1:nrows if supp_state.contained_cells[ix, iy]]\nscatter!(p, contained_x, contained_y, color = :blue, markersize = 3, label = \"Containment\")\n\np",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>WUI & Suppression</span>"
    ]
  },
  {
    "objectID": "reference/wui-suppression.html#comparing-suppressed-vs.-unsuppressed",
    "href": "reference/wui-suppression.html#comparing-suppressed-vs.-unsuppressed",
    "title": "WUI & Suppression",
    "section": "Comparing Suppressed vs. Unsuppressed",
    "text": "Comparing Suppressed vs. Unsuppressed\n\n# Without suppression\nstate_no_supp = FireState{Float64}(ncols, nrows, cellsize)\nignite!(state_no_supp, 40, 50, 0.0)\nsimulate_uniform!(state_no_supp, 1, fuel_table, weather, 0.0, 0.0, 0.0, 45.0)\n\n# With suppression (already run above)\n\np1 = heatmap(state_no_supp.burned',\n    title = \"No Suppression\\n$(round(get_burned_area_acres(state_no_supp), digits=1)) acres\",\n    color = :YlOrRd, aspect_ratio = 1, colorbar = false)\n\np2 = heatmap(fire_state.burned',\n    title = \"With Containment\\n$(round(get_burned_area_acres(fire_state), digits=1)) acres\",\n    color = :YlOrRd, aspect_ratio = 1, colorbar = false)\n\nplot(p1, p2, layout = (1, 2), size = (700, 350))",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>WUI & Suppression</span>"
    ]
  },
  {
    "objectID": "reference/wui-suppression.html#wui-simulation-example",
    "href": "reference/wui-suppression.html#wui-simulation-example",
    "title": "WUI & Suppression",
    "section": "WUI Simulation Example",
    "text": "WUI Simulation Example\n\nncols, nrows = 100, 100\ncellsize = 30.0\n\n# Create fire state and landscape\nstate = FireState{Float64}(ncols, nrows, cellsize)\nfuel_ids = fill(1, ncols, nrows)\nslope = zeros(Float64, ncols, nrows)\naspect = zeros(Float64, ncols, nrows)\n\n# Create buildings in the northern part\nbuildings = WUIBuilding{Float64}[]\nid = 0\nfor ix in 40:12:80\n    for iy in 65:12:90\n        id += 1\n        ctype = rand([:wood, :wood, :masonry])\n        push!(buildings, WUIBuilding{Float64}(id, ix, iy; construction_type = ctype))\n    end\nend\n\nwui_grid = WUIGrid{Float64}(buildings, ncols, nrows)\n\n# Wind from south (pushing fire toward buildings)\nweather = ConstantWeather{Float64}(\n    wind_speed_mph = 12.0,\n    wind_direction = 180.0,\n    M1 = 0.05, M10 = 0.07, M100 = 0.09,\n    MLH = 0.50, MLW = 0.80\n)\n\n# Ignite in southern portion\nignite!(state, 60, 30, 0.0)\n\n# Run simulation\nsimulate_uniform!(state, 1, fuel_table, weather, 0.0, 0.0, 0.0, 60.0)\n\n# Update WUI state\nrng = MersenneTwister(42)\nt = 0.0\nwhile t &lt; 60.0\n    ignitions = update_wui_state!(wui_grid, state, weather, t, 1.0, rng)\n    for ig in ignitions\n        println(\"Building $(ig.building_id) ignited at t=$(round(ig.ignition_time, digits=1))\")\n    end\n    t += 1.0\nend\n\n# Visualize\np = heatmap(state.burned',\n    title = \"Fire Approaching WUI\",\n    color = :YlOrRd,\n    aspect_ratio = 1\n)\n\n# Add buildings\nbuilding_x = [b.ix for b in buildings]\nbuilding_y = [b.iy for b in buildings]\ncolors = [wui_grid.ignited[i] ? :red : :blue for i in 1:length(buildings)]\n\nscatter!(p, building_x, building_y,\n    color = colors,\n    markersize = 6,\n    markershape = :square,\n    label = false\n)\n\np\n\nBuilding 1 ignited at t=0.0\nBuilding 2 ignited at t=0.0\nBuilding 3 ignited at t=0.0\nBuilding 4 ignited at t=0.0\nBuilding 5 ignited at t=0.0\nBuilding 6 ignited at t=0.0\nBuilding 7 ignited at t=0.0\nBuilding 8 ignited at t=0.0\nBuilding 9 ignited at t=0.0\nBuilding 10 ignited at t=0.0\nBuilding 11 ignited at t=0.0\nBuilding 12 ignited at t=0.0\n\n\n\n\n\n\n# WUI Statistics\nstats = get_wui_statistics(wui_grid)\n\nprintln(\"WUI Results:\")\nprintln(\"  Total buildings: $(stats.total_buildings)\")\nprintln(\"  Ignited: $(stats.ignited_buildings)\")\nprintln(\"  Ignition rate: $(round(stats.ignition_fraction * 100, digits=1))%\")\nif stats.ignited_buildings &gt; 0\n    println(\"  First ignition: $(round(stats.first_ignition_time, digits=1)) min\")\n    println(\"  Last ignition: $(round(stats.last_ignition_time, digits=1)) min\")\nend\n\nWUI Results:\n  Total buildings: 12\n  Ignited: 12\n  Ignition rate: 100.0%\n  First ignition: 0.0 min\n  Last ignition: 0.0 min",
    "crumbs": [
      "Module Reference",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>WUI & Suppression</span>"
    ]
  },
  {
    "objectID": "api.html",
    "href": "api.html",
    "title": "API",
    "section": "",
    "text": "Types",
    "crumbs": [
      "API",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>API</span>"
    ]
  },
  {
    "objectID": "api.html#types",
    "href": "api.html#types",
    "title": "API",
    "section": "",
    "text": "BatchResult\n\n\nBatchResult{T&lt;:AbstractFloat}\nResult from a single batch job.\n\n\n\n\nBatchSimulationJob\n\n\nBatchSimulationJob{T&lt;:AbstractFloat}\nA single simulation job for batch processing.\n\n\n\n\nBuildingIgnitionResult\n\n\nBuildingIgnitionResult{T&lt;:AbstractFloat}\nResult of a building ignition calculation.\n\n\n\n\nCPUFireState\n\n\nFireState{T&lt;:AbstractFloat, A&lt;:AbstractMatrix{T}}\nComplete state of a fire simulation. Parameterized on element type T and array type A to support both CPU (Matrix{T}) and GPU arrays.\nFireState{T}(ncols, nrows, cellsize; xllcorner=zero(T), yllcorner=zero(T), padding=2, band_thickness=5)\nCreate a new fire simulation state with specified precision.\n\nArguments\n\nncols: Number of grid columns\nnrows: Number of grid rows\ncellsize: Cell size in feet\nxllcorner: X coordinate of lower-left corner (default 0.0)\nyllcorner: Y coordinate of lower-left corner (default 0.0)\npadding: Boundary padding for stencil operations (default 2)\nband_thickness: Narrow band half-width (default 5)\n\n\n\n\n\n\nCanopyGrid\n\n\nCanopyGrid{T&lt;:AbstractFloat}\nGrid of canopy properties for each cell.\nCanopyGrid{T}(ncols, nrows)\nCreate an empty canopy grid (no canopy).\nCanopyGrid{T}(ncols, nrows, cbd, cbh, cc, ch)\nCreate a uniform canopy grid.\n\n\n\n\nCanopyProperties\n\n\nCanopyProperties{T&lt;:AbstractFloat}\nCanopy fuel properties for a cell.\n\n\n\n\nConstantWeather\n\n\nConstantWeather{T&lt;:AbstractFloat}\nConstant (spatially and temporally uniform) weather conditions.\n\n\n\n\nContainmentLine\n\n\nContainmentLine{T&lt;:AbstractFloat}\nA fire containment line (fireline, retardant line, etc.).\nContainmentLine{T}(cells; effectiveness=0.9, width=6.0, construction_time=0.0, resource_id=0)\nCreate a containment line from a vector of cells.\n\n\n\n\nCrownFireResult\n\n\nCrownFireResult{T&lt;:AbstractFloat}\nResults from crown fire calculation.\n\n\n\n\nEllipticalSpread\n\n\nEllipticalSpread{T&lt;:AbstractFloat}\nElliptical fire spread parameters following Anderson (1982).\n\n\n\n\nEnsembleConfig\n\n\nEnsembleConfig{T&lt;:AbstractFloat}\nConfiguration for ensemble simulation runs.\n\n\n\n\nEnsembleMember\n\n\nEnsembleMember{T&lt;:AbstractFloat}\nResults from a single ensemble member simulation.\n\n\n\n\nEnsembleResult\n\n\nEnsembleResult{T&lt;:AbstractFloat}\nAggregated results from an ensemble of simulations.\n\n\n\n\nFireState\n\n\nFireState{T&lt;:AbstractFloat, A&lt;:AbstractMatrix{T}}\nComplete state of a fire simulation. Parameterized on element type T and array type A to support both CPU (Matrix{T}) and GPU arrays.\nFireState{T}(ncols, nrows, cellsize; xllcorner=zero(T), yllcorner=zero(T), padding=2, band_thickness=5)\nCreate a new fire simulation state with specified precision.\n\nArguments\n\nncols: Number of grid columns\nnrows: Number of grid rows\ncellsize: Cell size in feet\nxllcorner: X coordinate of lower-left corner (default 0.0)\nyllcorner: Y coordinate of lower-left corner (default 0.0)\npadding: Boundary padding for stencil operations (default 2)\nband_thickness: Narrow band half-width (default 5)\n\n\n\n\n\n\nFuelModel\n\n\nFuelModel{T&lt;:AbstractFloat}\nComplete fuel model with all computed Rothermel coefficients. Matches ELMFIRE’s FUELMODELTABLE_TYPE structure.\nThe 6 fuel size classes are:\n\n1-hour dead\n10-hour dead\n100-hour dead\nDynamic dead (transferred herbaceous)\nLive herbaceous\nLive woody\n\n\n\n\n\nFuelModelArray\n\n\nFuelModelArray{T&lt;:AbstractFloat}\nDense struct-of-arrays representation of fuel model coefficients for GPU-friendly lookup. Replaces the Dict-based FuelModelTable with array indexing.\nFields are stored as [fuel_index, moisture_class_index] matrices where:\n\nfuel_index maps from fuel ID via fuel_id_to_index\nmoisture_class_index = live_moisture_class - 29 (so class 30 → index 1, class 120 → index 91)\n\nNTuple fields are stored as 3D arrays [fuel_index, moisture_class_index, component].\nFuelModelArray(table::FuelModelTable{T}) -&gt; FuelModelArray{T}\nConvert a FuelModelTable to a dense FuelModelArray for GPU-friendly access.\n\nExamples\ntable = create_standard_fuel_table(Float64)\narr = FuelModelArray(table)\n\n\n\n\n\nFuelModelTable\n\n\nFuelModelTable{T&lt;:AbstractFloat}\n2D table of fuel models indexed by (fuelid, livemoisture_class). Live moisture class ranges from 30 to 120 (representing 30% to 120% moisture).\n\n\n\n\nGeoMetadata\n\n\nGeoMetadata{T&lt;:AbstractFloat}\nGeospatial metadata for a raster dataset.\n\n\n\n\nGeoRaster\n\n\nGeoRaster{T&lt;:AbstractFloat}\nA raster dataset with geospatial metadata.\n\n\n\n\nHamadaParameters\n\n\nHamadaParameters{T&lt;:AbstractFloat}\nParameters for the Hamada urban fire spread model.\nThe Hamada model describes fire spread between buildings based on separation distance, wind conditions, and building characteristics.\n\n\n\n\nLandscapeData\n\n\nLandscapeData{T&lt;:AbstractFloat}\nComplete landscape data for fire simulation including fuel, topography, and canopy.\n\n\n\n\nNarrowBand\n\n\nNarrowBand\nTracks the active cells near the fire front for efficient computation.\nThe narrow band contains cells within band_thickness cells of the fire front (where φ changes sign). Uses a BitMatrix for O(1) membership testing and a packed Vector for cache-friendly iteration.\n\n\n\n\nParallelConfig\n\n\nParallelConfig\nConfiguration for parallel execution.\n\n\n\n\nPerturbationConfig\n\n\nPerturbationConfig{T&lt;:AbstractFloat}\nConfiguration for stochastic parameter perturbations.\n\n\n\n\nRawFuelModel\n\n\nRawFuelModel{T&lt;:AbstractFloat}\nRaw fuel model parameters as read from CSV file before coefficient calculation.\n\n\n\n\nSimulationConfig\n\n\nSimulationConfig{T&lt;:AbstractFloat}\nConfiguration for full simulation with crown fire, spotting, and weather interpolation.\n\n\n\n\nSpotFire\n\n\nSpotFire{T&lt;:AbstractFloat}\nA spot fire ignition location.\n\n\n\n\nSpotFireTracker\n\n\nSpotFireTracker{T&lt;:AbstractFloat}\nTracks pending and active spot fires during simulation.\n\n\n\n\nSpottingParameters\n\n\nSpottingParameters{T&lt;:AbstractFloat}\nParameters controlling ember generation and transport.\n\n\n\n\nSpreadResult\n\n\nSpreadResult{T&lt;:AbstractFloat}\nResults from the Rothermel surface fire spread rate calculation.\n\n\n\n\nSuppressionResource\n\n\nSuppressionResource{T&lt;:AbstractFloat}\nA fire suppression resource (crew, engine, etc.).\n\n\n\n\nSuppressionState\n\n\nSuppressionState{T&lt;:AbstractFloat}\nComplete state of fire suppression activities.\nSuppressionState{T}(ncols::Int, nrows::Int)\nCreate an empty suppression state.\n\n\n\n\nThreadLocalState\n\n\nThreadLocalState{T&lt;:AbstractFloat, R&lt;:AbstractRNG}\nThread-local simulation state to avoid data races.\n\n\n\n\nWUIBuilding\n\n\nWUIBuilding{T&lt;:AbstractFloat}\nA building in the WUI that can be affected by wildfire.\n\n\n\n\nWUIGrid\n\n\nWUIGrid{T&lt;:AbstractFloat}\nGrid of buildings for WUI fire simulation.\nWUIGrid{T}(buildings::Vector{WUIBuilding{T}}, ncols::Int, nrows::Int)\nCreate a WUI grid from a vector of buildings.\nWUIGrid{T}(ncols::Int, nrows::Int)\nCreate an empty WUI grid.\n\n\n\n\nWeatherGrid\n\n\nWeatherGrid{T&lt;:AbstractFloat}\nA grid of weather values at a single time.\nWeatherGrid{T}(ncols, nrows, cellsize; xllcorner=zero(T), yllcorner=zero(T))\nCreate an empty weather grid.\nWeatherGrid{T}(weather::ConstantWeather{T}, ncols, nrows, cellsize)\nCreate a uniform weather grid from constant weather conditions.\n\n\n\n\nWeatherInterpolator\n\n\nWeatherInterpolator{T&lt;:AbstractFloat}\nHandles interpolation of weather data to simulation grid and time.\nWeatherInterpolator(\n    weather_series::WeatherTimeSeries{T},\n    sim_ncols::Int, sim_nrows::Int,\n    sim_cellsize::T,\n    sim_xllcorner::T = zero(T),\n    sim_yllcorner::T = zero(T)\n)\nCreate a weather interpolator for the given simulation grid.\n\n\n\n\nWeatherTimeSeries\n\n\nWeatherTimeSeries{T&lt;:AbstractFloat}\nA time series of weather grids.\nWeatherTimeSeries{T}(grids, times)\nCreate a weather time series from a vector of grids and times.\nWeatherTimeSeries{T}(weather::ConstantWeather{T}, ncols, nrows, cellsize, duration)\nCreate a constant weather time series.",
    "crumbs": [
      "API",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>API</span>"
    ]
  },
  {
    "objectID": "api.html#functions",
    "href": "api.html#functions",
    "title": "API",
    "section": "Functions",
    "text": "Functions\n\nactive_mask\n\n\nactive_mask(nb::NarrowBand, nx::Int, ny::Int) -&gt; BitMatrix\nCreate a dense BitMatrix indicating which cells are in the active narrow band. Useful for GPU kernels that need a mask instead of an index list.\n\nExamples\nmask = active_mask(state.narrow_band, size(state.phi)...)\n\n\n\n\n\nadd_raw_model! {#add_raw_model!}\n\n\nadd_raw_model!(table::FuelModelTable{T}, raw::RawFuelModel) where {T}\nAdd a raw fuel model to the table and compute coefficients for all live moisture classes (30-120).\n\n\n\n\nadd_resource! {#add_resource!}\n\n\nadd_resource!(state::SuppressionState{T}, resource::SuppressionResource{T})\nAdd a suppression resource to the state.\n\n\n\n\nadd_spot_fires! {#add_spot_fires!}\n\n\nadd_spot_fires!(tracker::SpotFireTracker{T}, fires::Vector{SpotFire{T}})\nAdd new spot fires to the pending queue.\n\n\n\n\naggregate_ensemble_statistics! {#aggregate_ensemble_statistics!}\n\n\naggregate_ensemble_statistics!(result::EnsembleResult{T})\nCompute aggregate statistics from ensemble members.\n\n\n\n\napply_containment! {#apply_containment!}\n\n\napply_containment!(fire_state::FireState{T}, suppression_state::SuppressionState{T})\nApply containment effects to the fire state by reducing spread velocities at contained cells.\n\n\n\n\nassign_resource! {#assign_resource!}\n\n\nassign_resource!(\n    suppression::SuppressionState{T},\n    resource_id::Int,\n    targets::Vector{Tuple{Int,Int}}\n)\nAssign a resource to construct lines at target locations.\n\n\n\n\nbuilding_ignition_probability\n\n\nbuilding_ignition_probability(\n    building::WUIBuilding{T},\n    heat_flux::T,\n    exposure_time::T\n) -&gt; T\nCalculate the probability of building ignition given heat flux and exposure time.\nUses a dose-response model based on heat flux accumulation.\n\nArguments\n\nbuilding: Building properties\nheat_flux: Incident heat flux (kW/m²)\nexposure_time: Duration of exposure (minutes)\n\n\n\nReturns\n\nIgnition probability (0-1)\n\n\n\n\n\n\ncalculate_tanslp2\n\n\ncalculate_tanslp2(slope_degrees::T) -&gt; T\nCalculate tan²(slope) from slope in degrees.\n\n\n\n\ncheck_convergence\n\n\ncheck_convergence(result::EnsembleResult{T}; threshold::T = T(0.001)) -&gt; Bool\nCheck if the ensemble has converged based on burn probability changes.\n\n\n\n\ncombined_fireline_intensity\n\n\ncombined_fireline_intensity(\n    surface_result::SpreadResult{T},\n    crown_result::CrownFireResult{T},\n    fm::FuelModel{T}\n) -&gt; T\nCalculate the combined fireline intensity (kW/m) for surface and crown fire.\n\n\n\n\ncombined_spread_rate\n\n\ncombined_spread_rate(\n    surface_result::SpreadResult{T},\n    crown_result::CrownFireResult{T}\n) -&gt; T\nCalculate the combined spread rate considering both surface and crown fire.\nFor active crown fires, returns the crown fire spread rate. For passive crown fires, returns surface spread rate (crown fire doesn’t add to ROS). For surface fires only, returns the surface spread rate.\n\n\n\n\ncompute_burn_probability\n\n\ncompute_burn_probability(members::Vector{EnsembleMember{T}}, ncols::Int, nrows::Int) -&gt; Matrix{T}\nCompute burn probability from ensemble members.\n\n\n\n\ncompute_cfl_timestep\n\n\ncompute_cfl_timestep(\n    ux::AbstractMatrix{T},\n    uy::AbstractMatrix{T},\n    active_cells::AbstractVector{CartesianIndex{2}},\n    dx::T,\n    dt_current::T;\n    target_cfl::T = T(0.9),\n    dt_max::T = T(10)\n) -&gt; T\nCompute the adaptive timestep based on the CFL condition.\nCFL = umax * dt / dx &lt; target_cfl\nImplementation follows elmfire_level_set.f90:2010-2027.\n\n\n\n\ncompute_fuel_model\n\n\ncompute_fuel_model(raw::RawFuelModel{T}, live_moisture_class::Int) -&gt; FuelModel{T}\nCompute all Rothermel coefficients from raw fuel model data.\nFor dynamic fuel models, the live herbaceous fuel is partitioned between dead and live classes based on the live moisture class (30-120).\nImplementation follows elmfire_init.f90:786-880.\n\n\n\n\ncompute_mean_arrival_time\n\n\ncompute_mean_arrival_time(members::Vector{EnsembleMember{T}}, ncols::Int, nrows::Int) -&gt; Tuple{Matrix{T}, Matrix{T}}\nCompute mean and standard deviation of time of arrival from ensemble members. Returns (meantoa, stdtoa).\n\n\n\n\ncompute_normal\n\n\ncompute_normal(\n    phi::AbstractMatrix{T},\n    ix::Int, iy::Int,\n    dx::T\n) -&gt; Tuple{T, T}\nCompute the unit normal vector to the level set at cell (ix, iy). The normal points in the direction of increasing φ (outward from fire).\nUses central differences.\n\n\n\n\ncompute_num_embers\n\n\ncompute_num_embers(\n    params::SpottingParameters{T},\n    flin::T,\n    crown_fire_type::Int,\n    dt::T,\n    cellsize::T;\n    rng::AbstractRNG = Random.default_rng()\n) -&gt; Int\nCalculate the number of embers to generate for a burning cell.\n\n\n\n\ncompute_radiative_heat_flux\n\n\ncompute_radiative_heat_flux(flin::T, distance::T, flame_length::T) -&gt; T\nCompute radiative heat flux (kW/m²) at a given distance from the fire.\nBased on the solid flame model with view factor calculations.\n\nArguments\n\nflin: Fireline intensity (kW/m)\ndistance: Distance from fire front (m)\nflame_length: Flame length (m)\n\n\n\nReturns\n\nHeat flux in kW/m²\n\n\n\n\n\n\ncompute_slope_aspect\n\n\ncompute_slope_aspect(dem::GeoRaster{T}) -&gt; Tuple{Matrix{T}, Matrix{T}}\nCompute slope (degrees) and aspect (degrees) from a DEM using a 3x3 moving window.\nAspect is in degrees clockwise from north (0-360), with flat areas set to 0.\ncompute_slope_aspect(elevation::Matrix{T}, cellsize::T) -&gt; Tuple{Matrix{T}, Matrix{T}}\nCompute slope and aspect from an elevation matrix.\n\n\n\n\ncompute_view_factor\n\n\ncompute_view_factor(flame_height::T, distance::T) -&gt; T\nCompute the view factor between a vertical rectangular flame and a point.\nUses the approximation for a vertical radiating surface.\n\nArguments\n\nflame_height: Height of the flame (m)\ndistance: Horizontal distance to the target point (m)\n\n\n\n\n\n\nconstruct_containment_line! {#construct_containment_line!}\n\n\nconstruct_containment_line!(\n    state::SuppressionState{T},\n    resource::SuppressionResource{T},\n    start_ix::Int, start_iy::Int,\n    target_ix::Int, target_iy::Int,\n    dt::T,\n    cellsize::T,\n    t::T\n) -&gt; Tuple{Vector{Tuple{Int,Int}}, T}\nConstruct a containment line from start to target (or as far as possible in dt).\n\nArguments\n\nstate: Suppression state (modified in place)\nresource: Resource constructing the line\nstart_ix, start_iy: Starting grid coordinates\ntarget_ix, target_iy: Target grid coordinates\ndt: Time step (minutes)\ncellsize: Grid cell size (ft)\nt: Current simulation time (minutes)\n\n\n\nReturns\n\nTuple of (cellsconstructed, lengthconstructed)\n\n\n\n\n\n\ncreate_building_grid\n\n\ncreate_building_grid(\n    ncols::Int, nrows::Int,\n    building_spacing::Int,\n    building_footprint::Int,\n    origin_x::Int, origin_y::Int;\n    construction_type::Symbol = :wood\n) -&gt; Vector{WUIBuilding{T}}\nCreate a regular grid of buildings for WUI simulation.\n\nArguments\n\nncols, nrows: Grid dimensions\nbuilding_spacing: Spacing between buildings (cells)\nbuilding_footprint: Building footprint size (cells)\norigin_x, origin_y: Starting position for building grid\nconstruction_type: Default construction type for buildings\n\n\n\n\n\n\ncreate_constant_interpolator\n\n\ncreate_constant_interpolator(\n    weather::ConstantWeather{T},\n    sim_ncols::Int, sim_nrows::Int,\n    sim_cellsize::T\n) -&gt; WeatherInterpolator{T}\nCreate a weather interpolator for constant weather conditions.\n\n\n\n\ncreate_grid_mapping\n\n\ncreate_grid_mapping(\n    weather_grid::WeatherGrid{T},\n    sim_ncols::Int, sim_nrows::Int,\n    sim_cellsize::T,\n    sim_xllcorner::T,\n    sim_yllcorner::T\n) -&gt; Tuple{Vector{Int}, Vector{Int}}\nCreate mapping from simulation grid to weather grid indices.\nReturns (icolweather, irowweather) vectors such that simulation cell (ix, iy) maps to weather cell (icolweather[ix], irowweather[iy]).\n\n\n\n\ncreate_standard_fuel_table\n\n\ncreate_standard_fuel_table(::Type{T}) -&gt; FuelModelTable{T}\nCreate a fuel model table with the standard FBFM 1-13 models plus non-burnable.\n\n\n\n\ncreate_thread_local_states\n\n\ncreate_thread_local_states(template::FireState{T}, n::Int) -&gt; Vector{ThreadLocalState{T, MersenneTwister}}\nCreate n thread-local states from a template.\n\n\n\n\ncritical_fireline_intensity\n\n\ncritical_fireline_intensity(cbh::T, foliar_moisture::T) -&gt; T\nCalculate the critical fireline intensity (kW/m) needed to initiate crown fire.\nUses Van Wagner (1977) criterion: I_crit = (0.01 * CBH * (460 + 26 * FMC))^1.5\n\nArguments\n\ncbh: Canopy base height (m)\nfoliar_moisture: Foliar moisture content (%, e.g., 100 for 100%)\n\n\n\nReturns\n\nCritical fireline intensity (kW/m)\n\n\n\n\n\n\ncrown_spread_rate\n\n\ncrown_spread_rate(\n    canopy::CanopyProperties{T},\n    flin_surface::T,\n    ws20::T,\n    m1::T,\n    vs0::T;\n    crown_fire_adj::T = one(T),\n    spread_rate_limit::T = T(1000),\n    critical_canopy_cover::T = T(0.4)\n) -&gt; CrownFireResult{T}\nCalculate crown fire spread rate using the Cruz (2005) model.\n\nArguments\n\ncanopy: Canopy fuel properties\nflin_surface: Surface fireline intensity (kW/m)\nws20: 20-ft wind speed (mph)\nm1: 1-hour dead fuel moisture (fraction)\nvs0: Base surface spread rate (ft/min)\ncrown_fire_adj: Crown fire adjustment factor (default 1.0)\nspread_rate_limit: Maximum crown fire spread rate (ft/min)\ncritical_canopy_cover: Minimum canopy cover for active crown fire\n\n\n\nReturns\n\nCrownFireResult with crown fire type, spread rate, and related values\n\nImplementation follows elmfire_spread_rate.f90:136-211.\n\n\n\n\n\nelliptical_spread\n\n\nelliptical_spread(velocity::T, effective_windspeed::T) -&gt; EllipticalSpread{T}\nCalculate elliptical fire spread dimensions from the head fire rate and effective windspeed.\nUses Anderson (1982) length-to-breadth ratio: LB = 0.936 * exp(0.2566 * U) + 0.461 * exp(-0.1548 * U) - 0.397\nWhere U is effective windspeed in mi/h.\n\n\n\n\nfind_time_indices\n\n\nfind_time_indices(wts::WeatherTimeSeries{T}, t::T) -&gt; Tuple{Int, Int, T}\nFind the indices and interpolation weight for time t.\nReturns (ilo, ihi, f) where the interpolated value is: value = (1-f) * grids[i*lo] + f * grids[i*hi]\n\n\n\n\ngenerate_spot_fires\n\n\ngenerate_spot_fires(\n    ix0::Int, iy0::Int,\n    flin::T,\n    ws20::T,\n    wd20::T,\n    crown_fire_type::Int,\n    params::SpottingParameters{T},\n    cellsize::T,\n    ncols::Int, nrows::Int,\n    time_now::T,\n    burned::BitMatrix;\n    use_sardoy::Bool = false,\n    rng::AbstractRNG = Random.default_rng()\n) -&gt; Vector{SpotFire{T}}\nGenerate potential spot fire locations from a burning cell.\n\nArguments\n\nix0, iy0: Source cell grid indices\nflin: Fireline intensity (kW/m)\nws20: 20-ft wind speed (mph)\nwd20: Wind direction (degrees, FROM convention)\ncrown_fire_type: 0 = surface, 1 = passive crown, 2 = active crown\nparams: Spotting parameters\ncellsize: Cell size (ft)\nncols, nrows: Grid dimensions\ntime_now: Current simulation time (minutes)\nburned: Matrix of burned cells\nuse_sardoy: Use Sardoy model for distribution parameters\nrng: Random number generator\n\n\n\nReturns\n\nVector of potential spot fire locations (may be empty)\n\n\n\n\n\n\ngeo_to_grid\n\n\ngeo_to_grid(x::T, y::T, metadata::GeoMetadata{T}) -&gt; Tuple{Int, Int}\nConvert geographic coordinates to grid indices.\n\n\n\n\nget_active_cells\n\n\nget_active_cells(nb::NarrowBand) -&gt; AbstractVector{CartesianIndex{2}}\nGet a view of active cell indices for iteration. Zero-allocation.\n\n\n\n\nget_burned_area\n\n\nget_burned_area(state::FireState{T}) -&gt; T\nGet the total burned area in square feet.\n\n\n\n\nget_burned_area_acres\n\n\nget_burned_area_acres(state::FireState{T}) -&gt; T\nGet the total burned area in acres.\n\n\n\n\nget_canopy_properties\n\n\nget_canopy_properties(grid::CanopyGrid{T}, ix::Int, iy::Int) -&gt; CanopyProperties{T}\nGet canopy properties for a specific cell.\n\n\n\n\nget_exceedance_probability\n\n\nget_exceedance_probability(result::EnsembleResult{T}, threshold_acres::T) -&gt; T\nCalculate the probability that burned area exceeds a threshold.\n\n\n\n\nget_fire_perimeter\n\n\nget_fire_perimeter(state::FireState) -&gt; Vector{Tuple{Int, Int}}\nGet the grid coordinates of cells on the fire perimeter (burned cells adjacent to unburned).\n\n\n\n\nget_fuel_model\n\n\nget_fuel_model(table::FuelModelTable, fuel_id::Int, live_moisture::AbstractFloat) -&gt; FuelModel\nGet the fuel model for the given fuel ID and live moisture content. Live moisture is clamped to [30, 120] and rounded to nearest integer.\nget_fuel_model(table::FuelModelTable, fuel_id::Int, live_moisture_class::Int) -&gt; FuelModel\nGet the fuel model for the given fuel ID and live moisture class (30-120).\n\n\n\n\nget_percentile_fire\n\n\nget_percentile_fire(result::EnsembleResult{T}, percentile::T) -&gt; Union{Nothing, EnsembleMember{T}}\nGet the ensemble member closest to a given percentile of burned area.\n\n\n\n\nget_ready_ignitions! {#get_ready_ignitions!}\n\n\nget_ready_ignitions!(tracker::SpotFireTracker{T}, time_now::T) -&gt; Vector{Tuple{Int,Int}}\nGet spot fires that are ready to ignite and remove them from pending queue.\nReturns grid indices of cells to ignite.\n\n\n\n\nget_suppression_statistics\n\n\nget_suppression_statistics(suppression::SuppressionState{T}) -&gt; NamedTuple\nGet summary statistics for suppression activities.\n\n\n\n\nget_weather_at\n\n\nget_weather_at(interp::WeatherInterpolator{T}, ix::Int, iy::Int, t::T) -&gt; NamedTuple\nGet interpolated weather values at simulation grid cell (ix, iy) and time t.\nReturns named tuple with fields: ws, wd, m1, m10, m100, mlh, mlw\n\n\n\n\nget_wui_statistics\n\n\nget_wui_statistics(wui_grid::WUIGrid{T}) -&gt; NamedTuple\nGet summary statistics for the WUI simulation.\n\n\n\n\ngrid_to_geo\n\n\ngrid_to_geo(ix::Int, iy::Int, metadata::GeoMetadata{T}) -&gt; Tuple{T, T}\nConvert grid indices to geographic coordinates (cell center).\n\n\n\n\ngrid_to_padded\n\n\ngrid_to_padded(state::FireState, ix::Int, iy::Int) -&gt; Tuple{Int, Int}\nConvert grid coordinates to padded array coordinates.\n\n\n\n\nhalf_superbee\n\n\nhalf_superbee(r::T) -&gt; T\nSuperbee flux limiter function (half-superbee variant). Returns ψ(r)/2 where ψ is the Superbee limiter.\nUsed for second-order upwind schemes to limit gradients and prevent oscillations.\nImplementation matches elmfire_level_set.f90:1533-1541.\n\n\n\n\nhamada_spread_probability\n\n\nhamada_spread_probability(\n    source::WUIBuilding{T},\n    target::WUIBuilding{T},\n    params::HamadaParameters{T},\n    wind_speed::T,\n    wind_direction::T,\n    cellsize::T\n) -&gt; T\nCalculate the probability of fire spreading between buildings using the Hamada model.\n\nArguments\n\nsource: Building that is on fire\ntarget: Potential target building\nparams: Hamada model parameters\nwind_speed: Wind speed (mph)\nwind_direction: Wind direction (degrees, FROM)\ncellsize: Grid cell size (ft)\n\n\n\n\n\n\nignite! {#ignite!}\n\n\nignite!(state::FireState{T}, ix::Int, iy::Int, t::T)\nIgnite a cell at grid coordinates (ix, iy) at time t. Sets up the level set as a signed distance function near the ignition point.\n\n\n\n\nignite_circle! {#ignite_circle!}\n\n\nignite_circle!(state::FireState{T}, center_x::Int, center_y::Int, radius_cells::T, t::T)\nIgnite all cells within a circle of given radius (in grid cells) centered at (centerx, centery).\n\n\n\n\nignite_point! {#ignite_point!}\n\n\nignite_point!(state::FireState{T}, x::T, y::T, t::T)\nIgnite a cell at world coordinates (x, y) at time t.\n\n\n\n\ninitialize_circular_fire! {#initialize_circular_fire!}\n\n\ninitialize_circular_fire!(\n    phi::AbstractMatrix{T},\n    center_x::Int, center_y::Int,\n    radius_cells::T,\n    dx::T\n)\nInitialize the level set with a circular fire of given radius centered at (centerx, centery).\n\n\n\n\ninitialize_phi! {#initialize_phi!}\n\n\ninitialize_phi!(phi::AbstractMatrix{T}, ignition_points::Vector{Tuple{Int,Int}}, dx::T)\nInitialize the level set field φ with signed distance from ignition points.\nφ &lt; 0 inside the fire (burned) φ &gt; 0 outside the fire (unburned)\n\n\n\n\ninterpolate_wind_direction\n\n\ninterpolate_wind_direction(wd1::T, wd2::T, f::T) -&gt; T\nInterpolate wind direction, handling the 0°/360° wrap-around.\n\n\n\n\nisnonburnable\n\n\nisnonburnable(fm::FuelModel) -&gt; Bool\nCheck if a fuel model is non-burnable (fuel model 256 or similar).\n\n\n\n\nlevel_set_step! {#level_set_step!}\n\n\nlevel_set_step!(\n    phi::AbstractMatrix{T},\n    phi_old::AbstractMatrix{T},\n    ux::AbstractMatrix{T},\n    uy::AbstractMatrix{T},\n    active_cells::AbstractVector{CartesianIndex{2}},\n    dt::T,\n    dx::T\n)\nPerform one complete level set propagation step using RK2.\n\nCopy phi to phi_old\nPerform RK2 stage 1\nPerform RK2 stage 2\n\n\n\n\n\nlimit_gradients\n\n\nlimit_gradients(\n    phi::AbstractMatrix{T},\n    ux::T, uy::T,\n    ix::Int, iy::Int,\n    rcellsize::T\n) -&gt; Tuple{T, T}\nCalculate flux-limited gradients ∂φ/∂x and ∂φ/∂y at cell (ix, iy).\nUses the Superbee flux limiter with upwind differencing based on the velocity direction (ux, uy).\nImplementation follows elmfire_level_set.f90:2040-2118.\n\nArguments\n\nphi: Level set field (with boundary padding)\nux, uy: Velocity components at this cell\nix, iy: Cell indices (1-based, assuming 2-cell padding)\nrcellsize: Reciprocal of cell size (1/dx)\n\n\n\nReturns\n\n(dphidx, dphidy): Flux-limited gradients\n\n\n\n\n\n\nload_fuel_models\n\n\nload_fuel_models(::Type{T}, filepath::AbstractString) -&gt; FuelModelTable{T}\nLoad fuel models from a CSV file and compute all coefficients with specified precision.\nThe file should be in ELMFIRE fuel_models.csv format.\nload_fuel_models(::Type{T}) -&gt; FuelModelTable{T}\nLoad fuel models from the default ELMFIRE fuel_models.csv bundled with the package.\n\n\n\n\nlognormal_params\n\n\nlognormal_params(mean::T, normalized_variance::T) -&gt; Tuple{T, T}\nConvert mean and normalized variance to lognormal μ and σ parameters.\nThe normalized variance is defined as variance / mean².\n\n\n\n\nmoisture_damping\n\n\nmoisture_damping(r::T) -&gt; T\nCalculate the moisture damping coefficient ηm. Formula: ηm = 1 - 2.59r + 5.11r² - 3.52r³\nWhere r = M/M_ex (moisture ratio to extinction moisture).\nImplementation follows Rothermel (1972) equation.\n\n\n\n\npadded_to_grid\n\n\npadded_to_grid(state::FireState, px::Int, py::Int) -&gt; Tuple{Int, Int}\nConvert padded array coordinates to grid coordinates.\n\n\n\n\nparallel_map\n\n\nparallel_map(f, items::AbstractVector; n_threads::Int = 0)\nApply function f to each item in parallel.\n\n\n\n\nparallel_reduce\n\n\nparallel_reduce(f, g, items::AbstractVector; init, n_threads::Int = 0)\nApply function f to each item and reduce with g.\n\nArguments\n\nf: Map function to apply to each item\ng: Reduce function to combine results (must be associative)\nitems: Items to process\ninit: Initial value for reduction\n\n\n\n\n\n\nparse_fuel_model_line\n\n\nparse_fuel_model_line(::Type{T}, line::AbstractString) -&gt; RawFuelModel{T}\nParse a single line from the fuel_models.csv file with specified precision.\nCSV format: fuelid, name, dynamic, W01hr, W010hr, W0100hr, W0herb, W0woody, SIG1hr, SIGherb, SIGwoody, delta, mexdead, hoc\nExample line: 1,FBFM01,.FALSE.,0.034,0,0,0,0,3500,9999,9999,1,12,8000\n\n\n\n\nperturb_ignition\n\n\nperturb_ignition(ix::Int, iy::Int, radius::T, ncols::Int, nrows::Int, rng::AbstractRNG) -&gt; Tuple{Int, Int}\nPerturb ignition location within a given radius.\n\n\n\n\nperturb_weather\n\n\nperturb_weather(weather::ConstantWeather{T}, config::PerturbationConfig{T}, rng::AbstractRNG) -&gt; ConstantWeather{T}\nApply stochastic perturbations to weather conditions.\n\n\n\n\nplan_direct_attack\n\n\nplan_direct_attack(fire_state::FireState{T}) -&gt; Vector{Tuple{Int,Int}}\nPlan a direct attack on the current fire perimeter.\n\n\n\n\nplan_indirect_attack\n\n\nplan_indirect_attack(\n    fire_state::FireState{T},\n    weather::ConstantWeather{T},\n    buffer_distance::Int\n) -&gt; Vector{Tuple{Int,Int}}\nPlan an indirect attack line ahead of the fire front.\n\nArguments\n\nfire_state: Current fire state\nweather: Weather conditions for wind direction\nbuffer_distance: Distance ahead of fire front (cells)\n\n\n\nReturns\n\nVector of grid cells for the planned line\n\n\n\n\n\n\nread_dem\n\n\nread_dem(::Type{T}, path::String) -&gt; GeoRaster{T}\nRead a Digital Elevation Model raster.\n\n\n\n\nread_fuel_raster\n\n\nread_fuel_raster(::Type{T}, path::String) -&gt; Tuple{Matrix{Int}, GeoMetadata{T}}\nRead a fuel model raster (integer fuel IDs) and return the matrix with metadata.\n\n\n\n\nread_geotiff\n\n\nread_geotiff(::Type{T}, path::String) -&gt; GeoRaster{T}\nRead a GeoTIFF file and return a GeoRaster with the specified precision.\n\nArguments\n\nT: Element type for the raster data (e.g., Float64, Float32)\npath: Path to the GeoTIFF file\n\n\n\n\n\n\nread_landscape\n\n\nread_landscape(::Type{T}, fuel_path, dem_path;\n               cbd_path=nothing, cbh_path=nothing, cc_path=nothing, ch_path=nothing\n) -&gt; LandscapeData{T}\nRead a complete landscape dataset from GeoTIFF files.\n\nArguments\n\nT: Element type for the data\nfuel_path: Path to fuel model ID raster\ndem_path: Path to DEM raster\ncbd_path: Optional path to canopy bulk density raster (kg/m³)\ncbh_path: Optional path to canopy base height raster (m)\ncc_path: Optional path to canopy cover raster (fraction 0-1)\nch_path: Optional path to canopy height raster (m)\n\n\n\n\n\n\nresample_to_match\n\n\nresample_to_match(source::GeoRaster{T}, target_metadata::GeoMetadata{T}) -&gt; GeoRaster{T}\nResample a raster to match the resolution and extent of another. Uses nearest-neighbor interpolation.\n\n\n\n\nreset! {#reset!}\n\n\nreset!(state::FireState{T})\nReset a FireState to initial conditions for reuse in ensemble simulations.\n\n\n\n\nrk2_step! {#rk2_step!}\n\n\nrk2_step!(\n    phi::AbstractMatrix{T},\n    phi_old::AbstractMatrix{T},\n    ux::AbstractMatrix{T},\n    uy::AbstractMatrix{T},\n    active_cells::AbstractVector{CartesianIndex{2}},\n    dt::T,\n    dx::T,\n    stage::Int\n)\nPerform one stage of the 2-stage Runge-Kutta time integration.\nStage 1: φ^(1) = φ^n - dt(ux∂φ/∂x + uy∂φ/∂y) Stage 2: φ^(n+1) = 0.5(φ^n + φ^(1) - dt(ux∂φ/∂x + uy*∂φ/∂y))\nImplementation follows elmfire_level_set.f90:1957-1983.\n\n\n\n\nrun_batch_simulations\n\n\nrun_batch_simulations(\n    jobs::Vector{BatchSimulationJob{T}},\n    state_template::FireState{T},\n    fuel_ids::AbstractMatrix{Int},\n    fuel_table::FuelModelTable{T},\n    slope::AbstractMatrix{T},\n    aspect::AbstractMatrix{T};\n    canopy::Union{Nothing, CanopyGrid{T}} = nothing,\n    config::SimulationConfig{T} = SimulationConfig{T}(),\n    show_progress::Bool = true\n) -&gt; Vector{BatchResult{T}}\nRun a batch of independent simulations in parallel.\nThis is useful for running multiple scenarios with different ignition points or weather conditions.\n\n\n\n\nrun_ensemble! {#run_ensemble!}\n\n\nrun_ensemble!(\n    config::EnsembleConfig{T},\n    state_template::FireState{T},\n    fuel_ids::AbstractMatrix{Int},\n    fuel_table::FuelModelTable{T},\n    weather::ConstantWeather{T},\n    slope::AbstractMatrix{T},\n    aspect::AbstractMatrix{T},\n    ignition_ix::Int,\n    ignition_iy::Int,\n    t_start::T,\n    t_stop::T;\n    canopy::Union{Nothing, CanopyGrid{T}} = nothing,\n    show_progress::Bool = true,\n    callback::Union{Nothing, Function} = nothing\n) -&gt; EnsembleResult{T}\nRun a Monte Carlo ensemble of fire simulations.\n\nArguments\n\nconfig: Ensemble configuration\nstate_template: Template FireState to clone for each simulation\nfuel_ids: Matrix of fuel model IDs\nfuel_table: Fuel model lookup table\nweather: Base weather conditions (will be perturbed)\nslope: Slope in degrees\naspect: Aspect in degrees\nignition_ix, ignition_iy: Grid coordinates of ignition point\nt_start, t_stop: Simulation time range (minutes)\ncanopy: Optional canopy grid for crown fire\nshow_progress: Show progress bar (default true)\ncallback: Optional callback(member_id, state) called after each member completes\n\n\n\n\n\n\nrun_ensemble_threaded! {#run_ensemble_threaded!}\n\n\nrun_ensemble_threaded!(\n    config::EnsembleConfig{T},\n    state_template::FireState{T},\n    fuel_ids::AbstractMatrix{Int},\n    fuel_table::FuelModelTable{T},\n    weather::ConstantWeather{T},\n    slope::AbstractMatrix{T},\n    aspect::AbstractMatrix{T},\n    ignition_ix::Int,\n    ignition_iy::Int,\n    t_start::T,\n    t_stop::T;\n    canopy::Union{Nothing, CanopyGrid{T}} = nothing,\n    parallel_config::ParallelConfig = ParallelConfig(),\n    show_progress::Bool = true,\n    callback::Union{Nothing, Function} = nothing\n) -&gt; EnsembleResult{T}\nRun a Monte Carlo ensemble using multiple threads.\n\nArguments\nSame as run_ensemble! with additional:\n\nparallel_config: Configuration for parallel execution\n\n\n\n\n\n\nsample_lognormal\n\n\nsample_lognormal(mu::T, sigma::T, rng::AbstractRNG) -&gt; T\nSample from a lognormal distribution with given μ and σ.\n\n\n\n\nsardoy_parameters\n\n\nsardoy_parameters(ws::T, flin::T) -&gt; NTuple{4,T}\nCalculate spotting distance distribution parameters using the Sardoy (2008) model.\n\nArguments\n\nws: 20-ft wind speed (mph)\nflin: Fireline intensity (kW/m)\n\n\n\nReturns\n\n(mu_dist, sigma_dist, mu_spanwise, sigma_spanwise): Lognormal parameters for downwind and crosswind distributions\n\n\n\n\n\n\nsimulate! {#simulate!}\n\n\nsimulate!(\n    state::FireState{T},\n    fuel_ids::AbstractMatrix{Int},\n    fuel_table::FuelModelTable{T},\n    weather::ConstantWeather{T},\n    slope::AbstractMatrix{T},\n    aspect::AbstractMatrix{T},\n    t_start::T,\n    t_stop::T;\n    dt_initial::T = one(T),\n    target_cfl::T = T(0.9),\n    dt_max::T = T(10),\n    spread_rate_adj::T = one(T),\n    callback::Union{Nothing, Function} = nothing\n)\nRun the fire simulation from tstart to tstop.\n\nArguments\n\nstate: Fire state (modified in place)\nfuel_ids: Matrix of fuel model IDs for each cell\nfuel_table: Fuel model lookup table\nweather: Weather conditions\nslope: Slope in degrees for each cell\naspect: Aspect direction in degrees for each cell\nt_start: Start time (minutes)\nt_stop: Stop time (minutes)\ndt_initial: Initial timestep (minutes, default 1.0)\ntarget_cfl: Target CFL number (default 0.9)\ndt_max: Maximum timestep (minutes, default 10.0)\nspread_rate_adj: Spread rate adjustment factor (default 1.0, multiplies base spread rate)\ncallback: Optional callback function(state, t, dt, iteration) called each timestep\n\n\n\n\n\n\nsimulate_full! {#simulate_full!}\n\n\nsimulate_full!(\n    state::FireState{T},\n    fuel_ids::AbstractMatrix{Int},\n    fuel_table::FuelModelTable{T},\n    weather_interp::WeatherInterpolator{T},\n    slope::AbstractMatrix{T},\n    aspect::AbstractMatrix{T},\n    t_start::T,\n    t_stop::T;\n    canopy::Union{Nothing, CanopyGrid{T}} = nothing,\n    config::SimulationConfig{T} = SimulationConfig{T}(),\n    dt_initial::T = one(T),\n    target_cfl::T = T(0.9),\n    dt_max::T = T(10),\n    spread_rate_adj::T = one(T),\n    callback::Union{Nothing, Function} = nothing,\n    rng::AbstractRNG = Random.default_rng()\n)\nRun full fire simulation with crown fire, spotting, and weather interpolation.\n\nArguments\n\nstate: Fire state (modified in place)\nfuel_ids: Matrix of fuel model IDs for each cell\nfuel_table: Fuel model lookup table\nweather_interp: Weather interpolator for spatially/temporally varying weather\nslope: Slope in degrees for each cell\naspect: Aspect direction in degrees for each cell\nt_start: Start time (minutes)\nt_stop: Stop time (minutes)\ncanopy: Optional canopy properties grid (required if crown fire enabled)\nconfig: Simulation configuration (crown fire, spotting settings)\ndt_initial: Initial timestep (minutes, default 1.0)\ntarget_cfl: Target CFL number (default 0.9)\ndt_max: Maximum timestep (minutes, default 10.0)\nspread_rate_adj: Spread rate adjustment factor (default 1.0, multiplies base spread rate)\ncallback: Optional callback function(state, t, dt, iteration) called each timestep\nrng: Random number generator for stochastic processes\n\n\n\nReturns\n\nspot_tracker: SpotFireTracker with any remaining pending spot fires\n\n\n\n\n\n\nsimulate_full_uniform! {#simulate_full_uniform!}\n\n\nsimulate_full_uniform!(\n    state::FireState{T},\n    fuel_id::Int,\n    fuel_table::FuelModelTable{T},\n    weather::ConstantWeather{T},\n    slope_deg::T,\n    aspect_deg::T,\n    t_start::T,\n    t_stop::T;\n    canopy_cbd::T = zero(T),\n    canopy_cbh::T = zero(T),\n    canopy_cc::T = zero(T),\n    canopy_ch::T = zero(T),\n    config::SimulationConfig{T} = SimulationConfig{T}(),\n    kwargs...\n)\nRun full simulation with uniform conditions across the domain.\n\n\n\n\nsimulate_gpu! {#simulate_gpu!}\n\n\nsimulate_gpu!(\n    state::FireState{T},\n    fuel_ids::AbstractMatrix{Int},\n    fuel_array::FuelModelArray{T},\n    weather::ConstantWeather{T},\n    slope::AbstractMatrix{T},\n    aspect::AbstractMatrix{T},\n    t_start::T,\n    t_stop::T;\n    kwargs...\n)\nGPU-accelerated fire simulation. Requires loading KernelAbstractions and Adapt:\nusing KernelAbstractions, Adapt\nUses KernelAbstractions.jl kernels for velocity calculation, CFL reduction, and RK2 level set integration. The narrow band is managed on the CPU, with an active mask uploaded to GPU each timestep.\nSee also: simulate!, simulate_gpu_uniform!\n\n\n\n\nsimulate_gpu_uniform! {#simulate_gpu_uniform!}\n\n\nsimulate_gpu_uniform!(\n    state::FireState{T},\n    fuel_id::Int,\n    fuel_array::FuelModelArray{T},\n    weather::ConstantWeather{T},\n    slope_deg::T,\n    aspect_deg::T,\n    t_start::T,\n    t_stop::T;\n    kwargs...\n)\nGPU-accelerated simulation with uniform fuel, slope, and aspect. Requires loading KernelAbstractions and Adapt.\nSee also: simulate_gpu!\n\n\n\n\nsimulate_uniform! {#simulate_uniform!}\n\n\nsimulate_uniform!(\n    state::FireState{T},\n    fuel_id::Int,\n    fuel_table::FuelModelTable{T},\n    weather::ConstantWeather{T},\n    slope_deg::T,\n    aspect_deg::T,\n    t_start::T,\n    t_stop::T;\n    kwargs...\n)\nRun simulation with uniform fuel, slope, and aspect across the domain.\n\n\n\n\nsimulate_with_suppression! {#simulate_with_suppression!}\n\n\nsimulate_with_suppression!(\n    state::FireState{T},\n    suppression::SuppressionState{T},\n    fuel_ids::AbstractMatrix{Int},\n    fuel_table::FuelModelTable{T},\n    weather::ConstantWeather{T},\n    slope::AbstractMatrix{T},\n    aspect::AbstractMatrix{T},\n    t_start::T,\n    t_stop::T;\n    dt_initial::T = one(T),\n    target_cfl::T = T(0.9),\n    dt_max::T = T(10),\n    callback::Union{Nothing, Function} = nothing\n)\nRun fire simulation with active suppression.\n\n\n\n\nsurface_spread_rate\n\n\nsurface_spread_rate(\n    fm::FuelModel{T},\n    M1::T, M10::T, M100::T,\n    MLH::T, MLW::T,\n    wsmf::T,\n    tanslp2::T;\n    adj::T = one(T)\n) -&gt; SpreadResult{T}\nCalculate surface fire spread rate using the Rothermel (1972) model.\n\nArguments\n\nfm: Fuel model with pre-computed coefficients\nM1: 1-hour dead fuel moisture (fraction, e.g., 0.06 for 6%)\nM10: 10-hour dead fuel moisture (fraction)\nM100: 100-hour dead fuel moisture (fraction)\nMLH: Live herbaceous moisture (fraction)\nMLW: Live woody moisture (fraction)\nwsmf: Mid-flame wind speed (ft/min)\ntanslp2: tan²(slope angle)\nadj: Adjustment factor (default 1.0)\n\n\n\nReturns\n\nSpreadResult with velocity, reaction intensity, heat per unit area, and fireline intensity\n\nImplementation follows elmfire_spread_rate.f90:13-132.\nsurface_spread_rate(\n    fm::FuelModel{T},\n    moisture::NTuple{5,T},\n    wsmf::T,\n    tanslp2::T;\n    adj::T = one(T)\n) -&gt; SpreadResult{T}\nConvenience method accepting moisture as tuple (M1, M10, M100, MLH, MLW).\n\n\n\n\n\nsurface_spread_rate_flat\n\n\nsurface_spread_rate_flat(\n    fuel_arr::FuelModelArray{T}, fuel_index::Int, mc_index::Int,\n    M1::T, M10::T, M100::T, MLH::T, MLW::T,\n    wsmf::T, tanslp2::T, adj::T\n) -&gt; Tuple{T, T, T}\nCompute surface fire spread rate from a FuelModelArray using dense array indexing. This variant is designed for GPU kernels where Dict-based FuelModel lookup is not available.\nReturns (velocity, vs0, flin) as a tuple instead of a SpreadResult struct.\n\nArguments\n\nfuel_arr: Dense fuel model array\nfuel_index: Row index in fuel_arr (from fuel_arr.fuel_id_to_index[fuel_id])\nmc_index: Moisture class index (live_moisture_class - 29)\nM1, M10, M100, MLH, MLW: Fuel moisture fractions\nwsmf: Mid-flame wind speed (ft/min)\ntanslp2: tan²(slope angle)\nadj: Spread rate adjustment factor\n\n\n\n\n\n\ntag_band! {#tag_band!}\n\n\ntag_band!(nb::NarrowBand, center::CartesianIndex{2}, nx::Int, ny::Int, padding::Int=2)\nAdd cells within band_thickness of center to the active set.\n\n\n\n\ntransport_ember\n\n\ntransport_ember(\n    x0::T, y0::T,\n    ws20::T,\n    wd20::T,\n    spotting_distance::T,\n    cellsize::T,\n    ncols::Int, nrows::Int;\n    rng::AbstractRNG = Random.default_rng()\n) -&gt; Tuple{Int, Int, T}\nTransport a single ember from source location to landing location.\n\nArguments\n\nx0, y0: Source location (in grid units, 1-based)\nws20: 20-ft wind speed (mph)\nwd20: Wind direction (degrees, FROM convention)\nspotting_distance: Transport distance (m)\ncellsize: Cell size (ft)\nncols, nrows: Grid dimensions\n\n\n\nReturns\n\n(ix, iy, dist): Landing grid indices and actual distance traveled\n\n\n\n\n\n\nuntag_isolated! {#untag_isolated!}\n\n\nuntag_isolated!(\n    nb::NarrowBand,\n    phi::AbstractMatrix{T},\n    burned::Union{AbstractMatrix{Bool}, BitMatrix},\n    padding::Int = 0\n)\nRemove cells from the active set that are:\n\nAlready burned (φ ≤ 0) and have no unburned neighbors\nFar from the fire front and won’t affect propagation\n\nNote: The active set uses padded coordinates if padding &gt; 0, but the burned matrix uses grid coordinates. This function handles the conversion.\nUses swap-and-compact on the active list for zero-allocation removal.\n\n\n\n\nupdate_suppression_state! {#update_suppression_state!}\n\n\nupdate_suppression_state!(\n    suppression::SuppressionState{T},\n    fire_state::FireState{T},\n    dt::T,\n    t::T\n)\nUpdate suppression state: move resources, construct lines, etc.\n\n\n\n\nupdate_wui_state! {#update_wui_state!}\n\n\nupdate_wui_state!(\n    wui_grid::WUIGrid{T},\n    fire_state::FireState{T},\n    weather::ConstantWeather{T},\n    t::T,\n    dt::T,\n    rng::AbstractRNG\n) -&gt; Vector{BuildingIgnitionResult{T}}\nUpdate the WUI grid based on fire state and check for building ignitions.\n\nArguments\n\nwui_grid: WUI grid (modified in place)\nfire_state: Current fire simulation state\nweather: Weather conditions\nt: Current time (minutes)\ndt: Time step (minutes)\nrng: Random number generator\n\n\n\nReturns\n\nVector of new building ignitions during this time step\n\n\n\n\n\n\nvelocity_at_angle\n\n\nvelocity_at_angle(es::EllipticalSpread{T}, theta::T) -&gt; T\nCalculate fire spread rate at angle theta from the wind direction. theta = 0 is head fire (downwind), theta = π is backing fire (upwind).\n\n\n\n\nvelocity_components\n\n\nvelocity_components(\n    head_velocity::T,\n    back_velocity::T,\n    wind_direction_rad::T,\n    normal_x::T,\n    normal_y::T\n) -&gt; Tuple{T, T}\nCalculate velocity components (ux, uy) in grid coordinates from fire spread parameters.\n\nArguments\n\nhead_velocity: Head fire spread rate (ft/min)\nback_velocity: Backing fire spread rate (ft/min)\nwind_direction_rad: Wind direction in radians (meteorological convention)\nnormal_x, normal_y: Unit normal vector to the fire front\n\n\n\nReturns\n\n(ux, uy): Velocity components in grid coordinates (ft/min)\n\n\n\n\n\n\nwind_adjustment_factor\n\n\nwind_adjustment_factor(fuel_bed_depth::T) -&gt; T\nCalculate wind adjustment factor (WAF) from 20-ft wind to mid-flame wind.\nUses the unsheltered (no canopy) formula: WAF = 1.83 / ln((20 + 0.36H) / (0.13H)) where H is the fuel bed depth in feet.\nFor sheltered conditions (with canopy), use a lookup table or more complex formula.\n\n\n\n\nwrite_fire_perimeter\n\n\nwrite_fire_perimeter(path::String, state::FireState, metadata::GeoMetadata;\n                     format::Symbol=:geojson)\nWrite the fire perimeter to a GeoJSON or other format.\n\nArguments\n\npath: Output file path\nstate: Fire simulation state\nmetadata: Geospatial metadata for coordinate conversion\nformat: Output format (:geojson supported)\n\n\n\n\n\n\nwrite_geotiff\n\n\nwrite_geotiff(path::String, data::AbstractMatrix{T}, metadata::GeoMetadata{T})\nWrite a matrix to a GeoTIFF file with the given metadata.\nwrite_geotiff(path::String, raster::GeoRaster{T})\nWrite a GeoRaster to a GeoTIFF file.",
    "crumbs": [
      "API",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>API</span>"
    ]
  },
  {
    "objectID": "api.html#constants",
    "href": "api.html#constants",
    "title": "API",
    "section": "Constants",
    "text": "Constants\n\nBTUPFT2MIN_TO_KWPM2\n\n\nFloat64 &lt;: AbstractFloat &lt;: Real\n64-bit floating point number type (IEEE 754 standard). Binary format is 1 sign, 11 exponent, 52 fraction bits. See bitstring, signbit, exponent, frexp, and significand to access various bits.\nThis is the default for floating point literals, 1.0 isa Float64, and for many operations such as 1/2, 2pi, log(2), range(0,90,length=4). Unlike integers, this default does not change with Sys.WORD_SIZE.\nThe exponent for scientific notation can be entered as e or E, thus 2e3 === 2.0E3 === 2.0 * 10^3. Doing so is strongly preferred over 10^n because integers overflow, thus 2.0 * 10^19 &lt; 0 but 2e19 &gt; 0.\nSee also Inf, NaN, floatmax, Float32, Complex.\nFloat64(x [, mode::RoundingMode])\nCreate a Float64 from x. If x is not exactly representable then mode determines how x is rounded.\n\nExamples\njulia&gt; Float64(pi, RoundDown)\n3.141592653589793\n\njulia&gt; Float64(pi, RoundUp)\n3.1415926535897936\nSee RoundingMode for available rounding modes.\n\n\n\n\n\nFT_TO_M\n\n\nFloat64 &lt;: AbstractFloat &lt;: Real\n64-bit floating point number type (IEEE 754 standard). Binary format is 1 sign, 11 exponent, 52 fraction bits. See bitstring, signbit, exponent, frexp, and significand to access various bits.\nThis is the default for floating point literals, 1.0 isa Float64, and for many operations such as 1/2, 2pi, log(2), range(0,90,length=4). Unlike integers, this default does not change with Sys.WORD_SIZE.\nThe exponent for scientific notation can be entered as e or E, thus 2e3 === 2.0E3 === 2.0 * 10^3. Doing so is strongly preferred over 10^n because integers overflow, thus 2.0 * 10^19 &lt; 0 but 2e19 &gt; 0.\nSee also Inf, NaN, floatmax, Float32, Complex.\nFloat64(x [, mode::RoundingMode])\nCreate a Float64 from x. If x is not exactly representable then mode determines how x is rounded.\n\nExamples\njulia&gt; Float64(pi, RoundDown)\n3.141592653589793\n\njulia&gt; Float64(pi, RoundUp)\n3.1415926535897936\nSee RoundingMode for available rounding modes.\n\n\n\n\n\nM_TO_FT\n\n\nFloat64 &lt;: AbstractFloat &lt;: Real\n64-bit floating point number type (IEEE 754 standard). Binary format is 1 sign, 11 exponent, 52 fraction bits. See bitstring, signbit, exponent, frexp, and significand to access various bits.\nThis is the default for floating point literals, 1.0 isa Float64, and for many operations such as 1/2, 2pi, log(2), range(0,90,length=4). Unlike integers, this default does not change with Sys.WORD_SIZE.\nThe exponent for scientific notation can be entered as e or E, thus 2e3 === 2.0E3 === 2.0 * 10^3. Doing so is strongly preferred over 10^n because integers overflow, thus 2.0 * 10^19 &lt; 0 but 2e19 &gt; 0.\nSee also Inf, NaN, floatmax, Float32, Complex.\nFloat64(x [, mode::RoundingMode])\nCreate a Float64 from x. If x is not exactly representable then mode determines how x is rounded.\n\nExamples\njulia&gt; Float64(pi, RoundDown)\n3.141592653589793\n\njulia&gt; Float64(pi, RoundUp)\n3.1415926535897936\nSee RoundingMode for available rounding modes.\n\n\n\n\n\nPI\n\n\nFloat64 &lt;: AbstractFloat &lt;: Real\n64-bit floating point number type (IEEE 754 standard). Binary format is 1 sign, 11 exponent, 52 fraction bits. See bitstring, signbit, exponent, frexp, and significand to access various bits.\nThis is the default for floating point literals, 1.0 isa Float64, and for many operations such as 1/2, 2pi, log(2), range(0,90,length=4). Unlike integers, this default does not change with Sys.WORD_SIZE.\nThe exponent for scientific notation can be entered as e or E, thus 2e3 === 2.0E3 === 2.0 * 10^3. Doing so is strongly preferred over 10^n because integers overflow, thus 2.0 * 10^19 &lt; 0 but 2e19 &gt; 0.\nSee also Inf, NaN, floatmax, Float32, Complex.\nFloat64(x [, mode::RoundingMode])\nCreate a Float64 from x. If x is not exactly representable then mode determines how x is rounded.\n\nExamples\njulia&gt; Float64(pi, RoundDown)\n3.141592653589793\n\njulia&gt; Float64(pi, RoundUp)\n3.1415926535897936\nSee RoundingMode for available rounding modes.\n\n\n\n\n\nPIO180\n\n\nFloat64 &lt;: AbstractFloat &lt;: Real\n64-bit floating point number type (IEEE 754 standard). Binary format is 1 sign, 11 exponent, 52 fraction bits. See bitstring, signbit, exponent, frexp, and significand to access various bits.\nThis is the default for floating point literals, 1.0 isa Float64, and for many operations such as 1/2, 2pi, log(2), range(0,90,length=4). Unlike integers, this default does not change with Sys.WORD_SIZE.\nThe exponent for scientific notation can be entered as e or E, thus 2e3 === 2.0E3 === 2.0 * 10^3. Doing so is strongly preferred over 10^n because integers overflow, thus 2.0 * 10^19 &lt; 0 but 2e19 &gt; 0.\nSee also Inf, NaN, floatmax, Float32, Complex.\nFloat64(x [, mode::RoundingMode])\nCreate a Float64 from x. If x is not exactly representable then mode determines how x is rounded.\n\nExamples\njulia&gt; Float64(pi, RoundDown)\n3.141592653589793\n\njulia&gt; Float64(pi, RoundUp)\n3.1415926535897936\nSee RoundingMode for available rounding modes.",
    "crumbs": [
      "API",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>API</span>"
    ]
  },
  {
    "objectID": "changelog.html",
    "href": "changelog.html",
    "title": "Changelog",
    "section": "",
    "text": "Unreleased",
    "crumbs": [
      "Reference",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Changelog</span>"
    ]
  }
]